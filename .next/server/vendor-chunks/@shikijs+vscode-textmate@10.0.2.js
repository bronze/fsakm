"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@shikijs+vscode-textmate@10.0.2";
exports.ids = ["vendor-chunks/@shikijs+vscode-textmate@10.0.2"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@shikijs+vscode-textmate@10.0.2/node_modules/@shikijs/vscode-textmate/dist/index.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@shikijs+vscode-textmate@10.0.2/node_modules/@shikijs/vscode-textmate/dist/index.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EncodedTokenMetadata: () => (/* binding */ EncodedTokenMetadata),\n/* harmony export */   FindOption: () => (/* binding */ FindOption),\n/* harmony export */   FontStyle: () => (/* binding */ FontStyle),\n/* harmony export */   INITIAL: () => (/* binding */ INITIAL),\n/* harmony export */   Registry: () => (/* binding */ Registry),\n/* harmony export */   Theme: () => (/* binding */ Theme),\n/* harmony export */   disposeOnigString: () => (/* binding */ disposeOnigString)\n/* harmony export */ });\n// src/utils.ts\nfunction clone(something) {\n  return doClone(something);\n}\nfunction doClone(something) {\n  if (Array.isArray(something)) {\n    return cloneArray(something);\n  }\n  if (something instanceof RegExp) {\n    return something;\n  }\n  if (typeof something === \"object\") {\n    return cloneObj(something);\n  }\n  return something;\n}\nfunction cloneArray(arr) {\n  let r = [];\n  for (let i = 0, len = arr.length; i < len; i++) {\n    r[i] = doClone(arr[i]);\n  }\n  return r;\n}\nfunction cloneObj(obj) {\n  let r = {};\n  for (let key in obj) {\n    r[key] = doClone(obj[key]);\n  }\n  return r;\n}\nfunction mergeObjects(target, ...sources) {\n  sources.forEach((source) => {\n    for (let key in source) {\n      target[key] = source[key];\n    }\n  });\n  return target;\n}\nfunction basename(path) {\n  const idx = ~path.lastIndexOf(\"/\") || ~path.lastIndexOf(\"\\\\\");\n  if (idx === 0) {\n    return path;\n  } else if (~idx === path.length - 1) {\n    return basename(path.substring(0, path.length - 1));\n  } else {\n    return path.substr(~idx + 1);\n  }\n}\nvar CAPTURING_REGEX_SOURCE = /\\$(\\d+)|\\${(\\d+):\\/(downcase|upcase)}/g;\nvar RegexSource = class {\n  static hasCaptures(regexSource) {\n    if (regexSource === null) {\n      return false;\n    }\n    CAPTURING_REGEX_SOURCE.lastIndex = 0;\n    return CAPTURING_REGEX_SOURCE.test(regexSource);\n  }\n  static replaceCaptures(regexSource, captureSource, captureIndices) {\n    return regexSource.replace(CAPTURING_REGEX_SOURCE, (match, index, commandIndex, command) => {\n      let capture = captureIndices[parseInt(index || commandIndex, 10)];\n      if (capture) {\n        let result = captureSource.substring(capture.start, capture.end);\n        while (result[0] === \".\") {\n          result = result.substring(1);\n        }\n        switch (command) {\n          case \"downcase\":\n            return result.toLowerCase();\n          case \"upcase\":\n            return result.toUpperCase();\n          default:\n            return result;\n        }\n      } else {\n        return match;\n      }\n    });\n  }\n};\nfunction strcmp(a, b) {\n  if (a < b) {\n    return -1;\n  }\n  if (a > b) {\n    return 1;\n  }\n  return 0;\n}\nfunction strArrCmp(a, b) {\n  if (a === null && b === null) {\n    return 0;\n  }\n  if (!a) {\n    return -1;\n  }\n  if (!b) {\n    return 1;\n  }\n  let len1 = a.length;\n  let len2 = b.length;\n  if (len1 === len2) {\n    for (let i = 0; i < len1; i++) {\n      let res = strcmp(a[i], b[i]);\n      if (res !== 0) {\n        return res;\n      }\n    }\n    return 0;\n  }\n  return len1 - len2;\n}\nfunction isValidHexColor(hex) {\n  if (/^#[0-9a-f]{6}$/i.test(hex)) {\n    return true;\n  }\n  if (/^#[0-9a-f]{8}$/i.test(hex)) {\n    return true;\n  }\n  if (/^#[0-9a-f]{3}$/i.test(hex)) {\n    return true;\n  }\n  if (/^#[0-9a-f]{4}$/i.test(hex)) {\n    return true;\n  }\n  return false;\n}\nfunction escapeRegExpCharacters(value) {\n  return value.replace(/[\\-\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, \"\\\\$&\");\n}\nvar CachedFn = class {\n  constructor(fn) {\n    this.fn = fn;\n  }\n  cache = /* @__PURE__ */ new Map();\n  get(key) {\n    if (this.cache.has(key)) {\n      return this.cache.get(key);\n    }\n    const value = this.fn(key);\n    this.cache.set(key, value);\n    return value;\n  }\n};\n\n// src/theme.ts\nvar Theme = class {\n  constructor(_colorMap, _defaults, _root) {\n    this._colorMap = _colorMap;\n    this._defaults = _defaults;\n    this._root = _root;\n  }\n  static createFromRawTheme(source, colorMap) {\n    return this.createFromParsedTheme(parseTheme(source), colorMap);\n  }\n  static createFromParsedTheme(source, colorMap) {\n    return resolveParsedThemeRules(source, colorMap);\n  }\n  _cachedMatchRoot = new CachedFn(\n    (scopeName) => this._root.match(scopeName)\n  );\n  getColorMap() {\n    return this._colorMap.getColorMap();\n  }\n  getDefaults() {\n    return this._defaults;\n  }\n  match(scopePath) {\n    if (scopePath === null) {\n      return this._defaults;\n    }\n    const scopeName = scopePath.scopeName;\n    const matchingTrieElements = this._cachedMatchRoot.get(scopeName);\n    const effectiveRule = matchingTrieElements.find(\n      (v) => _scopePathMatchesParentScopes(scopePath.parent, v.parentScopes)\n    );\n    if (!effectiveRule) {\n      return null;\n    }\n    return new StyleAttributes(\n      effectiveRule.fontStyle,\n      effectiveRule.foreground,\n      effectiveRule.background\n    );\n  }\n};\nvar ScopeStack = class _ScopeStack {\n  constructor(parent, scopeName) {\n    this.parent = parent;\n    this.scopeName = scopeName;\n  }\n  static push(path, scopeNames) {\n    for (const name of scopeNames) {\n      path = new _ScopeStack(path, name);\n    }\n    return path;\n  }\n  static from(...segments) {\n    let result = null;\n    for (let i = 0; i < segments.length; i++) {\n      result = new _ScopeStack(result, segments[i]);\n    }\n    return result;\n  }\n  push(scopeName) {\n    return new _ScopeStack(this, scopeName);\n  }\n  getSegments() {\n    let item = this;\n    const result = [];\n    while (item) {\n      result.push(item.scopeName);\n      item = item.parent;\n    }\n    result.reverse();\n    return result;\n  }\n  toString() {\n    return this.getSegments().join(\" \");\n  }\n  extends(other) {\n    if (this === other) {\n      return true;\n    }\n    if (this.parent === null) {\n      return false;\n    }\n    return this.parent.extends(other);\n  }\n  getExtensionIfDefined(base) {\n    const result = [];\n    let item = this;\n    while (item && item !== base) {\n      result.push(item.scopeName);\n      item = item.parent;\n    }\n    return item === base ? result.reverse() : void 0;\n  }\n};\nfunction _scopePathMatchesParentScopes(scopePath, parentScopes) {\n  if (parentScopes.length === 0) {\n    return true;\n  }\n  for (let index = 0; index < parentScopes.length; index++) {\n    let scopePattern = parentScopes[index];\n    let scopeMustMatch = false;\n    if (scopePattern === \">\") {\n      if (index === parentScopes.length - 1) {\n        return false;\n      }\n      scopePattern = parentScopes[++index];\n      scopeMustMatch = true;\n    }\n    while (scopePath) {\n      if (_matchesScope(scopePath.scopeName, scopePattern)) {\n        break;\n      }\n      if (scopeMustMatch) {\n        return false;\n      }\n      scopePath = scopePath.parent;\n    }\n    if (!scopePath) {\n      return false;\n    }\n    scopePath = scopePath.parent;\n  }\n  return true;\n}\nfunction _matchesScope(scopeName, scopePattern) {\n  return scopePattern === scopeName || scopeName.startsWith(scopePattern) && scopeName[scopePattern.length] === \".\";\n}\nvar StyleAttributes = class {\n  constructor(fontStyle, foregroundId, backgroundId) {\n    this.fontStyle = fontStyle;\n    this.foregroundId = foregroundId;\n    this.backgroundId = backgroundId;\n  }\n};\nfunction parseTheme(source) {\n  if (!source) {\n    return [];\n  }\n  if (!source.settings || !Array.isArray(source.settings)) {\n    return [];\n  }\n  let settings = source.settings;\n  let result = [], resultLen = 0;\n  for (let i = 0, len = settings.length; i < len; i++) {\n    let entry = settings[i];\n    if (!entry.settings) {\n      continue;\n    }\n    let scopes;\n    if (typeof entry.scope === \"string\") {\n      let _scope = entry.scope;\n      _scope = _scope.replace(/^[,]+/, \"\");\n      _scope = _scope.replace(/[,]+$/, \"\");\n      scopes = _scope.split(\",\");\n    } else if (Array.isArray(entry.scope)) {\n      scopes = entry.scope;\n    } else {\n      scopes = [\"\"];\n    }\n    let fontStyle = -1 /* NotSet */;\n    if (typeof entry.settings.fontStyle === \"string\") {\n      fontStyle = 0 /* None */;\n      let segments = entry.settings.fontStyle.split(\" \");\n      for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n        let segment = segments[j];\n        switch (segment) {\n          case \"italic\":\n            fontStyle = fontStyle | 1 /* Italic */;\n            break;\n          case \"bold\":\n            fontStyle = fontStyle | 2 /* Bold */;\n            break;\n          case \"underline\":\n            fontStyle = fontStyle | 4 /* Underline */;\n            break;\n          case \"strikethrough\":\n            fontStyle = fontStyle | 8 /* Strikethrough */;\n            break;\n        }\n      }\n    }\n    let foreground = null;\n    if (typeof entry.settings.foreground === \"string\" && isValidHexColor(entry.settings.foreground)) {\n      foreground = entry.settings.foreground;\n    }\n    let background = null;\n    if (typeof entry.settings.background === \"string\" && isValidHexColor(entry.settings.background)) {\n      background = entry.settings.background;\n    }\n    for (let j = 0, lenJ = scopes.length; j < lenJ; j++) {\n      let _scope = scopes[j].trim();\n      let segments = _scope.split(\" \");\n      let scope = segments[segments.length - 1];\n      let parentScopes = null;\n      if (segments.length > 1) {\n        parentScopes = segments.slice(0, segments.length - 1);\n        parentScopes.reverse();\n      }\n      result[resultLen++] = new ParsedThemeRule(\n        scope,\n        parentScopes,\n        i,\n        fontStyle,\n        foreground,\n        background\n      );\n    }\n  }\n  return result;\n}\nvar ParsedThemeRule = class {\n  constructor(scope, parentScopes, index, fontStyle, foreground, background) {\n    this.scope = scope;\n    this.parentScopes = parentScopes;\n    this.index = index;\n    this.fontStyle = fontStyle;\n    this.foreground = foreground;\n    this.background = background;\n  }\n};\nvar FontStyle = /* @__PURE__ */ ((FontStyle2) => {\n  FontStyle2[FontStyle2[\"NotSet\"] = -1] = \"NotSet\";\n  FontStyle2[FontStyle2[\"None\"] = 0] = \"None\";\n  FontStyle2[FontStyle2[\"Italic\"] = 1] = \"Italic\";\n  FontStyle2[FontStyle2[\"Bold\"] = 2] = \"Bold\";\n  FontStyle2[FontStyle2[\"Underline\"] = 4] = \"Underline\";\n  FontStyle2[FontStyle2[\"Strikethrough\"] = 8] = \"Strikethrough\";\n  return FontStyle2;\n})(FontStyle || {});\nfunction resolveParsedThemeRules(parsedThemeRules, _colorMap) {\n  parsedThemeRules.sort((a, b) => {\n    let r = strcmp(a.scope, b.scope);\n    if (r !== 0) {\n      return r;\n    }\n    r = strArrCmp(a.parentScopes, b.parentScopes);\n    if (r !== 0) {\n      return r;\n    }\n    return a.index - b.index;\n  });\n  let defaultFontStyle = 0 /* None */;\n  let defaultForeground = \"#000000\";\n  let defaultBackground = \"#ffffff\";\n  while (parsedThemeRules.length >= 1 && parsedThemeRules[0].scope === \"\") {\n    let incomingDefaults = parsedThemeRules.shift();\n    if (incomingDefaults.fontStyle !== -1 /* NotSet */) {\n      defaultFontStyle = incomingDefaults.fontStyle;\n    }\n    if (incomingDefaults.foreground !== null) {\n      defaultForeground = incomingDefaults.foreground;\n    }\n    if (incomingDefaults.background !== null) {\n      defaultBackground = incomingDefaults.background;\n    }\n  }\n  let colorMap = new ColorMap(_colorMap);\n  let defaults = new StyleAttributes(defaultFontStyle, colorMap.getId(defaultForeground), colorMap.getId(defaultBackground));\n  let root = new ThemeTrieElement(new ThemeTrieElementRule(0, null, -1 /* NotSet */, 0, 0), []);\n  for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n    let rule = parsedThemeRules[i];\n    root.insert(0, rule.scope, rule.parentScopes, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n  }\n  return new Theme(colorMap, defaults, root);\n}\nvar ColorMap = class {\n  _isFrozen;\n  _lastColorId;\n  _id2color;\n  _color2id;\n  constructor(_colorMap) {\n    this._lastColorId = 0;\n    this._id2color = [];\n    this._color2id = /* @__PURE__ */ Object.create(null);\n    if (Array.isArray(_colorMap)) {\n      this._isFrozen = true;\n      for (let i = 0, len = _colorMap.length; i < len; i++) {\n        this._color2id[_colorMap[i]] = i;\n        this._id2color[i] = _colorMap[i];\n      }\n    } else {\n      this._isFrozen = false;\n    }\n  }\n  getId(color) {\n    if (color === null) {\n      return 0;\n    }\n    color = color.toUpperCase();\n    let value = this._color2id[color];\n    if (value) {\n      return value;\n    }\n    if (this._isFrozen) {\n      throw new Error(`Missing color in color map - ${color}`);\n    }\n    value = ++this._lastColorId;\n    this._color2id[color] = value;\n    this._id2color[value] = color;\n    return value;\n  }\n  getColorMap() {\n    return this._id2color.slice(0);\n  }\n};\nvar emptyParentScopes = Object.freeze([]);\nvar ThemeTrieElementRule = class _ThemeTrieElementRule {\n  scopeDepth;\n  parentScopes;\n  fontStyle;\n  foreground;\n  background;\n  constructor(scopeDepth, parentScopes, fontStyle, foreground, background) {\n    this.scopeDepth = scopeDepth;\n    this.parentScopes = parentScopes || emptyParentScopes;\n    this.fontStyle = fontStyle;\n    this.foreground = foreground;\n    this.background = background;\n  }\n  clone() {\n    return new _ThemeTrieElementRule(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);\n  }\n  static cloneArr(arr) {\n    let r = [];\n    for (let i = 0, len = arr.length; i < len; i++) {\n      r[i] = arr[i].clone();\n    }\n    return r;\n  }\n  acceptOverwrite(scopeDepth, fontStyle, foreground, background) {\n    if (this.scopeDepth > scopeDepth) {\n      console.log(\"how did this happen?\");\n    } else {\n      this.scopeDepth = scopeDepth;\n    }\n    if (fontStyle !== -1 /* NotSet */) {\n      this.fontStyle = fontStyle;\n    }\n    if (foreground !== 0) {\n      this.foreground = foreground;\n    }\n    if (background !== 0) {\n      this.background = background;\n    }\n  }\n};\nvar ThemeTrieElement = class _ThemeTrieElement {\n  constructor(_mainRule, rulesWithParentScopes = [], _children = {}) {\n    this._mainRule = _mainRule;\n    this._children = _children;\n    this._rulesWithParentScopes = rulesWithParentScopes;\n  }\n  _rulesWithParentScopes;\n  static _cmpBySpecificity(a, b) {\n    if (a.scopeDepth !== b.scopeDepth) {\n      return b.scopeDepth - a.scopeDepth;\n    }\n    let aParentIndex = 0;\n    let bParentIndex = 0;\n    while (true) {\n      if (a.parentScopes[aParentIndex] === \">\") {\n        aParentIndex++;\n      }\n      if (b.parentScopes[bParentIndex] === \">\") {\n        bParentIndex++;\n      }\n      if (aParentIndex >= a.parentScopes.length || bParentIndex >= b.parentScopes.length) {\n        break;\n      }\n      const parentScopeLengthDiff = b.parentScopes[bParentIndex].length - a.parentScopes[aParentIndex].length;\n      if (parentScopeLengthDiff !== 0) {\n        return parentScopeLengthDiff;\n      }\n      aParentIndex++;\n      bParentIndex++;\n    }\n    return b.parentScopes.length - a.parentScopes.length;\n  }\n  match(scope) {\n    if (scope !== \"\") {\n      let dotIndex = scope.indexOf(\".\");\n      let head;\n      let tail;\n      if (dotIndex === -1) {\n        head = scope;\n        tail = \"\";\n      } else {\n        head = scope.substring(0, dotIndex);\n        tail = scope.substring(dotIndex + 1);\n      }\n      if (this._children.hasOwnProperty(head)) {\n        return this._children[head].match(tail);\n      }\n    }\n    const rules = this._rulesWithParentScopes.concat(this._mainRule);\n    rules.sort(_ThemeTrieElement._cmpBySpecificity);\n    return rules;\n  }\n  insert(scopeDepth, scope, parentScopes, fontStyle, foreground, background) {\n    if (scope === \"\") {\n      this._doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background);\n      return;\n    }\n    let dotIndex = scope.indexOf(\".\");\n    let head;\n    let tail;\n    if (dotIndex === -1) {\n      head = scope;\n      tail = \"\";\n    } else {\n      head = scope.substring(0, dotIndex);\n      tail = scope.substring(dotIndex + 1);\n    }\n    let child;\n    if (this._children.hasOwnProperty(head)) {\n      child = this._children[head];\n    } else {\n      child = new _ThemeTrieElement(this._mainRule.clone(), ThemeTrieElementRule.cloneArr(this._rulesWithParentScopes));\n      this._children[head] = child;\n    }\n    child.insert(scopeDepth + 1, tail, parentScopes, fontStyle, foreground, background);\n  }\n  _doInsertHere(scopeDepth, parentScopes, fontStyle, foreground, background) {\n    if (parentScopes === null) {\n      this._mainRule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n      return;\n    }\n    for (let i = 0, len = this._rulesWithParentScopes.length; i < len; i++) {\n      let rule = this._rulesWithParentScopes[i];\n      if (strArrCmp(rule.parentScopes, parentScopes) === 0) {\n        rule.acceptOverwrite(scopeDepth, fontStyle, foreground, background);\n        return;\n      }\n    }\n    if (fontStyle === -1 /* NotSet */) {\n      fontStyle = this._mainRule.fontStyle;\n    }\n    if (foreground === 0) {\n      foreground = this._mainRule.foreground;\n    }\n    if (background === 0) {\n      background = this._mainRule.background;\n    }\n    this._rulesWithParentScopes.push(new ThemeTrieElementRule(scopeDepth, parentScopes, fontStyle, foreground, background));\n  }\n};\n\n// src/encodedTokenAttributes.ts\nvar EncodedTokenMetadata = class _EncodedTokenMetadata {\n  static toBinaryStr(encodedTokenAttributes) {\n    return encodedTokenAttributes.toString(2).padStart(32, \"0\");\n  }\n  static print(encodedTokenAttributes) {\n    const languageId = _EncodedTokenMetadata.getLanguageId(encodedTokenAttributes);\n    const tokenType = _EncodedTokenMetadata.getTokenType(encodedTokenAttributes);\n    const fontStyle = _EncodedTokenMetadata.getFontStyle(encodedTokenAttributes);\n    const foreground = _EncodedTokenMetadata.getForeground(encodedTokenAttributes);\n    const background = _EncodedTokenMetadata.getBackground(encodedTokenAttributes);\n    console.log({\n      languageId,\n      tokenType,\n      fontStyle,\n      foreground,\n      background\n    });\n  }\n  static getLanguageId(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 255 /* LANGUAGEID_MASK */) >>> 0 /* LANGUAGEID_OFFSET */;\n  }\n  static getTokenType(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 768 /* TOKEN_TYPE_MASK */) >>> 8 /* TOKEN_TYPE_OFFSET */;\n  }\n  static containsBalancedBrackets(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 1024 /* BALANCED_BRACKETS_MASK */) !== 0;\n  }\n  static getFontStyle(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 30720 /* FONT_STYLE_MASK */) >>> 11 /* FONT_STYLE_OFFSET */;\n  }\n  static getForeground(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 16744448 /* FOREGROUND_MASK */) >>> 15 /* FOREGROUND_OFFSET */;\n  }\n  static getBackground(encodedTokenAttributes) {\n    return (encodedTokenAttributes & 4278190080 /* BACKGROUND_MASK */) >>> 24 /* BACKGROUND_OFFSET */;\n  }\n  /**\n   * Updates the fields in `metadata`.\n   * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.\n   */\n  static set(encodedTokenAttributes, languageId, tokenType, containsBalancedBrackets, fontStyle, foreground, background) {\n    let _languageId = _EncodedTokenMetadata.getLanguageId(encodedTokenAttributes);\n    let _tokenType = _EncodedTokenMetadata.getTokenType(encodedTokenAttributes);\n    let _containsBalancedBracketsBit = _EncodedTokenMetadata.containsBalancedBrackets(encodedTokenAttributes) ? 1 : 0;\n    let _fontStyle = _EncodedTokenMetadata.getFontStyle(encodedTokenAttributes);\n    let _foreground = _EncodedTokenMetadata.getForeground(encodedTokenAttributes);\n    let _background = _EncodedTokenMetadata.getBackground(encodedTokenAttributes);\n    if (languageId !== 0) {\n      _languageId = languageId;\n    }\n    if (tokenType !== 8 /* NotSet */) {\n      _tokenType = fromOptionalTokenType(tokenType);\n    }\n    if (containsBalancedBrackets !== null) {\n      _containsBalancedBracketsBit = containsBalancedBrackets ? 1 : 0;\n    }\n    if (fontStyle !== -1 /* NotSet */) {\n      _fontStyle = fontStyle;\n    }\n    if (foreground !== 0) {\n      _foreground = foreground;\n    }\n    if (background !== 0) {\n      _background = background;\n    }\n    return (_languageId << 0 /* LANGUAGEID_OFFSET */ | _tokenType << 8 /* TOKEN_TYPE_OFFSET */ | _containsBalancedBracketsBit << 10 /* BALANCED_BRACKETS_OFFSET */ | _fontStyle << 11 /* FONT_STYLE_OFFSET */ | _foreground << 15 /* FOREGROUND_OFFSET */ | _background << 24 /* BACKGROUND_OFFSET */) >>> 0;\n  }\n};\nfunction toOptionalTokenType(standardType) {\n  return standardType;\n}\nfunction fromOptionalTokenType(standardType) {\n  return standardType;\n}\n\n// src/matcher.ts\nfunction createMatchers(selector, matchesName) {\n  const results = [];\n  const tokenizer = newTokenizer(selector);\n  let token = tokenizer.next();\n  while (token !== null) {\n    let priority = 0;\n    if (token.length === 2 && token.charAt(1) === \":\") {\n      switch (token.charAt(0)) {\n        case \"R\":\n          priority = 1;\n          break;\n        case \"L\":\n          priority = -1;\n          break;\n        default:\n          console.log(`Unknown priority ${token} in scope selector`);\n      }\n      token = tokenizer.next();\n    }\n    let matcher = parseConjunction();\n    results.push({ matcher, priority });\n    if (token !== \",\") {\n      break;\n    }\n    token = tokenizer.next();\n  }\n  return results;\n  function parseOperand() {\n    if (token === \"-\") {\n      token = tokenizer.next();\n      const expressionToNegate = parseOperand();\n      return (matcherInput) => !!expressionToNegate && !expressionToNegate(matcherInput);\n    }\n    if (token === \"(\") {\n      token = tokenizer.next();\n      const expressionInParents = parseInnerExpression();\n      if (token === \")\") {\n        token = tokenizer.next();\n      }\n      return expressionInParents;\n    }\n    if (isIdentifier(token)) {\n      const identifiers = [];\n      do {\n        identifiers.push(token);\n        token = tokenizer.next();\n      } while (isIdentifier(token));\n      return (matcherInput) => matchesName(identifiers, matcherInput);\n    }\n    return null;\n  }\n  function parseConjunction() {\n    const matchers = [];\n    let matcher = parseOperand();\n    while (matcher) {\n      matchers.push(matcher);\n      matcher = parseOperand();\n    }\n    return (matcherInput) => matchers.every((matcher2) => matcher2(matcherInput));\n  }\n  function parseInnerExpression() {\n    const matchers = [];\n    let matcher = parseConjunction();\n    while (matcher) {\n      matchers.push(matcher);\n      if (token === \"|\" || token === \",\") {\n        do {\n          token = tokenizer.next();\n        } while (token === \"|\" || token === \",\");\n      } else {\n        break;\n      }\n      matcher = parseConjunction();\n    }\n    return (matcherInput) => matchers.some((matcher2) => matcher2(matcherInput));\n  }\n}\nfunction isIdentifier(token) {\n  return !!token && !!token.match(/[\\w\\.:]+/);\n}\nfunction newTokenizer(input) {\n  let regex = /([LR]:|[\\w\\.:][\\w\\.:\\-]*|[\\,\\|\\-\\(\\)])/g;\n  let match = regex.exec(input);\n  return {\n    next: () => {\n      if (!match) {\n        return null;\n      }\n      const res = match[0];\n      match = regex.exec(input);\n      return res;\n    }\n  };\n}\n\n// src/onigLib.ts\nvar FindOption = /* @__PURE__ */ ((FindOption2) => {\n  FindOption2[FindOption2[\"None\"] = 0] = \"None\";\n  FindOption2[FindOption2[\"NotBeginString\"] = 1] = \"NotBeginString\";\n  FindOption2[FindOption2[\"NotEndString\"] = 2] = \"NotEndString\";\n  FindOption2[FindOption2[\"NotBeginPosition\"] = 4] = \"NotBeginPosition\";\n  FindOption2[FindOption2[\"DebugCall\"] = 8] = \"DebugCall\";\n  return FindOption2;\n})(FindOption || {});\nfunction disposeOnigString(str) {\n  if (typeof str.dispose === \"function\") {\n    str.dispose();\n  }\n}\n\n// src/grammar/grammarDependencies.ts\nvar TopLevelRuleReference = class {\n  constructor(scopeName) {\n    this.scopeName = scopeName;\n  }\n  toKey() {\n    return this.scopeName;\n  }\n};\nvar TopLevelRepositoryRuleReference = class {\n  constructor(scopeName, ruleName) {\n    this.scopeName = scopeName;\n    this.ruleName = ruleName;\n  }\n  toKey() {\n    return `${this.scopeName}#${this.ruleName}`;\n  }\n};\nvar ExternalReferenceCollector = class {\n  _references = [];\n  _seenReferenceKeys = /* @__PURE__ */ new Set();\n  get references() {\n    return this._references;\n  }\n  visitedRule = /* @__PURE__ */ new Set();\n  add(reference) {\n    const key = reference.toKey();\n    if (this._seenReferenceKeys.has(key)) {\n      return;\n    }\n    this._seenReferenceKeys.add(key);\n    this._references.push(reference);\n  }\n};\nvar ScopeDependencyProcessor = class {\n  constructor(repo, initialScopeName) {\n    this.repo = repo;\n    this.initialScopeName = initialScopeName;\n    this.seenFullScopeRequests.add(this.initialScopeName);\n    this.Q = [new TopLevelRuleReference(this.initialScopeName)];\n  }\n  seenFullScopeRequests = /* @__PURE__ */ new Set();\n  seenPartialScopeRequests = /* @__PURE__ */ new Set();\n  Q;\n  processQueue() {\n    const q = this.Q;\n    this.Q = [];\n    const deps = new ExternalReferenceCollector();\n    for (const dep of q) {\n      collectReferencesOfReference(dep, this.initialScopeName, this.repo, deps);\n    }\n    for (const dep of deps.references) {\n      if (dep instanceof TopLevelRuleReference) {\n        if (this.seenFullScopeRequests.has(dep.scopeName)) {\n          continue;\n        }\n        this.seenFullScopeRequests.add(dep.scopeName);\n        this.Q.push(dep);\n      } else {\n        if (this.seenFullScopeRequests.has(dep.scopeName)) {\n          continue;\n        }\n        if (this.seenPartialScopeRequests.has(dep.toKey())) {\n          continue;\n        }\n        this.seenPartialScopeRequests.add(dep.toKey());\n        this.Q.push(dep);\n      }\n    }\n  }\n};\nfunction collectReferencesOfReference(reference, baseGrammarScopeName, repo, result) {\n  const selfGrammar = repo.lookup(reference.scopeName);\n  if (!selfGrammar) {\n    if (reference.scopeName === baseGrammarScopeName) {\n      throw new Error(`No grammar provided for <${baseGrammarScopeName}>`);\n    }\n    return;\n  }\n  const baseGrammar = repo.lookup(baseGrammarScopeName);\n  if (reference instanceof TopLevelRuleReference) {\n    collectExternalReferencesInTopLevelRule({ baseGrammar, selfGrammar }, result);\n  } else {\n    collectExternalReferencesInTopLevelRepositoryRule(\n      reference.ruleName,\n      { baseGrammar, selfGrammar, repository: selfGrammar.repository },\n      result\n    );\n  }\n  const injections = repo.injections(reference.scopeName);\n  if (injections) {\n    for (const injection of injections) {\n      result.add(new TopLevelRuleReference(injection));\n    }\n  }\n}\nfunction collectExternalReferencesInTopLevelRepositoryRule(ruleName, context, result) {\n  if (context.repository && context.repository[ruleName]) {\n    const rule = context.repository[ruleName];\n    collectExternalReferencesInRules([rule], context, result);\n  }\n}\nfunction collectExternalReferencesInTopLevelRule(context, result) {\n  if (context.selfGrammar.patterns && Array.isArray(context.selfGrammar.patterns)) {\n    collectExternalReferencesInRules(\n      context.selfGrammar.patterns,\n      { ...context, repository: context.selfGrammar.repository },\n      result\n    );\n  }\n  if (context.selfGrammar.injections) {\n    collectExternalReferencesInRules(\n      Object.values(context.selfGrammar.injections),\n      { ...context, repository: context.selfGrammar.repository },\n      result\n    );\n  }\n}\nfunction collectExternalReferencesInRules(rules, context, result) {\n  for (const rule of rules) {\n    if (result.visitedRule.has(rule)) {\n      continue;\n    }\n    result.visitedRule.add(rule);\n    const patternRepository = rule.repository ? mergeObjects({}, context.repository, rule.repository) : context.repository;\n    if (Array.isArray(rule.patterns)) {\n      collectExternalReferencesInRules(rule.patterns, { ...context, repository: patternRepository }, result);\n    }\n    const include = rule.include;\n    if (!include) {\n      continue;\n    }\n    const reference = parseInclude(include);\n    switch (reference.kind) {\n      case 0 /* Base */:\n        collectExternalReferencesInTopLevelRule({ ...context, selfGrammar: context.baseGrammar }, result);\n        break;\n      case 1 /* Self */:\n        collectExternalReferencesInTopLevelRule(context, result);\n        break;\n      case 2 /* RelativeReference */:\n        collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, { ...context, repository: patternRepository }, result);\n        break;\n      case 3 /* TopLevelReference */:\n      case 4 /* TopLevelRepositoryReference */:\n        const selfGrammar = reference.scopeName === context.selfGrammar.scopeName ? context.selfGrammar : reference.scopeName === context.baseGrammar.scopeName ? context.baseGrammar : void 0;\n        if (selfGrammar) {\n          const newContext = { baseGrammar: context.baseGrammar, selfGrammar, repository: patternRepository };\n          if (reference.kind === 4 /* TopLevelRepositoryReference */) {\n            collectExternalReferencesInTopLevelRepositoryRule(reference.ruleName, newContext, result);\n          } else {\n            collectExternalReferencesInTopLevelRule(newContext, result);\n          }\n        } else {\n          if (reference.kind === 4 /* TopLevelRepositoryReference */) {\n            result.add(new TopLevelRepositoryRuleReference(reference.scopeName, reference.ruleName));\n          } else {\n            result.add(new TopLevelRuleReference(reference.scopeName));\n          }\n        }\n        break;\n    }\n  }\n}\nvar BaseReference = class {\n  kind = 0 /* Base */;\n};\nvar SelfReference = class {\n  kind = 1 /* Self */;\n};\nvar RelativeReference = class {\n  constructor(ruleName) {\n    this.ruleName = ruleName;\n  }\n  kind = 2 /* RelativeReference */;\n};\nvar TopLevelReference = class {\n  constructor(scopeName) {\n    this.scopeName = scopeName;\n  }\n  kind = 3 /* TopLevelReference */;\n};\nvar TopLevelRepositoryReference = class {\n  constructor(scopeName, ruleName) {\n    this.scopeName = scopeName;\n    this.ruleName = ruleName;\n  }\n  kind = 4 /* TopLevelRepositoryReference */;\n};\nfunction parseInclude(include) {\n  if (include === \"$base\") {\n    return new BaseReference();\n  } else if (include === \"$self\") {\n    return new SelfReference();\n  }\n  const indexOfSharp = include.indexOf(\"#\");\n  if (indexOfSharp === -1) {\n    return new TopLevelReference(include);\n  } else if (indexOfSharp === 0) {\n    return new RelativeReference(include.substring(1));\n  } else {\n    const scopeName = include.substring(0, indexOfSharp);\n    const ruleName = include.substring(indexOfSharp + 1);\n    return new TopLevelRepositoryReference(scopeName, ruleName);\n  }\n}\n\n// src/rule.ts\nvar HAS_BACK_REFERENCES = /\\\\(\\d+)/;\nvar BACK_REFERENCING_END = /\\\\(\\d+)/g;\nvar ruleIdSymbol = Symbol(\"RuleId\");\nvar endRuleId = -1;\nvar whileRuleId = -2;\nfunction ruleIdFromNumber(id) {\n  return id;\n}\nfunction ruleIdToNumber(id) {\n  return id;\n}\nvar Rule = class {\n  $location;\n  id;\n  _nameIsCapturing;\n  _name;\n  _contentNameIsCapturing;\n  _contentName;\n  constructor($location, id, name, contentName) {\n    this.$location = $location;\n    this.id = id;\n    this._name = name || null;\n    this._nameIsCapturing = RegexSource.hasCaptures(this._name);\n    this._contentName = contentName || null;\n    this._contentNameIsCapturing = RegexSource.hasCaptures(this._contentName);\n  }\n  get debugName() {\n    const location = this.$location ? `${basename(this.$location.filename)}:${this.$location.line}` : \"unknown\";\n    return `${this.constructor.name}#${this.id} @ ${location}`;\n  }\n  getName(lineText, captureIndices) {\n    if (!this._nameIsCapturing || this._name === null || lineText === null || captureIndices === null) {\n      return this._name;\n    }\n    return RegexSource.replaceCaptures(this._name, lineText, captureIndices);\n  }\n  getContentName(lineText, captureIndices) {\n    if (!this._contentNameIsCapturing || this._contentName === null) {\n      return this._contentName;\n    }\n    return RegexSource.replaceCaptures(this._contentName, lineText, captureIndices);\n  }\n};\nvar CaptureRule = class extends Rule {\n  retokenizeCapturedWithRuleId;\n  constructor($location, id, name, contentName, retokenizeCapturedWithRuleId) {\n    super($location, id, name, contentName);\n    this.retokenizeCapturedWithRuleId = retokenizeCapturedWithRuleId;\n  }\n  dispose() {\n  }\n  collectPatterns(grammar, out) {\n    throw new Error(\"Not supported!\");\n  }\n  compile(grammar, endRegexSource) {\n    throw new Error(\"Not supported!\");\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    throw new Error(\"Not supported!\");\n  }\n};\nvar MatchRule = class extends Rule {\n  _match;\n  captures;\n  _cachedCompiledPatterns;\n  constructor($location, id, name, match, captures) {\n    super($location, id, name, null);\n    this._match = new RegExpSource(match, this.id);\n    this.captures = captures;\n    this._cachedCompiledPatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n  }\n  get debugMatchRegExp() {\n    return `${this._match.source}`;\n  }\n  collectPatterns(grammar, out) {\n    out.push(this._match);\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      this.collectPatterns(grammar, this._cachedCompiledPatterns);\n    }\n    return this._cachedCompiledPatterns;\n  }\n};\nvar IncludeOnlyRule = class extends Rule {\n  hasMissingPatterns;\n  patterns;\n  _cachedCompiledPatterns;\n  constructor($location, id, name, contentName, patterns) {\n    super($location, id, name, contentName);\n    this.patterns = patterns.patterns;\n    this.hasMissingPatterns = patterns.hasMissingPatterns;\n    this._cachedCompiledPatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n  }\n  collectPatterns(grammar, out) {\n    for (const pattern of this.patterns) {\n      const rule = grammar.getRule(pattern);\n      rule.collectPatterns(grammar, out);\n    }\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      this.collectPatterns(grammar, this._cachedCompiledPatterns);\n    }\n    return this._cachedCompiledPatterns;\n  }\n};\nvar BeginEndRule = class extends Rule {\n  _begin;\n  beginCaptures;\n  _end;\n  endHasBackReferences;\n  endCaptures;\n  applyEndPatternLast;\n  hasMissingPatterns;\n  patterns;\n  _cachedCompiledPatterns;\n  constructor($location, id, name, contentName, begin, beginCaptures, end, endCaptures, applyEndPatternLast, patterns) {\n    super($location, id, name, contentName);\n    this._begin = new RegExpSource(begin, this.id);\n    this.beginCaptures = beginCaptures;\n    this._end = new RegExpSource(end ? end : \"\\uFFFF\", -1);\n    this.endHasBackReferences = this._end.hasBackReferences;\n    this.endCaptures = endCaptures;\n    this.applyEndPatternLast = applyEndPatternLast || false;\n    this.patterns = patterns.patterns;\n    this.hasMissingPatterns = patterns.hasMissingPatterns;\n    this._cachedCompiledPatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n  }\n  get debugBeginRegExp() {\n    return `${this._begin.source}`;\n  }\n  get debugEndRegExp() {\n    return `${this._end.source}`;\n  }\n  getEndWithResolvedBackReferences(lineText, captureIndices) {\n    return this._end.resolveBackReferences(lineText, captureIndices);\n  }\n  collectPatterns(grammar, out) {\n    out.push(this._begin);\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar, endRegexSource).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar, endRegexSource) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      for (const pattern of this.patterns) {\n        const rule = grammar.getRule(pattern);\n        rule.collectPatterns(grammar, this._cachedCompiledPatterns);\n      }\n      if (this.applyEndPatternLast) {\n        this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end);\n      } else {\n        this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);\n      }\n    }\n    if (this._end.hasBackReferences) {\n      if (this.applyEndPatternLast) {\n        this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, endRegexSource);\n      } else {\n        this._cachedCompiledPatterns.setSource(0, endRegexSource);\n      }\n    }\n    return this._cachedCompiledPatterns;\n  }\n};\nvar BeginWhileRule = class extends Rule {\n  _begin;\n  beginCaptures;\n  whileCaptures;\n  _while;\n  whileHasBackReferences;\n  hasMissingPatterns;\n  patterns;\n  _cachedCompiledPatterns;\n  _cachedCompiledWhilePatterns;\n  constructor($location, id, name, contentName, begin, beginCaptures, _while, whileCaptures, patterns) {\n    super($location, id, name, contentName);\n    this._begin = new RegExpSource(begin, this.id);\n    this.beginCaptures = beginCaptures;\n    this.whileCaptures = whileCaptures;\n    this._while = new RegExpSource(_while, whileRuleId);\n    this.whileHasBackReferences = this._while.hasBackReferences;\n    this.patterns = patterns.patterns;\n    this.hasMissingPatterns = patterns.hasMissingPatterns;\n    this._cachedCompiledPatterns = null;\n    this._cachedCompiledWhilePatterns = null;\n  }\n  dispose() {\n    if (this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns.dispose();\n      this._cachedCompiledPatterns = null;\n    }\n    if (this._cachedCompiledWhilePatterns) {\n      this._cachedCompiledWhilePatterns.dispose();\n      this._cachedCompiledWhilePatterns = null;\n    }\n  }\n  get debugBeginRegExp() {\n    return `${this._begin.source}`;\n  }\n  get debugWhileRegExp() {\n    return `${this._while.source}`;\n  }\n  getWhileWithResolvedBackReferences(lineText, captureIndices) {\n    return this._while.resolveBackReferences(lineText, captureIndices);\n  }\n  collectPatterns(grammar, out) {\n    out.push(this._begin);\n  }\n  compile(grammar, endRegexSource) {\n    return this._getCachedCompiledPatterns(grammar).compile(grammar);\n  }\n  compileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledPatterns(grammar).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledPatterns(grammar) {\n    if (!this._cachedCompiledPatterns) {\n      this._cachedCompiledPatterns = new RegExpSourceList();\n      for (const pattern of this.patterns) {\n        const rule = grammar.getRule(pattern);\n        rule.collectPatterns(grammar, this._cachedCompiledPatterns);\n      }\n    }\n    return this._cachedCompiledPatterns;\n  }\n  compileWhile(grammar, endRegexSource) {\n    return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compile(grammar);\n  }\n  compileWhileAG(grammar, endRegexSource, allowA, allowG) {\n    return this._getCachedCompiledWhilePatterns(grammar, endRegexSource).compileAG(grammar, allowA, allowG);\n  }\n  _getCachedCompiledWhilePatterns(grammar, endRegexSource) {\n    if (!this._cachedCompiledWhilePatterns) {\n      this._cachedCompiledWhilePatterns = new RegExpSourceList();\n      this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while);\n    }\n    if (this._while.hasBackReferences) {\n      this._cachedCompiledWhilePatterns.setSource(0, endRegexSource ? endRegexSource : \"\\uFFFF\");\n    }\n    return this._cachedCompiledWhilePatterns;\n  }\n};\nvar RuleFactory = class _RuleFactory {\n  static createCaptureRule(helper, $location, name, contentName, retokenizeCapturedWithRuleId) {\n    return helper.registerRule((id) => {\n      return new CaptureRule($location, id, name, contentName, retokenizeCapturedWithRuleId);\n    });\n  }\n  static getCompiledRuleId(desc, helper, repository) {\n    if (!desc.id) {\n      helper.registerRule((id) => {\n        desc.id = id;\n        if (desc.match) {\n          return new MatchRule(\n            desc.$vscodeTextmateLocation,\n            desc.id,\n            desc.name,\n            desc.match,\n            _RuleFactory._compileCaptures(desc.captures, helper, repository)\n          );\n        }\n        if (typeof desc.begin === \"undefined\") {\n          if (desc.repository) {\n            repository = mergeObjects({}, repository, desc.repository);\n          }\n          let patterns = desc.patterns;\n          if (typeof patterns === \"undefined\" && desc.include) {\n            patterns = [{ include: desc.include }];\n          }\n          return new IncludeOnlyRule(\n            desc.$vscodeTextmateLocation,\n            desc.id,\n            desc.name,\n            desc.contentName,\n            _RuleFactory._compilePatterns(patterns, helper, repository)\n          );\n        }\n        if (desc.while) {\n          return new BeginWhileRule(\n            desc.$vscodeTextmateLocation,\n            desc.id,\n            desc.name,\n            desc.contentName,\n            desc.begin,\n            _RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository),\n            desc.while,\n            _RuleFactory._compileCaptures(desc.whileCaptures || desc.captures, helper, repository),\n            _RuleFactory._compilePatterns(desc.patterns, helper, repository)\n          );\n        }\n        return new BeginEndRule(\n          desc.$vscodeTextmateLocation,\n          desc.id,\n          desc.name,\n          desc.contentName,\n          desc.begin,\n          _RuleFactory._compileCaptures(desc.beginCaptures || desc.captures, helper, repository),\n          desc.end,\n          _RuleFactory._compileCaptures(desc.endCaptures || desc.captures, helper, repository),\n          desc.applyEndPatternLast,\n          _RuleFactory._compilePatterns(desc.patterns, helper, repository)\n        );\n      });\n    }\n    return desc.id;\n  }\n  static _compileCaptures(captures, helper, repository) {\n    let r = [];\n    if (captures) {\n      let maximumCaptureId = 0;\n      for (const captureId in captures) {\n        if (captureId === \"$vscodeTextmateLocation\") {\n          continue;\n        }\n        const numericCaptureId = parseInt(captureId, 10);\n        if (numericCaptureId > maximumCaptureId) {\n          maximumCaptureId = numericCaptureId;\n        }\n      }\n      for (let i = 0; i <= maximumCaptureId; i++) {\n        r[i] = null;\n      }\n      for (const captureId in captures) {\n        if (captureId === \"$vscodeTextmateLocation\") {\n          continue;\n        }\n        const numericCaptureId = parseInt(captureId, 10);\n        let retokenizeCapturedWithRuleId = 0;\n        if (captures[captureId].patterns) {\n          retokenizeCapturedWithRuleId = _RuleFactory.getCompiledRuleId(captures[captureId], helper, repository);\n        }\n        r[numericCaptureId] = _RuleFactory.createCaptureRule(helper, captures[captureId].$vscodeTextmateLocation, captures[captureId].name, captures[captureId].contentName, retokenizeCapturedWithRuleId);\n      }\n    }\n    return r;\n  }\n  static _compilePatterns(patterns, helper, repository) {\n    let r = [];\n    if (patterns) {\n      for (let i = 0, len = patterns.length; i < len; i++) {\n        const pattern = patterns[i];\n        let ruleId = -1;\n        if (pattern.include) {\n          const reference = parseInclude(pattern.include);\n          switch (reference.kind) {\n            case 0 /* Base */:\n            case 1 /* Self */:\n              ruleId = _RuleFactory.getCompiledRuleId(repository[pattern.include], helper, repository);\n              break;\n            case 2 /* RelativeReference */:\n              let localIncludedRule = repository[reference.ruleName];\n              if (localIncludedRule) {\n                ruleId = _RuleFactory.getCompiledRuleId(localIncludedRule, helper, repository);\n              } else {\n              }\n              break;\n            case 3 /* TopLevelReference */:\n            case 4 /* TopLevelRepositoryReference */:\n              const externalGrammarName = reference.scopeName;\n              const externalGrammarInclude = reference.kind === 4 /* TopLevelRepositoryReference */ ? reference.ruleName : null;\n              const externalGrammar = helper.getExternalGrammar(externalGrammarName, repository);\n              if (externalGrammar) {\n                if (externalGrammarInclude) {\n                  let externalIncludedRule = externalGrammar.repository[externalGrammarInclude];\n                  if (externalIncludedRule) {\n                    ruleId = _RuleFactory.getCompiledRuleId(externalIncludedRule, helper, externalGrammar.repository);\n                  } else {\n                  }\n                } else {\n                  ruleId = _RuleFactory.getCompiledRuleId(externalGrammar.repository.$self, helper, externalGrammar.repository);\n                }\n              } else {\n              }\n              break;\n          }\n        } else {\n          ruleId = _RuleFactory.getCompiledRuleId(pattern, helper, repository);\n        }\n        if (ruleId !== -1) {\n          const rule = helper.getRule(ruleId);\n          let skipRule = false;\n          if (rule instanceof IncludeOnlyRule || rule instanceof BeginEndRule || rule instanceof BeginWhileRule) {\n            if (rule.hasMissingPatterns && rule.patterns.length === 0) {\n              skipRule = true;\n            }\n          }\n          if (skipRule) {\n            continue;\n          }\n          r.push(ruleId);\n        }\n      }\n    }\n    return {\n      patterns: r,\n      hasMissingPatterns: (patterns ? patterns.length : 0) !== r.length\n    };\n  }\n};\nvar RegExpSource = class _RegExpSource {\n  source;\n  ruleId;\n  hasAnchor;\n  hasBackReferences;\n  _anchorCache;\n  constructor(regExpSource, ruleId) {\n    if (regExpSource && typeof regExpSource === \"string\") {\n      const len = regExpSource.length;\n      let lastPushedPos = 0;\n      let output = [];\n      let hasAnchor = false;\n      for (let pos = 0; pos < len; pos++) {\n        const ch = regExpSource.charAt(pos);\n        if (ch === \"\\\\\") {\n          if (pos + 1 < len) {\n            const nextCh = regExpSource.charAt(pos + 1);\n            if (nextCh === \"z\") {\n              output.push(regExpSource.substring(lastPushedPos, pos));\n              output.push(\"$(?!\\\\n)(?<!\\\\n)\");\n              lastPushedPos = pos + 2;\n            } else if (nextCh === \"A\" || nextCh === \"G\") {\n              hasAnchor = true;\n            }\n            pos++;\n          }\n        }\n      }\n      this.hasAnchor = hasAnchor;\n      if (lastPushedPos === 0) {\n        this.source = regExpSource;\n      } else {\n        output.push(regExpSource.substring(lastPushedPos, len));\n        this.source = output.join(\"\");\n      }\n    } else {\n      this.hasAnchor = false;\n      this.source = regExpSource;\n    }\n    if (this.hasAnchor) {\n      this._anchorCache = this._buildAnchorCache();\n    } else {\n      this._anchorCache = null;\n    }\n    this.ruleId = ruleId;\n    if (typeof this.source === \"string\") {\n      this.hasBackReferences = HAS_BACK_REFERENCES.test(this.source);\n    } else {\n      this.hasBackReferences = false;\n    }\n  }\n  clone() {\n    return new _RegExpSource(this.source, this.ruleId);\n  }\n  setSource(newSource) {\n    if (this.source === newSource) {\n      return;\n    }\n    this.source = newSource;\n    if (this.hasAnchor) {\n      this._anchorCache = this._buildAnchorCache();\n    }\n  }\n  resolveBackReferences(lineText, captureIndices) {\n    if (typeof this.source !== \"string\") {\n      throw new Error(\"This method should only be called if the source is a string\");\n    }\n    let capturedValues = captureIndices.map((capture) => {\n      return lineText.substring(capture.start, capture.end);\n    });\n    BACK_REFERENCING_END.lastIndex = 0;\n    return this.source.replace(BACK_REFERENCING_END, (match, g1) => {\n      return escapeRegExpCharacters(capturedValues[parseInt(g1, 10)] || \"\");\n    });\n  }\n  _buildAnchorCache() {\n    if (typeof this.source !== \"string\") {\n      throw new Error(\"This method should only be called if the source is a string\");\n    }\n    let A0_G0_result = [];\n    let A0_G1_result = [];\n    let A1_G0_result = [];\n    let A1_G1_result = [];\n    let pos, len, ch, nextCh;\n    for (pos = 0, len = this.source.length; pos < len; pos++) {\n      ch = this.source.charAt(pos);\n      A0_G0_result[pos] = ch;\n      A0_G1_result[pos] = ch;\n      A1_G0_result[pos] = ch;\n      A1_G1_result[pos] = ch;\n      if (ch === \"\\\\\") {\n        if (pos + 1 < len) {\n          nextCh = this.source.charAt(pos + 1);\n          if (nextCh === \"A\") {\n            A0_G0_result[pos + 1] = \"\\uFFFF\";\n            A0_G1_result[pos + 1] = \"\\uFFFF\";\n            A1_G0_result[pos + 1] = \"A\";\n            A1_G1_result[pos + 1] = \"A\";\n          } else if (nextCh === \"G\") {\n            A0_G0_result[pos + 1] = \"\\uFFFF\";\n            A0_G1_result[pos + 1] = \"G\";\n            A1_G0_result[pos + 1] = \"\\uFFFF\";\n            A1_G1_result[pos + 1] = \"G\";\n          } else {\n            A0_G0_result[pos + 1] = nextCh;\n            A0_G1_result[pos + 1] = nextCh;\n            A1_G0_result[pos + 1] = nextCh;\n            A1_G1_result[pos + 1] = nextCh;\n          }\n          pos++;\n        }\n      }\n    }\n    return {\n      A0_G0: A0_G0_result.join(\"\"),\n      A0_G1: A0_G1_result.join(\"\"),\n      A1_G0: A1_G0_result.join(\"\"),\n      A1_G1: A1_G1_result.join(\"\")\n    };\n  }\n  resolveAnchors(allowA, allowG) {\n    if (!this.hasAnchor || !this._anchorCache || typeof this.source !== \"string\") {\n      return this.source;\n    }\n    if (allowA) {\n      if (allowG) {\n        return this._anchorCache.A1_G1;\n      } else {\n        return this._anchorCache.A1_G0;\n      }\n    } else {\n      if (allowG) {\n        return this._anchorCache.A0_G1;\n      } else {\n        return this._anchorCache.A0_G0;\n      }\n    }\n  }\n};\nvar RegExpSourceList = class {\n  _items;\n  _hasAnchors;\n  _cached;\n  _anchorCache;\n  constructor() {\n    this._items = [];\n    this._hasAnchors = false;\n    this._cached = null;\n    this._anchorCache = {\n      A0_G0: null,\n      A0_G1: null,\n      A1_G0: null,\n      A1_G1: null\n    };\n  }\n  dispose() {\n    this._disposeCaches();\n  }\n  _disposeCaches() {\n    if (this._cached) {\n      this._cached.dispose();\n      this._cached = null;\n    }\n    if (this._anchorCache.A0_G0) {\n      this._anchorCache.A0_G0.dispose();\n      this._anchorCache.A0_G0 = null;\n    }\n    if (this._anchorCache.A0_G1) {\n      this._anchorCache.A0_G1.dispose();\n      this._anchorCache.A0_G1 = null;\n    }\n    if (this._anchorCache.A1_G0) {\n      this._anchorCache.A1_G0.dispose();\n      this._anchorCache.A1_G0 = null;\n    }\n    if (this._anchorCache.A1_G1) {\n      this._anchorCache.A1_G1.dispose();\n      this._anchorCache.A1_G1 = null;\n    }\n  }\n  push(item) {\n    this._items.push(item);\n    this._hasAnchors = this._hasAnchors || item.hasAnchor;\n  }\n  unshift(item) {\n    this._items.unshift(item);\n    this._hasAnchors = this._hasAnchors || item.hasAnchor;\n  }\n  length() {\n    return this._items.length;\n  }\n  setSource(index, newSource) {\n    if (this._items[index].source !== newSource) {\n      this._disposeCaches();\n      this._items[index].setSource(newSource);\n    }\n  }\n  compile(onigLib) {\n    if (!this._cached) {\n      let regExps = this._items.map((e) => e.source);\n      this._cached = new CompiledRule(onigLib, regExps, this._items.map((e) => e.ruleId));\n    }\n    return this._cached;\n  }\n  compileAG(onigLib, allowA, allowG) {\n    if (!this._hasAnchors) {\n      return this.compile(onigLib);\n    } else {\n      if (allowA) {\n        if (allowG) {\n          if (!this._anchorCache.A1_G1) {\n            this._anchorCache.A1_G1 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A1_G1;\n        } else {\n          if (!this._anchorCache.A1_G0) {\n            this._anchorCache.A1_G0 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A1_G0;\n        }\n      } else {\n        if (allowG) {\n          if (!this._anchorCache.A0_G1) {\n            this._anchorCache.A0_G1 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A0_G1;\n        } else {\n          if (!this._anchorCache.A0_G0) {\n            this._anchorCache.A0_G0 = this._resolveAnchors(onigLib, allowA, allowG);\n          }\n          return this._anchorCache.A0_G0;\n        }\n      }\n    }\n  }\n  _resolveAnchors(onigLib, allowA, allowG) {\n    let regExps = this._items.map((e) => e.resolveAnchors(allowA, allowG));\n    return new CompiledRule(onigLib, regExps, this._items.map((e) => e.ruleId));\n  }\n};\nvar CompiledRule = class {\n  constructor(onigLib, regExps, rules) {\n    this.regExps = regExps;\n    this.rules = rules;\n    this.scanner = onigLib.createOnigScanner(regExps);\n  }\n  scanner;\n  dispose() {\n    if (typeof this.scanner.dispose === \"function\") {\n      this.scanner.dispose();\n    }\n  }\n  toString() {\n    const r = [];\n    for (let i = 0, len = this.rules.length; i < len; i++) {\n      r.push(\"   - \" + this.rules[i] + \": \" + this.regExps[i]);\n    }\n    return r.join(\"\\n\");\n  }\n  findNextMatchSync(string, startPosition, options) {\n    const result = this.scanner.findNextMatchSync(string, startPosition, options);\n    if (!result) {\n      return null;\n    }\n    return {\n      ruleId: this.rules[result.index],\n      captureIndices: result.captureIndices\n    };\n  }\n};\n\n// src/grammar/basicScopesAttributeProvider.ts\nvar BasicScopeAttributes = class {\n  constructor(languageId, tokenType) {\n    this.languageId = languageId;\n    this.tokenType = tokenType;\n  }\n};\nvar BasicScopeAttributesProvider = class _BasicScopeAttributesProvider {\n  _defaultAttributes;\n  _embeddedLanguagesMatcher;\n  constructor(initialLanguageId, embeddedLanguages) {\n    this._defaultAttributes = new BasicScopeAttributes(initialLanguageId, 8 /* NotSet */);\n    this._embeddedLanguagesMatcher = new ScopeMatcher(Object.entries(embeddedLanguages || {}));\n  }\n  getDefaultAttributes() {\n    return this._defaultAttributes;\n  }\n  getBasicScopeAttributes(scopeName) {\n    if (scopeName === null) {\n      return _BasicScopeAttributesProvider._NULL_SCOPE_METADATA;\n    }\n    return this._getBasicScopeAttributes.get(scopeName);\n  }\n  static _NULL_SCOPE_METADATA = new BasicScopeAttributes(0, 0);\n  _getBasicScopeAttributes = new CachedFn((scopeName) => {\n    const languageId = this._scopeToLanguage(scopeName);\n    const standardTokenType = this._toStandardTokenType(scopeName);\n    return new BasicScopeAttributes(languageId, standardTokenType);\n  });\n  /**\n   * Given a produced TM scope, return the language that token describes or null if unknown.\n   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null\n   */\n  _scopeToLanguage(scope) {\n    return this._embeddedLanguagesMatcher.match(scope) || 0;\n  }\n  _toStandardTokenType(scopeName) {\n    const m = scopeName.match(_BasicScopeAttributesProvider.STANDARD_TOKEN_TYPE_REGEXP);\n    if (!m) {\n      return 8 /* NotSet */;\n    }\n    switch (m[1]) {\n      case \"comment\":\n        return 1 /* Comment */;\n      case \"string\":\n        return 2 /* String */;\n      case \"regex\":\n        return 3 /* RegEx */;\n      case \"meta.embedded\":\n        return 0 /* Other */;\n    }\n    throw new Error(\"Unexpected match for standard token type!\");\n  }\n  static STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|meta\\.embedded)\\b/;\n};\nvar ScopeMatcher = class {\n  values;\n  scopesRegExp;\n  constructor(values) {\n    if (values.length === 0) {\n      this.values = null;\n      this.scopesRegExp = null;\n    } else {\n      this.values = new Map(values);\n      const escapedScopes = values.map(\n        ([scopeName, value]) => escapeRegExpCharacters(scopeName)\n      );\n      escapedScopes.sort();\n      escapedScopes.reverse();\n      this.scopesRegExp = new RegExp(\n        `^((${escapedScopes.join(\")|(\")}))($|\\\\.)`,\n        \"\"\n      );\n    }\n  }\n  match(scope) {\n    if (!this.scopesRegExp) {\n      return void 0;\n    }\n    const m = scope.match(this.scopesRegExp);\n    if (!m) {\n      return void 0;\n    }\n    return this.values.get(m[1]);\n  }\n};\n\n// src/debug.ts\nvar DebugFlags = {\n  InDebugMode: typeof process !== \"undefined\" && !!process.env[\"VSCODE_TEXTMATE_DEBUG\"]\n};\nvar UseOnigurumaFindOptions = false;\n\n// src/grammar/tokenizeString.ts\nvar TokenizeStringResult = class {\n  constructor(stack, stoppedEarly) {\n    this.stack = stack;\n    this.stoppedEarly = stoppedEarly;\n  }\n};\nfunction _tokenizeString(grammar, lineText, isFirstLine, linePos, stack, lineTokens, checkWhileConditions, timeLimit) {\n  const lineLength = lineText.content.length;\n  let STOP = false;\n  let anchorPosition = -1;\n  if (checkWhileConditions) {\n    const whileCheckResult = _checkWhileConditions(\n      grammar,\n      lineText,\n      isFirstLine,\n      linePos,\n      stack,\n      lineTokens\n    );\n    stack = whileCheckResult.stack;\n    linePos = whileCheckResult.linePos;\n    isFirstLine = whileCheckResult.isFirstLine;\n    anchorPosition = whileCheckResult.anchorPosition;\n  }\n  const startTime = Date.now();\n  while (!STOP) {\n    if (timeLimit !== 0) {\n      const elapsedTime = Date.now() - startTime;\n      if (elapsedTime > timeLimit) {\n        return new TokenizeStringResult(stack, true);\n      }\n    }\n    scanNext();\n  }\n  return new TokenizeStringResult(stack, false);\n  function scanNext() {\n    if (false) {}\n    const r = matchRuleOrInjections(\n      grammar,\n      lineText,\n      isFirstLine,\n      linePos,\n      stack,\n      anchorPosition\n    );\n    if (!r) {\n      lineTokens.produce(stack, lineLength);\n      STOP = true;\n      return;\n    }\n    const captureIndices = r.captureIndices;\n    const matchedRuleId = r.matchedRuleId;\n    const hasAdvanced = captureIndices && captureIndices.length > 0 ? captureIndices[0].end > linePos : false;\n    if (matchedRuleId === endRuleId) {\n      const poppedRule = stack.getRule(grammar);\n      if (false) {}\n      lineTokens.produce(stack, captureIndices[0].start);\n      stack = stack.withContentNameScopesList(stack.nameScopesList);\n      handleCaptures(\n        grammar,\n        lineText,\n        isFirstLine,\n        stack,\n        lineTokens,\n        poppedRule.endCaptures,\n        captureIndices\n      );\n      lineTokens.produce(stack, captureIndices[0].end);\n      const popped = stack;\n      stack = stack.parent;\n      anchorPosition = popped.getAnchorPos();\n      if (!hasAdvanced && popped.getEnterPos() === linePos) {\n        if (false) {}\n        stack = popped;\n        lineTokens.produce(stack, lineLength);\n        STOP = true;\n        return;\n      }\n    } else {\n      const _rule = grammar.getRule(matchedRuleId);\n      lineTokens.produce(stack, captureIndices[0].start);\n      const beforePush = stack;\n      const scopeName = _rule.getName(lineText.content, captureIndices);\n      const nameScopesList = stack.contentNameScopesList.pushAttributed(\n        scopeName,\n        grammar\n      );\n      stack = stack.push(\n        matchedRuleId,\n        linePos,\n        anchorPosition,\n        captureIndices[0].end === lineLength,\n        null,\n        nameScopesList,\n        nameScopesList\n      );\n      if (_rule instanceof BeginEndRule) {\n        const pushedRule = _rule;\n        if (false) {}\n        handleCaptures(\n          grammar,\n          lineText,\n          isFirstLine,\n          stack,\n          lineTokens,\n          pushedRule.beginCaptures,\n          captureIndices\n        );\n        lineTokens.produce(stack, captureIndices[0].end);\n        anchorPosition = captureIndices[0].end;\n        const contentName = pushedRule.getContentName(\n          lineText.content,\n          captureIndices\n        );\n        const contentNameScopesList = nameScopesList.pushAttributed(\n          contentName,\n          grammar\n        );\n        stack = stack.withContentNameScopesList(contentNameScopesList);\n        if (pushedRule.endHasBackReferences) {\n          stack = stack.withEndRule(\n            pushedRule.getEndWithResolvedBackReferences(\n              lineText.content,\n              captureIndices\n            )\n          );\n        }\n        if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n          if (false) {}\n          stack = stack.pop();\n          lineTokens.produce(stack, lineLength);\n          STOP = true;\n          return;\n        }\n      } else if (_rule instanceof BeginWhileRule) {\n        const pushedRule = _rule;\n        if (false) {}\n        handleCaptures(\n          grammar,\n          lineText,\n          isFirstLine,\n          stack,\n          lineTokens,\n          pushedRule.beginCaptures,\n          captureIndices\n        );\n        lineTokens.produce(stack, captureIndices[0].end);\n        anchorPosition = captureIndices[0].end;\n        const contentName = pushedRule.getContentName(\n          lineText.content,\n          captureIndices\n        );\n        const contentNameScopesList = nameScopesList.pushAttributed(\n          contentName,\n          grammar\n        );\n        stack = stack.withContentNameScopesList(contentNameScopesList);\n        if (pushedRule.whileHasBackReferences) {\n          stack = stack.withEndRule(\n            pushedRule.getWhileWithResolvedBackReferences(\n              lineText.content,\n              captureIndices\n            )\n          );\n        }\n        if (!hasAdvanced && beforePush.hasSameRuleAs(stack)) {\n          if (false) {}\n          stack = stack.pop();\n          lineTokens.produce(stack, lineLength);\n          STOP = true;\n          return;\n        }\n      } else {\n        const matchingRule = _rule;\n        if (false) {}\n        handleCaptures(\n          grammar,\n          lineText,\n          isFirstLine,\n          stack,\n          lineTokens,\n          matchingRule.captures,\n          captureIndices\n        );\n        lineTokens.produce(stack, captureIndices[0].end);\n        stack = stack.pop();\n        if (!hasAdvanced) {\n          if (false) {}\n          stack = stack.safePop();\n          lineTokens.produce(stack, lineLength);\n          STOP = true;\n          return;\n        }\n      }\n    }\n    if (captureIndices[0].end > linePos) {\n      linePos = captureIndices[0].end;\n      isFirstLine = false;\n    }\n  }\n}\nfunction _checkWhileConditions(grammar, lineText, isFirstLine, linePos, stack, lineTokens) {\n  let anchorPosition = stack.beginRuleCapturedEOL ? 0 : -1;\n  const whileRules = [];\n  for (let node = stack; node; node = node.pop()) {\n    const nodeRule = node.getRule(grammar);\n    if (nodeRule instanceof BeginWhileRule) {\n      whileRules.push({\n        rule: nodeRule,\n        stack: node\n      });\n    }\n  }\n  for (let whileRule = whileRules.pop(); whileRule; whileRule = whileRules.pop()) {\n    const { ruleScanner, findOptions } = prepareRuleWhileSearch(whileRule.rule, grammar, whileRule.stack.endRule, isFirstLine, linePos === anchorPosition);\n    const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n    if (false) {}\n    if (r) {\n      const matchedRuleId = r.ruleId;\n      if (matchedRuleId !== whileRuleId) {\n        stack = whileRule.stack.pop();\n        break;\n      }\n      if (r.captureIndices && r.captureIndices.length) {\n        lineTokens.produce(whileRule.stack, r.captureIndices[0].start);\n        handleCaptures(grammar, lineText, isFirstLine, whileRule.stack, lineTokens, whileRule.rule.whileCaptures, r.captureIndices);\n        lineTokens.produce(whileRule.stack, r.captureIndices[0].end);\n        anchorPosition = r.captureIndices[0].end;\n        if (r.captureIndices[0].end > linePos) {\n          linePos = r.captureIndices[0].end;\n          isFirstLine = false;\n        }\n      }\n    } else {\n      if (false) {}\n      stack = whileRule.stack.pop();\n      break;\n    }\n  }\n  return { stack, linePos, anchorPosition, isFirstLine };\n}\nfunction matchRuleOrInjections(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n  const matchResult = matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n  const injections = grammar.getInjections();\n  if (injections.length === 0) {\n    return matchResult;\n  }\n  const injectionResult = matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition);\n  if (!injectionResult) {\n    return matchResult;\n  }\n  if (!matchResult) {\n    return injectionResult;\n  }\n  const matchResultScore = matchResult.captureIndices[0].start;\n  const injectionResultScore = injectionResult.captureIndices[0].start;\n  if (injectionResultScore < matchResultScore || injectionResult.priorityMatch && injectionResultScore === matchResultScore) {\n    return injectionResult;\n  }\n  return matchResult;\n}\nfunction matchRule(grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n  const rule = stack.getRule(grammar);\n  const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, stack.endRule, isFirstLine, linePos === anchorPosition);\n  const r = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n  if (r) {\n    return {\n      captureIndices: r.captureIndices,\n      matchedRuleId: r.ruleId\n    };\n  }\n  return null;\n}\nfunction matchInjections(injections, grammar, lineText, isFirstLine, linePos, stack, anchorPosition) {\n  let bestMatchRating = Number.MAX_VALUE;\n  let bestMatchCaptureIndices = null;\n  let bestMatchRuleId;\n  let bestMatchResultPriority = 0;\n  const scopes = stack.contentNameScopesList.getScopeNames();\n  for (let i = 0, len = injections.length; i < len; i++) {\n    const injection = injections[i];\n    if (!injection.matcher(scopes)) {\n      continue;\n    }\n    const rule = grammar.getRule(injection.ruleId);\n    const { ruleScanner, findOptions } = prepareRuleSearch(rule, grammar, null, isFirstLine, linePos === anchorPosition);\n    const matchResult = ruleScanner.findNextMatchSync(lineText, linePos, findOptions);\n    if (!matchResult) {\n      continue;\n    }\n    if (false) {}\n    const matchRating = matchResult.captureIndices[0].start;\n    if (matchRating >= bestMatchRating) {\n      continue;\n    }\n    bestMatchRating = matchRating;\n    bestMatchCaptureIndices = matchResult.captureIndices;\n    bestMatchRuleId = matchResult.ruleId;\n    bestMatchResultPriority = injection.priority;\n    if (bestMatchRating === linePos) {\n      break;\n    }\n  }\n  if (bestMatchCaptureIndices) {\n    return {\n      priorityMatch: bestMatchResultPriority === -1,\n      captureIndices: bestMatchCaptureIndices,\n      matchedRuleId: bestMatchRuleId\n    };\n  }\n  return null;\n}\nfunction prepareRuleSearch(rule, grammar, endRegexSource, allowA, allowG) {\n  if (UseOnigurumaFindOptions) {\n    const ruleScanner2 = rule.compile(grammar, endRegexSource);\n    const findOptions = getFindOptions(allowA, allowG);\n    return { ruleScanner: ruleScanner2, findOptions };\n  }\n  const ruleScanner = rule.compileAG(grammar, endRegexSource, allowA, allowG);\n  return { ruleScanner, findOptions: 0 /* None */ };\n}\nfunction prepareRuleWhileSearch(rule, grammar, endRegexSource, allowA, allowG) {\n  if (UseOnigurumaFindOptions) {\n    const ruleScanner2 = rule.compileWhile(grammar, endRegexSource);\n    const findOptions = getFindOptions(allowA, allowG);\n    return { ruleScanner: ruleScanner2, findOptions };\n  }\n  const ruleScanner = rule.compileWhileAG(grammar, endRegexSource, allowA, allowG);\n  return { ruleScanner, findOptions: 0 /* None */ };\n}\nfunction getFindOptions(allowA, allowG) {\n  let options = 0 /* None */;\n  if (!allowA) {\n    options |= 1 /* NotBeginString */;\n  }\n  if (!allowG) {\n    options |= 4 /* NotBeginPosition */;\n  }\n  return options;\n}\nfunction handleCaptures(grammar, lineText, isFirstLine, stack, lineTokens, captures, captureIndices) {\n  if (captures.length === 0) {\n    return;\n  }\n  const lineTextContent = lineText.content;\n  const len = Math.min(captures.length, captureIndices.length);\n  const localStack = [];\n  const maxEnd = captureIndices[0].end;\n  for (let i = 0; i < len; i++) {\n    const captureRule = captures[i];\n    if (captureRule === null) {\n      continue;\n    }\n    const captureIndex = captureIndices[i];\n    if (captureIndex.length === 0) {\n      continue;\n    }\n    if (captureIndex.start > maxEnd) {\n      break;\n    }\n    while (localStack.length > 0 && localStack[localStack.length - 1].endPos <= captureIndex.start) {\n      lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n      localStack.pop();\n    }\n    if (localStack.length > 0) {\n      lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, captureIndex.start);\n    } else {\n      lineTokens.produce(stack, captureIndex.start);\n    }\n    if (captureRule.retokenizeCapturedWithRuleId) {\n      const scopeName = captureRule.getName(lineTextContent, captureIndices);\n      const nameScopesList = stack.contentNameScopesList.pushAttributed(scopeName, grammar);\n      const contentName = captureRule.getContentName(lineTextContent, captureIndices);\n      const contentNameScopesList = nameScopesList.pushAttributed(contentName, grammar);\n      const stackClone = stack.push(captureRule.retokenizeCapturedWithRuleId, captureIndex.start, -1, false, null, nameScopesList, contentNameScopesList);\n      const onigSubStr = grammar.createOnigString(lineTextContent.substring(0, captureIndex.end));\n      _tokenizeString(\n        grammar,\n        onigSubStr,\n        isFirstLine && captureIndex.start === 0,\n        captureIndex.start,\n        stackClone,\n        lineTokens,\n        false,\n        /* no time limit */\n        0\n      );\n      disposeOnigString(onigSubStr);\n      continue;\n    }\n    const captureRuleScopeName = captureRule.getName(lineTextContent, captureIndices);\n    if (captureRuleScopeName !== null) {\n      const base = localStack.length > 0 ? localStack[localStack.length - 1].scopes : stack.contentNameScopesList;\n      const captureRuleScopesList = base.pushAttributed(captureRuleScopeName, grammar);\n      localStack.push(new LocalStackElement(captureRuleScopesList, captureIndex.end));\n    }\n  }\n  while (localStack.length > 0) {\n    lineTokens.produceFromScopes(localStack[localStack.length - 1].scopes, localStack[localStack.length - 1].endPos);\n    localStack.pop();\n  }\n}\nvar LocalStackElement = class {\n  scopes;\n  endPos;\n  constructor(scopes, endPos) {\n    this.scopes = scopes;\n    this.endPos = endPos;\n  }\n};\n\n// src/grammar/grammar.ts\nfunction createGrammar(scopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, onigLib) {\n  return new Grammar(\n    scopeName,\n    grammar,\n    initialLanguage,\n    embeddedLanguages,\n    tokenTypes,\n    balancedBracketSelectors,\n    grammarRepository,\n    onigLib\n  );\n}\nfunction collectInjections(result, selector, rule, ruleFactoryHelper, grammar) {\n  const matchers = createMatchers(selector, nameMatcher);\n  const ruleId = RuleFactory.getCompiledRuleId(rule, ruleFactoryHelper, grammar.repository);\n  for (const matcher of matchers) {\n    result.push({\n      debugSelector: selector,\n      matcher: matcher.matcher,\n      ruleId,\n      grammar,\n      priority: matcher.priority\n    });\n  }\n}\nfunction nameMatcher(identifers, scopes) {\n  if (scopes.length < identifers.length) {\n    return false;\n  }\n  let lastIndex = 0;\n  return identifers.every((identifier) => {\n    for (let i = lastIndex; i < scopes.length; i++) {\n      if (scopesAreMatching(scopes[i], identifier)) {\n        lastIndex = i + 1;\n        return true;\n      }\n    }\n    return false;\n  });\n}\nfunction scopesAreMatching(thisScopeName, scopeName) {\n  if (!thisScopeName) {\n    return false;\n  }\n  if (thisScopeName === scopeName) {\n    return true;\n  }\n  const len = scopeName.length;\n  return thisScopeName.length > len && thisScopeName.substr(0, len) === scopeName && thisScopeName[len] === \".\";\n}\nvar Grammar = class {\n  constructor(_rootScopeName, grammar, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors, grammarRepository, _onigLib) {\n    this._rootScopeName = _rootScopeName;\n    this.balancedBracketSelectors = balancedBracketSelectors;\n    this._onigLib = _onigLib;\n    this._basicScopeAttributesProvider = new BasicScopeAttributesProvider(\n      initialLanguage,\n      embeddedLanguages\n    );\n    this._rootId = -1;\n    this._lastRuleId = 0;\n    this._ruleId2desc = [null];\n    this._includedGrammars = {};\n    this._grammarRepository = grammarRepository;\n    this._grammar = initGrammar(grammar, null);\n    this._injections = null;\n    this._tokenTypeMatchers = [];\n    if (tokenTypes) {\n      for (const selector of Object.keys(tokenTypes)) {\n        const matchers = createMatchers(selector, nameMatcher);\n        for (const matcher of matchers) {\n          this._tokenTypeMatchers.push({\n            matcher: matcher.matcher,\n            type: tokenTypes[selector]\n          });\n        }\n      }\n    }\n  }\n  _rootId;\n  _lastRuleId;\n  _ruleId2desc;\n  _includedGrammars;\n  _grammarRepository;\n  _grammar;\n  _injections;\n  _basicScopeAttributesProvider;\n  _tokenTypeMatchers;\n  get themeProvider() {\n    return this._grammarRepository;\n  }\n  dispose() {\n    for (const rule of this._ruleId2desc) {\n      if (rule) {\n        rule.dispose();\n      }\n    }\n  }\n  createOnigScanner(sources) {\n    return this._onigLib.createOnigScanner(sources);\n  }\n  createOnigString(sources) {\n    return this._onigLib.createOnigString(sources);\n  }\n  getMetadataForScope(scope) {\n    return this._basicScopeAttributesProvider.getBasicScopeAttributes(scope);\n  }\n  _collectInjections() {\n    const grammarRepository = {\n      lookup: (scopeName2) => {\n        if (scopeName2 === this._rootScopeName) {\n          return this._grammar;\n        }\n        return this.getExternalGrammar(scopeName2);\n      },\n      injections: (scopeName2) => {\n        return this._grammarRepository.injections(scopeName2);\n      }\n    };\n    const result = [];\n    const scopeName = this._rootScopeName;\n    const grammar = grammarRepository.lookup(scopeName);\n    if (grammar) {\n      const rawInjections = grammar.injections;\n      if (rawInjections) {\n        for (let expression in rawInjections) {\n          collectInjections(\n            result,\n            expression,\n            rawInjections[expression],\n            this,\n            grammar\n          );\n        }\n      }\n      const injectionScopeNames = this._grammarRepository.injections(scopeName);\n      if (injectionScopeNames) {\n        injectionScopeNames.forEach((injectionScopeName) => {\n          const injectionGrammar = this.getExternalGrammar(injectionScopeName);\n          if (injectionGrammar) {\n            const selector = injectionGrammar.injectionSelector;\n            if (selector) {\n              collectInjections(\n                result,\n                selector,\n                injectionGrammar,\n                this,\n                injectionGrammar\n              );\n            }\n          }\n        });\n      }\n    }\n    result.sort((i1, i2) => i1.priority - i2.priority);\n    return result;\n  }\n  getInjections() {\n    if (this._injections === null) {\n      this._injections = this._collectInjections();\n    }\n    return this._injections;\n  }\n  registerRule(factory) {\n    const id = ++this._lastRuleId;\n    const result = factory(ruleIdFromNumber(id));\n    this._ruleId2desc[id] = result;\n    return result;\n  }\n  getRule(ruleId) {\n    return this._ruleId2desc[ruleIdToNumber(ruleId)];\n  }\n  getExternalGrammar(scopeName, repository) {\n    if (this._includedGrammars[scopeName]) {\n      return this._includedGrammars[scopeName];\n    } else if (this._grammarRepository) {\n      const rawIncludedGrammar = this._grammarRepository.lookup(scopeName);\n      if (rawIncludedGrammar) {\n        this._includedGrammars[scopeName] = initGrammar(\n          rawIncludedGrammar,\n          repository && repository.$base\n        );\n        return this._includedGrammars[scopeName];\n      }\n    }\n    return void 0;\n  }\n  tokenizeLine(lineText, prevState, timeLimit = 0) {\n    const r = this._tokenize(lineText, prevState, false, timeLimit);\n    return {\n      tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),\n      ruleStack: r.ruleStack,\n      stoppedEarly: r.stoppedEarly\n    };\n  }\n  tokenizeLine2(lineText, prevState, timeLimit = 0) {\n    const r = this._tokenize(lineText, prevState, true, timeLimit);\n    return {\n      tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),\n      ruleStack: r.ruleStack,\n      stoppedEarly: r.stoppedEarly\n    };\n  }\n  _tokenize(lineText, prevState, emitBinaryTokens, timeLimit) {\n    if (this._rootId === -1) {\n      this._rootId = RuleFactory.getCompiledRuleId(\n        this._grammar.repository.$self,\n        this,\n        this._grammar.repository\n      );\n      this.getInjections();\n    }\n    let isFirstLine;\n    if (!prevState || prevState === StateStackImpl.NULL) {\n      isFirstLine = true;\n      const rawDefaultMetadata = this._basicScopeAttributesProvider.getDefaultAttributes();\n      const defaultStyle = this.themeProvider.getDefaults();\n      const defaultMetadata = EncodedTokenMetadata.set(\n        0,\n        rawDefaultMetadata.languageId,\n        rawDefaultMetadata.tokenType,\n        null,\n        defaultStyle.fontStyle,\n        defaultStyle.foregroundId,\n        defaultStyle.backgroundId\n      );\n      const rootScopeName = this.getRule(this._rootId).getName(\n        null,\n        null\n      );\n      let scopeList;\n      if (rootScopeName) {\n        scopeList = AttributedScopeStack.createRootAndLookUpScopeName(\n          rootScopeName,\n          defaultMetadata,\n          this\n        );\n      } else {\n        scopeList = AttributedScopeStack.createRoot(\n          \"unknown\",\n          defaultMetadata\n        );\n      }\n      prevState = new StateStackImpl(\n        null,\n        this._rootId,\n        -1,\n        -1,\n        false,\n        null,\n        scopeList,\n        scopeList\n      );\n    } else {\n      isFirstLine = false;\n      prevState.reset();\n    }\n    lineText = lineText + \"\\n\";\n    const onigLineText = this.createOnigString(lineText);\n    const lineLength = onigLineText.content.length;\n    const lineTokens = new LineTokens(\n      emitBinaryTokens,\n      lineText,\n      this._tokenTypeMatchers,\n      this.balancedBracketSelectors\n    );\n    const r = _tokenizeString(\n      this,\n      onigLineText,\n      isFirstLine,\n      0,\n      prevState,\n      lineTokens,\n      true,\n      timeLimit\n    );\n    disposeOnigString(onigLineText);\n    return {\n      lineLength,\n      lineTokens,\n      ruleStack: r.stack,\n      stoppedEarly: r.stoppedEarly\n    };\n  }\n};\nfunction initGrammar(grammar, base) {\n  grammar = clone(grammar);\n  grammar.repository = grammar.repository || {};\n  grammar.repository.$self = {\n    $vscodeTextmateLocation: grammar.$vscodeTextmateLocation,\n    patterns: grammar.patterns,\n    name: grammar.scopeName\n  };\n  grammar.repository.$base = base || grammar.repository.$self;\n  return grammar;\n}\nvar AttributedScopeStack = class _AttributedScopeStack {\n  /**\n   * Invariant:\n   * ```\n   * if (parent && !scopePath.extends(parent.scopePath)) {\n   * \tthrow new Error();\n   * }\n   * ```\n   */\n  constructor(parent, scopePath, tokenAttributes) {\n    this.parent = parent;\n    this.scopePath = scopePath;\n    this.tokenAttributes = tokenAttributes;\n  }\n  static fromExtension(namesScopeList, contentNameScopesList) {\n    let current = namesScopeList;\n    let scopeNames = namesScopeList?.scopePath ?? null;\n    for (const frame of contentNameScopesList) {\n      scopeNames = ScopeStack.push(scopeNames, frame.scopeNames);\n      current = new _AttributedScopeStack(current, scopeNames, frame.encodedTokenAttributes);\n    }\n    return current;\n  }\n  static createRoot(scopeName, tokenAttributes) {\n    return new _AttributedScopeStack(null, new ScopeStack(null, scopeName), tokenAttributes);\n  }\n  static createRootAndLookUpScopeName(scopeName, tokenAttributes, grammar) {\n    const rawRootMetadata = grammar.getMetadataForScope(scopeName);\n    const scopePath = new ScopeStack(null, scopeName);\n    const rootStyle = grammar.themeProvider.themeMatch(scopePath);\n    const resolvedTokenAttributes = _AttributedScopeStack.mergeAttributes(\n      tokenAttributes,\n      rawRootMetadata,\n      rootStyle\n    );\n    return new _AttributedScopeStack(null, scopePath, resolvedTokenAttributes);\n  }\n  get scopeName() {\n    return this.scopePath.scopeName;\n  }\n  toString() {\n    return this.getScopeNames().join(\" \");\n  }\n  equals(other) {\n    return _AttributedScopeStack.equals(this, other);\n  }\n  static equals(a, b) {\n    do {\n      if (a === b) {\n        return true;\n      }\n      if (!a && !b) {\n        return true;\n      }\n      if (!a || !b) {\n        return false;\n      }\n      if (a.scopeName !== b.scopeName || a.tokenAttributes !== b.tokenAttributes) {\n        return false;\n      }\n      a = a.parent;\n      b = b.parent;\n    } while (true);\n  }\n  static mergeAttributes(existingTokenAttributes, basicScopeAttributes, styleAttributes) {\n    let fontStyle = -1 /* NotSet */;\n    let foreground = 0;\n    let background = 0;\n    if (styleAttributes !== null) {\n      fontStyle = styleAttributes.fontStyle;\n      foreground = styleAttributes.foregroundId;\n      background = styleAttributes.backgroundId;\n    }\n    return EncodedTokenMetadata.set(\n      existingTokenAttributes,\n      basicScopeAttributes.languageId,\n      basicScopeAttributes.tokenType,\n      null,\n      fontStyle,\n      foreground,\n      background\n    );\n  }\n  pushAttributed(scopePath, grammar) {\n    if (scopePath === null) {\n      return this;\n    }\n    if (scopePath.indexOf(\" \") === -1) {\n      return _AttributedScopeStack._pushAttributed(this, scopePath, grammar);\n    }\n    const scopes = scopePath.split(/ /g);\n    let result = this;\n    for (const scope of scopes) {\n      result = _AttributedScopeStack._pushAttributed(result, scope, grammar);\n    }\n    return result;\n  }\n  static _pushAttributed(target, scopeName, grammar) {\n    const rawMetadata = grammar.getMetadataForScope(scopeName);\n    const newPath = target.scopePath.push(scopeName);\n    const scopeThemeMatchResult = grammar.themeProvider.themeMatch(newPath);\n    const metadata = _AttributedScopeStack.mergeAttributes(\n      target.tokenAttributes,\n      rawMetadata,\n      scopeThemeMatchResult\n    );\n    return new _AttributedScopeStack(target, newPath, metadata);\n  }\n  getScopeNames() {\n    return this.scopePath.getSegments();\n  }\n  getExtensionIfDefined(base) {\n    const result = [];\n    let self = this;\n    while (self && self !== base) {\n      result.push({\n        encodedTokenAttributes: self.tokenAttributes,\n        scopeNames: self.scopePath.getExtensionIfDefined(self.parent?.scopePath ?? null)\n      });\n      self = self.parent;\n    }\n    return self === base ? result.reverse() : void 0;\n  }\n};\nvar StateStackImpl = class _StateStackImpl {\n  /**\n   * Invariant:\n   * ```\n   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {\n   * \tthrow new Error();\n   * }\n   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {\n   * \tthrow new Error();\n   * }\n   * ```\n   */\n  constructor(parent, ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {\n    this.parent = parent;\n    this.ruleId = ruleId;\n    this.beginRuleCapturedEOL = beginRuleCapturedEOL;\n    this.endRule = endRule;\n    this.nameScopesList = nameScopesList;\n    this.contentNameScopesList = contentNameScopesList;\n    this.depth = this.parent ? this.parent.depth + 1 : 1;\n    this._enterPos = enterPos;\n    this._anchorPos = anchorPos;\n  }\n  _stackElementBrand = void 0;\n  // TODO remove me\n  static NULL = new _StateStackImpl(\n    null,\n    0,\n    0,\n    0,\n    false,\n    null,\n    null,\n    null\n  );\n  /**\n   * The position on the current line where this state was pushed.\n   * This is relevant only while tokenizing a line, to detect endless loops.\n   * Its value is meaningless across lines.\n   */\n  _enterPos;\n  /**\n   * The captured anchor position when this stack element was pushed.\n   * This is relevant only while tokenizing a line, to restore the anchor position when popping.\n   * Its value is meaningless across lines.\n   */\n  _anchorPos;\n  /**\n   * The depth of the stack.\n   */\n  depth;\n  equals(other) {\n    if (other === null) {\n      return false;\n    }\n    return _StateStackImpl._equals(this, other);\n  }\n  static _equals(a, b) {\n    if (a === b) {\n      return true;\n    }\n    if (!this._structuralEquals(a, b)) {\n      return false;\n    }\n    return AttributedScopeStack.equals(a.contentNameScopesList, b.contentNameScopesList);\n  }\n  /**\n   * A structural equals check. Does not take into account `scopes`.\n   */\n  static _structuralEquals(a, b) {\n    do {\n      if (a === b) {\n        return true;\n      }\n      if (!a && !b) {\n        return true;\n      }\n      if (!a || !b) {\n        return false;\n      }\n      if (a.depth !== b.depth || a.ruleId !== b.ruleId || a.endRule !== b.endRule) {\n        return false;\n      }\n      a = a.parent;\n      b = b.parent;\n    } while (true);\n  }\n  clone() {\n    return this;\n  }\n  static _reset(el) {\n    while (el) {\n      el._enterPos = -1;\n      el._anchorPos = -1;\n      el = el.parent;\n    }\n  }\n  reset() {\n    _StateStackImpl._reset(this);\n  }\n  pop() {\n    return this.parent;\n  }\n  safePop() {\n    if (this.parent) {\n      return this.parent;\n    }\n    return this;\n  }\n  push(ruleId, enterPos, anchorPos, beginRuleCapturedEOL, endRule, nameScopesList, contentNameScopesList) {\n    return new _StateStackImpl(\n      this,\n      ruleId,\n      enterPos,\n      anchorPos,\n      beginRuleCapturedEOL,\n      endRule,\n      nameScopesList,\n      contentNameScopesList\n    );\n  }\n  getEnterPos() {\n    return this._enterPos;\n  }\n  getAnchorPos() {\n    return this._anchorPos;\n  }\n  getRule(grammar) {\n    return grammar.getRule(this.ruleId);\n  }\n  toString() {\n    const r = [];\n    this._writeString(r, 0);\n    return \"[\" + r.join(\",\") + \"]\";\n  }\n  _writeString(res, outIndex) {\n    if (this.parent) {\n      outIndex = this.parent._writeString(res, outIndex);\n    }\n    res[outIndex++] = `(${this.ruleId}, ${this.nameScopesList?.toString()}, ${this.contentNameScopesList?.toString()})`;\n    return outIndex;\n  }\n  withContentNameScopesList(contentNameScopeStack) {\n    if (this.contentNameScopesList === contentNameScopeStack) {\n      return this;\n    }\n    return this.parent.push(\n      this.ruleId,\n      this._enterPos,\n      this._anchorPos,\n      this.beginRuleCapturedEOL,\n      this.endRule,\n      this.nameScopesList,\n      contentNameScopeStack\n    );\n  }\n  withEndRule(endRule) {\n    if (this.endRule === endRule) {\n      return this;\n    }\n    return new _StateStackImpl(\n      this.parent,\n      this.ruleId,\n      this._enterPos,\n      this._anchorPos,\n      this.beginRuleCapturedEOL,\n      endRule,\n      this.nameScopesList,\n      this.contentNameScopesList\n    );\n  }\n  // Used to warn of endless loops\n  hasSameRuleAs(other) {\n    let el = this;\n    while (el && el._enterPos === other._enterPos) {\n      if (el.ruleId === other.ruleId) {\n        return true;\n      }\n      el = el.parent;\n    }\n    return false;\n  }\n  toStateStackFrame() {\n    return {\n      ruleId: ruleIdToNumber(this.ruleId),\n      beginRuleCapturedEOL: this.beginRuleCapturedEOL,\n      endRule: this.endRule,\n      nameScopesList: this.nameScopesList?.getExtensionIfDefined(this.parent?.nameScopesList ?? null) ?? [],\n      contentNameScopesList: this.contentNameScopesList?.getExtensionIfDefined(this.nameScopesList) ?? []\n    };\n  }\n  static pushFrame(self, frame) {\n    const namesScopeList = AttributedScopeStack.fromExtension(self?.nameScopesList ?? null, frame.nameScopesList);\n    return new _StateStackImpl(\n      self,\n      ruleIdFromNumber(frame.ruleId),\n      frame.enterPos ?? -1,\n      frame.anchorPos ?? -1,\n      frame.beginRuleCapturedEOL,\n      frame.endRule,\n      namesScopeList,\n      AttributedScopeStack.fromExtension(namesScopeList, frame.contentNameScopesList)\n    );\n  }\n};\nvar BalancedBracketSelectors = class {\n  balancedBracketScopes;\n  unbalancedBracketScopes;\n  allowAny = false;\n  constructor(balancedBracketScopes, unbalancedBracketScopes) {\n    this.balancedBracketScopes = balancedBracketScopes.flatMap(\n      (selector) => {\n        if (selector === \"*\") {\n          this.allowAny = true;\n          return [];\n        }\n        return createMatchers(selector, nameMatcher).map((m) => m.matcher);\n      }\n    );\n    this.unbalancedBracketScopes = unbalancedBracketScopes.flatMap(\n      (selector) => createMatchers(selector, nameMatcher).map((m) => m.matcher)\n    );\n  }\n  get matchesAlways() {\n    return this.allowAny && this.unbalancedBracketScopes.length === 0;\n  }\n  get matchesNever() {\n    return this.balancedBracketScopes.length === 0 && !this.allowAny;\n  }\n  match(scopes) {\n    for (const excluder of this.unbalancedBracketScopes) {\n      if (excluder(scopes)) {\n        return false;\n      }\n    }\n    for (const includer of this.balancedBracketScopes) {\n      if (includer(scopes)) {\n        return true;\n      }\n    }\n    return this.allowAny;\n  }\n};\nvar LineTokens = class {\n  constructor(emitBinaryTokens, lineText, tokenTypeOverrides, balancedBracketSelectors) {\n    this.balancedBracketSelectors = balancedBracketSelectors;\n    this._emitBinaryTokens = emitBinaryTokens;\n    this._tokenTypeOverrides = tokenTypeOverrides;\n    if (false) {} else {\n      this._lineText = null;\n    }\n    this._tokens = [];\n    this._binaryTokens = [];\n    this._lastTokenEndIndex = 0;\n  }\n  _emitBinaryTokens;\n  /**\n   * defined only if `false`.\n   */\n  _lineText;\n  /**\n   * used only if `_emitBinaryTokens` is false.\n   */\n  _tokens;\n  /**\n   * used only if `_emitBinaryTokens` is true.\n   */\n  _binaryTokens;\n  _lastTokenEndIndex;\n  _tokenTypeOverrides;\n  produce(stack, endIndex) {\n    this.produceFromScopes(stack.contentNameScopesList, endIndex);\n  }\n  produceFromScopes(scopesList, endIndex) {\n    if (this._lastTokenEndIndex >= endIndex) {\n      return;\n    }\n    if (this._emitBinaryTokens) {\n      let metadata = scopesList?.tokenAttributes ?? 0;\n      let containsBalancedBrackets = false;\n      if (this.balancedBracketSelectors?.matchesAlways) {\n        containsBalancedBrackets = true;\n      }\n      if (this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {\n        const scopes2 = scopesList?.getScopeNames() ?? [];\n        for (const tokenType of this._tokenTypeOverrides) {\n          if (tokenType.matcher(scopes2)) {\n            metadata = EncodedTokenMetadata.set(\n              metadata,\n              0,\n              toOptionalTokenType(tokenType.type),\n              null,\n              -1 /* NotSet */,\n              0,\n              0\n            );\n          }\n        }\n        if (this.balancedBracketSelectors) {\n          containsBalancedBrackets = this.balancedBracketSelectors.match(scopes2);\n        }\n      }\n      if (containsBalancedBrackets) {\n        metadata = EncodedTokenMetadata.set(\n          metadata,\n          0,\n          8 /* NotSet */,\n          containsBalancedBrackets,\n          -1 /* NotSet */,\n          0,\n          0\n        );\n      }\n      if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === metadata) {\n        this._lastTokenEndIndex = endIndex;\n        return;\n      }\n      this._binaryTokens.push(this._lastTokenEndIndex);\n      this._binaryTokens.push(metadata);\n      this._lastTokenEndIndex = endIndex;\n      return;\n    }\n    const scopes = scopesList?.getScopeNames() ?? [];\n    this._tokens.push({\n      startIndex: this._lastTokenEndIndex,\n      endIndex,\n      // value: lineText.substring(lastTokenEndIndex, endIndex),\n      scopes\n    });\n    this._lastTokenEndIndex = endIndex;\n  }\n  getResult(stack, lineLength) {\n    if (this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === lineLength - 1) {\n      this._tokens.pop();\n    }\n    if (this._tokens.length === 0) {\n      this._lastTokenEndIndex = -1;\n      this.produce(stack, lineLength);\n      this._tokens[this._tokens.length - 1].startIndex = 0;\n    }\n    return this._tokens;\n  }\n  getBinaryResult(stack, lineLength) {\n    if (this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === lineLength - 1) {\n      this._binaryTokens.pop();\n      this._binaryTokens.pop();\n    }\n    if (this._binaryTokens.length === 0) {\n      this._lastTokenEndIndex = -1;\n      this.produce(stack, lineLength);\n      this._binaryTokens[this._binaryTokens.length - 2] = 0;\n    }\n    const result = new Uint32Array(this._binaryTokens.length);\n    for (let i = 0, len = this._binaryTokens.length; i < len; i++) {\n      result[i] = this._binaryTokens[i];\n    }\n    return result;\n  }\n};\n\n// src/registry.ts\nvar SyncRegistry = class {\n  constructor(theme, _onigLib) {\n    this._onigLib = _onigLib;\n    this._theme = theme;\n  }\n  _grammars = /* @__PURE__ */ new Map();\n  _rawGrammars = /* @__PURE__ */ new Map();\n  _injectionGrammars = /* @__PURE__ */ new Map();\n  _theme;\n  dispose() {\n    for (const grammar of this._grammars.values()) {\n      grammar.dispose();\n    }\n  }\n  setTheme(theme) {\n    this._theme = theme;\n  }\n  getColorMap() {\n    return this._theme.getColorMap();\n  }\n  /**\n   * Add `grammar` to registry and return a list of referenced scope names\n   */\n  addGrammar(grammar, injectionScopeNames) {\n    this._rawGrammars.set(grammar.scopeName, grammar);\n    if (injectionScopeNames) {\n      this._injectionGrammars.set(grammar.scopeName, injectionScopeNames);\n    }\n  }\n  /**\n   * Lookup a raw grammar.\n   */\n  lookup(scopeName) {\n    return this._rawGrammars.get(scopeName);\n  }\n  /**\n   * Returns the injections for the given grammar\n   */\n  injections(targetScope) {\n    return this._injectionGrammars.get(targetScope);\n  }\n  /**\n   * Get the default theme settings\n   */\n  getDefaults() {\n    return this._theme.getDefaults();\n  }\n  /**\n   * Match a scope in the theme.\n   */\n  themeMatch(scopePath) {\n    return this._theme.match(scopePath);\n  }\n  /**\n   * Lookup a grammar.\n   */\n  grammarForScopeName(scopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {\n    if (!this._grammars.has(scopeName)) {\n      let rawGrammar = this._rawGrammars.get(scopeName);\n      if (!rawGrammar) {\n        return null;\n      }\n      this._grammars.set(scopeName, createGrammar(\n        scopeName,\n        rawGrammar,\n        initialLanguage,\n        embeddedLanguages,\n        tokenTypes,\n        balancedBracketSelectors,\n        this,\n        this._onigLib\n      ));\n    }\n    return this._grammars.get(scopeName);\n  }\n};\n\n// src/index.ts\nvar Registry = class {\n  _options;\n  _syncRegistry;\n  _ensureGrammarCache;\n  constructor(options) {\n    this._options = options;\n    this._syncRegistry = new SyncRegistry(\n      Theme.createFromRawTheme(options.theme, options.colorMap),\n      options.onigLib\n    );\n    this._ensureGrammarCache = /* @__PURE__ */ new Map();\n  }\n  dispose() {\n    this._syncRegistry.dispose();\n  }\n  /**\n   * Change the theme. Once called, no previous `ruleStack` should be used anymore.\n   */\n  setTheme(theme, colorMap) {\n    this._syncRegistry.setTheme(Theme.createFromRawTheme(theme, colorMap));\n  }\n  /**\n   * Returns a lookup array for color ids.\n   */\n  getColorMap() {\n    return this._syncRegistry.getColorMap();\n  }\n  /**\n   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n   * Please do not use language id 0.\n   */\n  loadGrammarWithEmbeddedLanguages(initialScopeName, initialLanguage, embeddedLanguages) {\n    return this.loadGrammarWithConfiguration(initialScopeName, initialLanguage, { embeddedLanguages });\n  }\n  /**\n   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n   * Please do not use language id 0.\n   */\n  loadGrammarWithConfiguration(initialScopeName, initialLanguage, configuration) {\n    return this._loadGrammar(\n      initialScopeName,\n      initialLanguage,\n      configuration.embeddedLanguages,\n      configuration.tokenTypes,\n      new BalancedBracketSelectors(\n        configuration.balancedBracketSelectors || [],\n        configuration.unbalancedBracketSelectors || []\n      )\n    );\n  }\n  /**\n   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.\n   */\n  loadGrammar(initialScopeName) {\n    return this._loadGrammar(initialScopeName, 0, null, null, null);\n  }\n  _loadGrammar(initialScopeName, initialLanguage, embeddedLanguages, tokenTypes, balancedBracketSelectors) {\n    const dependencyProcessor = new ScopeDependencyProcessor(this._syncRegistry, initialScopeName);\n    while (dependencyProcessor.Q.length > 0) {\n      dependencyProcessor.Q.map((request) => this._loadSingleGrammar(request.scopeName));\n      dependencyProcessor.processQueue();\n    }\n    return this._grammarForScopeName(\n      initialScopeName,\n      initialLanguage,\n      embeddedLanguages,\n      tokenTypes,\n      balancedBracketSelectors\n    );\n  }\n  _loadSingleGrammar(scopeName) {\n    if (!this._ensureGrammarCache.has(scopeName)) {\n      this._doLoadSingleGrammar(scopeName);\n      this._ensureGrammarCache.set(scopeName, true);\n    }\n  }\n  _doLoadSingleGrammar(scopeName) {\n    const grammar = this._options.loadGrammar(scopeName);\n    if (grammar) {\n      const injections = typeof this._options.getInjections === \"function\" ? this._options.getInjections(scopeName) : void 0;\n      this._syncRegistry.addGrammar(grammar, injections);\n    }\n  }\n  /**\n   * Adds a rawGrammar.\n   */\n  addGrammar(rawGrammar, injections = [], initialLanguage = 0, embeddedLanguages = null) {\n    this._syncRegistry.addGrammar(rawGrammar, injections);\n    return this._grammarForScopeName(rawGrammar.scopeName, initialLanguage, embeddedLanguages);\n  }\n  /**\n   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.\n   */\n  _grammarForScopeName(scopeName, initialLanguage = 0, embeddedLanguages = null, tokenTypes = null, balancedBracketSelectors = null) {\n    return this._syncRegistry.grammarForScopeName(\n      scopeName,\n      initialLanguage,\n      embeddedLanguages,\n      tokenTypes,\n      balancedBracketSelectors\n    );\n  }\n};\nvar INITIAL = StateStackImpl.NULL;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNoaWtpanMrdnNjb2RlLXRleHRtYXRlQDEwLjAuMi9ub2RlX21vZHVsZXMvQHNoaWtpanMvdnNjb2RlLXRleHRtYXRlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMEJBQTBCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBLGtCQUFrQixFQUFFO0FBQ3BCO0FBQ0E7QUFDQSxrQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixFQUFFO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZCQUE2QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxpQkFBaUI7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxNQUFNO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFNBQVM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLE9BQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZSxHQUFHLGNBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHFCQUFxQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDBCQUEwQjtBQUN4RSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFFBQVEsOERBQThEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdEQUF3RDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdEQUF3RDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLHdEQUF3RCwyQ0FBMkM7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw4Q0FBOEM7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRiwyQ0FBMkM7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrQ0FBa0MsR0FBRyxvQkFBb0I7QUFDbEcsY0FBYyxzQkFBc0IsR0FBRyxTQUFTLElBQUksU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsV0FBVztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMEJBQTBCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFLLEVBQUUsRUFLVjtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBSyxFQUFFLEVBSVY7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSyxFQUFFLEVBSVY7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLLEVBQUUsRUFJVjtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUssRUFBRSxFQUlWO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFlBQVksS0FBSyxFQUFFLEVBRVY7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLLEVBQUUsRUFJVjtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxZQUFZLEtBQUssRUFBRSxFQUlWO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLLEVBQUUsRUFJVjtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EseUNBQXlDLFdBQVc7QUFDcEQsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQSxRQUFRLEtBQUssRUFBRSxFQUdWO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxLQUFLLEVBQUUsRUFFVjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQUssRUFBRSxFQUdWO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVksSUFBSSxnQ0FBZ0MsSUFBSSx1Q0FBdUM7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFLLEVBQUUsRUFFVixDQUFDO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixtQkFBbUI7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNFIiwic291cmNlcyI6WyIvaG9tZS9icm9uemUvY29kaW5nL2ZzYWttL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2hpa2lqcyt2c2NvZGUtdGV4dG1hdGVAMTAuMC4yL25vZGVfbW9kdWxlcy9Ac2hpa2lqcy92c2NvZGUtdGV4dG1hdGUvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXRpbHMudHNcbmZ1bmN0aW9uIGNsb25lKHNvbWV0aGluZykge1xuICByZXR1cm4gZG9DbG9uZShzb21ldGhpbmcpO1xufVxuZnVuY3Rpb24gZG9DbG9uZShzb21ldGhpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc29tZXRoaW5nKSkge1xuICAgIHJldHVybiBjbG9uZUFycmF5KHNvbWV0aGluZyk7XG4gIH1cbiAgaWYgKHNvbWV0aGluZyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiBzb21ldGhpbmc7XG4gIH1cbiAgaWYgKHR5cGVvZiBzb21ldGhpbmcgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gY2xvbmVPYmooc29tZXRoaW5nKTtcbiAgfVxuICByZXR1cm4gc29tZXRoaW5nO1xufVxuZnVuY3Rpb24gY2xvbmVBcnJheShhcnIpIHtcbiAgbGV0IHIgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHJbaV0gPSBkb0Nsb25lKGFycltpXSk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBjbG9uZU9iaihvYmopIHtcbiAgbGV0IHIgPSB7fTtcbiAgZm9yIChsZXQga2V5IGluIG9iaikge1xuICAgIHJba2V5XSA9IGRvQ2xvbmUob2JqW2tleV0pO1xuICB9XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKHRhcmdldCwgLi4uc291cmNlcykge1xuICBzb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgIGZvciAobGV0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGJhc2VuYW1lKHBhdGgpIHtcbiAgY29uc3QgaWR4ID0gfnBhdGgubGFzdEluZGV4T2YoXCIvXCIpIHx8IH5wYXRoLmxhc3RJbmRleE9mKFwiXFxcXFwiKTtcbiAgaWYgKGlkeCA9PT0gMCkge1xuICAgIHJldHVybiBwYXRoO1xuICB9IGVsc2UgaWYgKH5pZHggPT09IHBhdGgubGVuZ3RoIC0gMSkge1xuICAgIHJldHVybiBiYXNlbmFtZShwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxlbmd0aCAtIDEpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGF0aC5zdWJzdHIofmlkeCArIDEpO1xuICB9XG59XG52YXIgQ0FQVFVSSU5HX1JFR0VYX1NPVVJDRSA9IC9cXCQoXFxkKyl8XFwkeyhcXGQrKTpcXC8oZG93bmNhc2V8dXBjYXNlKX0vZztcbnZhciBSZWdleFNvdXJjZSA9IGNsYXNzIHtcbiAgc3RhdGljIGhhc0NhcHR1cmVzKHJlZ2V4U291cmNlKSB7XG4gICAgaWYgKHJlZ2V4U291cmNlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIENBUFRVUklOR19SRUdFWF9TT1VSQ0UubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gQ0FQVFVSSU5HX1JFR0VYX1NPVVJDRS50ZXN0KHJlZ2V4U291cmNlKTtcbiAgfVxuICBzdGF0aWMgcmVwbGFjZUNhcHR1cmVzKHJlZ2V4U291cmNlLCBjYXB0dXJlU291cmNlLCBjYXB0dXJlSW5kaWNlcykge1xuICAgIHJldHVybiByZWdleFNvdXJjZS5yZXBsYWNlKENBUFRVUklOR19SRUdFWF9TT1VSQ0UsIChtYXRjaCwgaW5kZXgsIGNvbW1hbmRJbmRleCwgY29tbWFuZCkgPT4ge1xuICAgICAgbGV0IGNhcHR1cmUgPSBjYXB0dXJlSW5kaWNlc1twYXJzZUludChpbmRleCB8fCBjb21tYW5kSW5kZXgsIDEwKV07XG4gICAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gY2FwdHVyZVNvdXJjZS5zdWJzdHJpbmcoY2FwdHVyZS5zdGFydCwgY2FwdHVyZS5lbmQpO1xuICAgICAgICB3aGlsZSAocmVzdWx0WzBdID09PSBcIi5cIikge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgICAgY2FzZSBcImRvd25jYXNlXCI6XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgY2FzZSBcInVwY2FzZVwiOlxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBzdHJjbXAoYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBzdHJBcnJDbXAoYSwgYikge1xuICBpZiAoYSA9PT0gbnVsbCAmJiBiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKCFhKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICghYikge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGxldCBsZW4xID0gYS5sZW5ndGg7XG4gIGxldCBsZW4yID0gYi5sZW5ndGg7XG4gIGlmIChsZW4xID09PSBsZW4yKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4xOyBpKyspIHtcbiAgICAgIGxldCByZXMgPSBzdHJjbXAoYVtpXSwgYltpXSk7XG4gICAgICBpZiAocmVzICE9PSAwKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBsZW4xIC0gbGVuMjtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRIZXhDb2xvcihoZXgpIHtcbiAgaWYgKC9eI1swLTlhLWZdezZ9JC9pLnRlc3QoaGV4KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICgvXiNbMC05YS1mXXs4fSQvaS50ZXN0KGhleCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoL14jWzAtOWEtZl17M30kL2kudGVzdChoZXgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKC9eI1swLTlhLWZdezR9JC9pLnRlc3QoaGV4KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cENoYXJhY3RlcnModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1tcXC1cXFxcXFx7XFx9XFwqXFwrXFw/XFx8XFxeXFwkXFwuXFwsXFxbXFxdXFwoXFwpXFwjXFxzXS9nLCBcIlxcXFwkJlwiKTtcbn1cbnZhciBDYWNoZWRGbiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZm4pIHtcbiAgICB0aGlzLmZuID0gZm47XG4gIH1cbiAgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBnZXQoa2V5KSB7XG4gICAgaWYgKHRoaXMuY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZm4oa2V5KTtcbiAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbi8vIHNyYy90aGVtZS50c1xudmFyIFRoZW1lID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihfY29sb3JNYXAsIF9kZWZhdWx0cywgX3Jvb3QpIHtcbiAgICB0aGlzLl9jb2xvck1hcCA9IF9jb2xvck1hcDtcbiAgICB0aGlzLl9kZWZhdWx0cyA9IF9kZWZhdWx0cztcbiAgICB0aGlzLl9yb290ID0gX3Jvb3Q7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUZyb21SYXdUaGVtZShzb3VyY2UsIGNvbG9yTWFwKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlRnJvbVBhcnNlZFRoZW1lKHBhcnNlVGhlbWUoc291cmNlKSwgY29sb3JNYXApO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVGcm9tUGFyc2VkVGhlbWUoc291cmNlLCBjb2xvck1hcCkge1xuICAgIHJldHVybiByZXNvbHZlUGFyc2VkVGhlbWVSdWxlcyhzb3VyY2UsIGNvbG9yTWFwKTtcbiAgfVxuICBfY2FjaGVkTWF0Y2hSb290ID0gbmV3IENhY2hlZEZuKFxuICAgIChzY29wZU5hbWUpID0+IHRoaXMuX3Jvb3QubWF0Y2goc2NvcGVOYW1lKVxuICApO1xuICBnZXRDb2xvck1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sb3JNYXAuZ2V0Q29sb3JNYXAoKTtcbiAgfVxuICBnZXREZWZhdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmYXVsdHM7XG4gIH1cbiAgbWF0Y2goc2NvcGVQYXRoKSB7XG4gICAgaWYgKHNjb3BlUGF0aCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRzO1xuICAgIH1cbiAgICBjb25zdCBzY29wZU5hbWUgPSBzY29wZVBhdGguc2NvcGVOYW1lO1xuICAgIGNvbnN0IG1hdGNoaW5nVHJpZUVsZW1lbnRzID0gdGhpcy5fY2FjaGVkTWF0Y2hSb290LmdldChzY29wZU5hbWUpO1xuICAgIGNvbnN0IGVmZmVjdGl2ZVJ1bGUgPSBtYXRjaGluZ1RyaWVFbGVtZW50cy5maW5kKFxuICAgICAgKHYpID0+IF9zY29wZVBhdGhNYXRjaGVzUGFyZW50U2NvcGVzKHNjb3BlUGF0aC5wYXJlbnQsIHYucGFyZW50U2NvcGVzKVxuICAgICk7XG4gICAgaWYgKCFlZmZlY3RpdmVSdWxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHlsZUF0dHJpYnV0ZXMoXG4gICAgICBlZmZlY3RpdmVSdWxlLmZvbnRTdHlsZSxcbiAgICAgIGVmZmVjdGl2ZVJ1bGUuZm9yZWdyb3VuZCxcbiAgICAgIGVmZmVjdGl2ZVJ1bGUuYmFja2dyb3VuZFxuICAgICk7XG4gIH1cbn07XG52YXIgU2NvcGVTdGFjayA9IGNsYXNzIF9TY29wZVN0YWNrIHtcbiAgY29uc3RydWN0b3IocGFyZW50LCBzY29wZU5hbWUpIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnNjb3BlTmFtZSA9IHNjb3BlTmFtZTtcbiAgfVxuICBzdGF0aWMgcHVzaChwYXRoLCBzY29wZU5hbWVzKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHNjb3BlTmFtZXMpIHtcbiAgICAgIHBhdGggPSBuZXcgX1Njb3BlU3RhY2socGF0aCwgbmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIHN0YXRpYyBmcm9tKC4uLnNlZ21lbnRzKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0ID0gbmV3IF9TY29wZVN0YWNrKHJlc3VsdCwgc2VnbWVudHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHB1c2goc2NvcGVOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBfU2NvcGVTdGFjayh0aGlzLCBzY29wZU5hbWUpO1xuICB9XG4gIGdldFNlZ21lbnRzKCkge1xuICAgIGxldCBpdGVtID0gdGhpcztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAoaXRlbSkge1xuICAgICAgcmVzdWx0LnB1c2goaXRlbS5zY29wZU5hbWUpO1xuICAgICAgaXRlbSA9IGl0ZW0ucGFyZW50O1xuICAgIH1cbiAgICByZXN1bHQucmV2ZXJzZSgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2VnbWVudHMoKS5qb2luKFwiIFwiKTtcbiAgfVxuICBleHRlbmRzKG90aGVyKSB7XG4gICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcmVudC5leHRlbmRzKG90aGVyKTtcbiAgfVxuICBnZXRFeHRlbnNpb25JZkRlZmluZWQoYmFzZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpdGVtID0gdGhpcztcbiAgICB3aGlsZSAoaXRlbSAmJiBpdGVtICE9PSBiYXNlKSB7XG4gICAgICByZXN1bHQucHVzaChpdGVtLnNjb3BlTmFtZSk7XG4gICAgICBpdGVtID0gaXRlbS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBpdGVtID09PSBiYXNlID8gcmVzdWx0LnJldmVyc2UoKSA6IHZvaWQgMDtcbiAgfVxufTtcbmZ1bmN0aW9uIF9zY29wZVBhdGhNYXRjaGVzUGFyZW50U2NvcGVzKHNjb3BlUGF0aCwgcGFyZW50U2NvcGVzKSB7XG4gIGlmIChwYXJlbnRTY29wZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhcmVudFNjb3Blcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBsZXQgc2NvcGVQYXR0ZXJuID0gcGFyZW50U2NvcGVzW2luZGV4XTtcbiAgICBsZXQgc2NvcGVNdXN0TWF0Y2ggPSBmYWxzZTtcbiAgICBpZiAoc2NvcGVQYXR0ZXJuID09PSBcIj5cIikge1xuICAgICAgaWYgKGluZGV4ID09PSBwYXJlbnRTY29wZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzY29wZVBhdHRlcm4gPSBwYXJlbnRTY29wZXNbKytpbmRleF07XG4gICAgICBzY29wZU11c3RNYXRjaCA9IHRydWU7XG4gICAgfVxuICAgIHdoaWxlIChzY29wZVBhdGgpIHtcbiAgICAgIGlmIChfbWF0Y2hlc1Njb3BlKHNjb3BlUGF0aC5zY29wZU5hbWUsIHNjb3BlUGF0dGVybikpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2NvcGVNdXN0TWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc2NvcGVQYXRoID0gc2NvcGVQYXRoLnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFzY29wZVBhdGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2NvcGVQYXRoID0gc2NvcGVQYXRoLnBhcmVudDtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIF9tYXRjaGVzU2NvcGUoc2NvcGVOYW1lLCBzY29wZVBhdHRlcm4pIHtcbiAgcmV0dXJuIHNjb3BlUGF0dGVybiA9PT0gc2NvcGVOYW1lIHx8IHNjb3BlTmFtZS5zdGFydHNXaXRoKHNjb3BlUGF0dGVybikgJiYgc2NvcGVOYW1lW3Njb3BlUGF0dGVybi5sZW5ndGhdID09PSBcIi5cIjtcbn1cbnZhciBTdHlsZUF0dHJpYnV0ZXMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGZvbnRTdHlsZSwgZm9yZWdyb3VuZElkLCBiYWNrZ3JvdW5kSWQpIHtcbiAgICB0aGlzLmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICB0aGlzLmZvcmVncm91bmRJZCA9IGZvcmVncm91bmRJZDtcbiAgICB0aGlzLmJhY2tncm91bmRJZCA9IGJhY2tncm91bmRJZDtcbiAgfVxufTtcbmZ1bmN0aW9uIHBhcnNlVGhlbWUoc291cmNlKSB7XG4gIGlmICghc291cmNlKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICghc291cmNlLnNldHRpbmdzIHx8ICFBcnJheS5pc0FycmF5KHNvdXJjZS5zZXR0aW5ncykpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgbGV0IHNldHRpbmdzID0gc291cmNlLnNldHRpbmdzO1xuICBsZXQgcmVzdWx0ID0gW10sIHJlc3VsdExlbiA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzZXR0aW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGxldCBlbnRyeSA9IHNldHRpbmdzW2ldO1xuICAgIGlmICghZW50cnkuc2V0dGluZ3MpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgc2NvcGVzO1xuICAgIGlmICh0eXBlb2YgZW50cnkuc2NvcGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGxldCBfc2NvcGUgPSBlbnRyeS5zY29wZTtcbiAgICAgIF9zY29wZSA9IF9zY29wZS5yZXBsYWNlKC9eWyxdKy8sIFwiXCIpO1xuICAgICAgX3Njb3BlID0gX3Njb3BlLnJlcGxhY2UoL1ssXSskLywgXCJcIik7XG4gICAgICBzY29wZXMgPSBfc2NvcGUuc3BsaXQoXCIsXCIpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbnRyeS5zY29wZSkpIHtcbiAgICAgIHNjb3BlcyA9IGVudHJ5LnNjb3BlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY29wZXMgPSBbXCJcIl07XG4gICAgfVxuICAgIGxldCBmb250U3R5bGUgPSAtMSAvKiBOb3RTZXQgKi87XG4gICAgaWYgKHR5cGVvZiBlbnRyeS5zZXR0aW5ncy5mb250U3R5bGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGZvbnRTdHlsZSA9IDAgLyogTm9uZSAqLztcbiAgICAgIGxldCBzZWdtZW50cyA9IGVudHJ5LnNldHRpbmdzLmZvbnRTdHlsZS5zcGxpdChcIiBcIik7XG4gICAgICBmb3IgKGxldCBqID0gMCwgbGVuSiA9IHNlZ21lbnRzLmxlbmd0aDsgaiA8IGxlbko7IGorKykge1xuICAgICAgICBsZXQgc2VnbWVudCA9IHNlZ21lbnRzW2pdO1xuICAgICAgICBzd2l0Y2ggKHNlZ21lbnQpIHtcbiAgICAgICAgICBjYXNlIFwiaXRhbGljXCI6XG4gICAgICAgICAgICBmb250U3R5bGUgPSBmb250U3R5bGUgfCAxIC8qIEl0YWxpYyAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJib2xkXCI6XG4gICAgICAgICAgICBmb250U3R5bGUgPSBmb250U3R5bGUgfCAyIC8qIEJvbGQgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidW5kZXJsaW5lXCI6XG4gICAgICAgICAgICBmb250U3R5bGUgPSBmb250U3R5bGUgfCA0IC8qIFVuZGVybGluZSAqLztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzdHJpa2V0aHJvdWdoXCI6XG4gICAgICAgICAgICBmb250U3R5bGUgPSBmb250U3R5bGUgfCA4IC8qIFN0cmlrZXRocm91Z2ggKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZm9yZWdyb3VuZCA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiBlbnRyeS5zZXR0aW5ncy5mb3JlZ3JvdW5kID09PSBcInN0cmluZ1wiICYmIGlzVmFsaWRIZXhDb2xvcihlbnRyeS5zZXR0aW5ncy5mb3JlZ3JvdW5kKSkge1xuICAgICAgZm9yZWdyb3VuZCA9IGVudHJ5LnNldHRpbmdzLmZvcmVncm91bmQ7XG4gICAgfVxuICAgIGxldCBiYWNrZ3JvdW5kID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIGVudHJ5LnNldHRpbmdzLmJhY2tncm91bmQgPT09IFwic3RyaW5nXCIgJiYgaXNWYWxpZEhleENvbG9yKGVudHJ5LnNldHRpbmdzLmJhY2tncm91bmQpKSB7XG4gICAgICBiYWNrZ3JvdW5kID0gZW50cnkuc2V0dGluZ3MuYmFja2dyb3VuZDtcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IDAsIGxlbkogPSBzY29wZXMubGVuZ3RoOyBqIDwgbGVuSjsgaisrKSB7XG4gICAgICBsZXQgX3Njb3BlID0gc2NvcGVzW2pdLnRyaW0oKTtcbiAgICAgIGxldCBzZWdtZW50cyA9IF9zY29wZS5zcGxpdChcIiBcIik7XG4gICAgICBsZXQgc2NvcGUgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgIGxldCBwYXJlbnRTY29wZXMgPSBudWxsO1xuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcGFyZW50U2NvcGVzID0gc2VnbWVudHMuc2xpY2UoMCwgc2VnbWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICAgIHBhcmVudFNjb3Blcy5yZXZlcnNlKCk7XG4gICAgICB9XG4gICAgICByZXN1bHRbcmVzdWx0TGVuKytdID0gbmV3IFBhcnNlZFRoZW1lUnVsZShcbiAgICAgICAgc2NvcGUsXG4gICAgICAgIHBhcmVudFNjb3BlcyxcbiAgICAgICAgaSxcbiAgICAgICAgZm9udFN0eWxlLFxuICAgICAgICBmb3JlZ3JvdW5kLFxuICAgICAgICBiYWNrZ3JvdW5kXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIFBhcnNlZFRoZW1lUnVsZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2NvcGUsIHBhcmVudFNjb3BlcywgaW5kZXgsIGZvbnRTdHlsZSwgZm9yZWdyb3VuZCwgYmFja2dyb3VuZCkge1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLnBhcmVudFNjb3BlcyA9IHBhcmVudFNjb3BlcztcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZDtcbiAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuICB9XG59O1xudmFyIEZvbnRTdHlsZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEZvbnRTdHlsZTIpID0+IHtcbiAgRm9udFN0eWxlMltGb250U3R5bGUyW1wiTm90U2V0XCJdID0gLTFdID0gXCJOb3RTZXRcIjtcbiAgRm9udFN0eWxlMltGb250U3R5bGUyW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gIEZvbnRTdHlsZTJbRm9udFN0eWxlMltcIkl0YWxpY1wiXSA9IDFdID0gXCJJdGFsaWNcIjtcbiAgRm9udFN0eWxlMltGb250U3R5bGUyW1wiQm9sZFwiXSA9IDJdID0gXCJCb2xkXCI7XG4gIEZvbnRTdHlsZTJbRm9udFN0eWxlMltcIlVuZGVybGluZVwiXSA9IDRdID0gXCJVbmRlcmxpbmVcIjtcbiAgRm9udFN0eWxlMltGb250U3R5bGUyW1wiU3RyaWtldGhyb3VnaFwiXSA9IDhdID0gXCJTdHJpa2V0aHJvdWdoXCI7XG4gIHJldHVybiBGb250U3R5bGUyO1xufSkoRm9udFN0eWxlIHx8IHt9KTtcbmZ1bmN0aW9uIHJlc29sdmVQYXJzZWRUaGVtZVJ1bGVzKHBhcnNlZFRoZW1lUnVsZXMsIF9jb2xvck1hcCkge1xuICBwYXJzZWRUaGVtZVJ1bGVzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBsZXQgciA9IHN0cmNtcChhLnNjb3BlLCBiLnNjb3BlKTtcbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIHIgPSBzdHJBcnJDbXAoYS5wYXJlbnRTY29wZXMsIGIucGFyZW50U2NvcGVzKTtcbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgfSk7XG4gIGxldCBkZWZhdWx0Rm9udFN0eWxlID0gMCAvKiBOb25lICovO1xuICBsZXQgZGVmYXVsdEZvcmVncm91bmQgPSBcIiMwMDAwMDBcIjtcbiAgbGV0IGRlZmF1bHRCYWNrZ3JvdW5kID0gXCIjZmZmZmZmXCI7XG4gIHdoaWxlIChwYXJzZWRUaGVtZVJ1bGVzLmxlbmd0aCA+PSAxICYmIHBhcnNlZFRoZW1lUnVsZXNbMF0uc2NvcGUgPT09IFwiXCIpIHtcbiAgICBsZXQgaW5jb21pbmdEZWZhdWx0cyA9IHBhcnNlZFRoZW1lUnVsZXMuc2hpZnQoKTtcbiAgICBpZiAoaW5jb21pbmdEZWZhdWx0cy5mb250U3R5bGUgIT09IC0xIC8qIE5vdFNldCAqLykge1xuICAgICAgZGVmYXVsdEZvbnRTdHlsZSA9IGluY29taW5nRGVmYXVsdHMuZm9udFN0eWxlO1xuICAgIH1cbiAgICBpZiAoaW5jb21pbmdEZWZhdWx0cy5mb3JlZ3JvdW5kICE9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0Rm9yZWdyb3VuZCA9IGluY29taW5nRGVmYXVsdHMuZm9yZWdyb3VuZDtcbiAgICB9XG4gICAgaWYgKGluY29taW5nRGVmYXVsdHMuYmFja2dyb3VuZCAhPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdEJhY2tncm91bmQgPSBpbmNvbWluZ0RlZmF1bHRzLmJhY2tncm91bmQ7XG4gICAgfVxuICB9XG4gIGxldCBjb2xvck1hcCA9IG5ldyBDb2xvck1hcChfY29sb3JNYXApO1xuICBsZXQgZGVmYXVsdHMgPSBuZXcgU3R5bGVBdHRyaWJ1dGVzKGRlZmF1bHRGb250U3R5bGUsIGNvbG9yTWFwLmdldElkKGRlZmF1bHRGb3JlZ3JvdW5kKSwgY29sb3JNYXAuZ2V0SWQoZGVmYXVsdEJhY2tncm91bmQpKTtcbiAgbGV0IHJvb3QgPSBuZXcgVGhlbWVUcmllRWxlbWVudChuZXcgVGhlbWVUcmllRWxlbWVudFJ1bGUoMCwgbnVsbCwgLTEgLyogTm90U2V0ICovLCAwLCAwKSwgW10pO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGFyc2VkVGhlbWVSdWxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGxldCBydWxlID0gcGFyc2VkVGhlbWVSdWxlc1tpXTtcbiAgICByb290Lmluc2VydCgwLCBydWxlLnNjb3BlLCBydWxlLnBhcmVudFNjb3BlcywgcnVsZS5mb250U3R5bGUsIGNvbG9yTWFwLmdldElkKHJ1bGUuZm9yZWdyb3VuZCksIGNvbG9yTWFwLmdldElkKHJ1bGUuYmFja2dyb3VuZCkpO1xuICB9XG4gIHJldHVybiBuZXcgVGhlbWUoY29sb3JNYXAsIGRlZmF1bHRzLCByb290KTtcbn1cbnZhciBDb2xvck1hcCA9IGNsYXNzIHtcbiAgX2lzRnJvemVuO1xuICBfbGFzdENvbG9ySWQ7XG4gIF9pZDJjb2xvcjtcbiAgX2NvbG9yMmlkO1xuICBjb25zdHJ1Y3RvcihfY29sb3JNYXApIHtcbiAgICB0aGlzLl9sYXN0Q29sb3JJZCA9IDA7XG4gICAgdGhpcy5faWQyY29sb3IgPSBbXTtcbiAgICB0aGlzLl9jb2xvcjJpZCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KF9jb2xvck1hcCkpIHtcbiAgICAgIHRoaXMuX2lzRnJvemVuID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBfY29sb3JNYXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5fY29sb3IyaWRbX2NvbG9yTWFwW2ldXSA9IGk7XG4gICAgICAgIHRoaXMuX2lkMmNvbG9yW2ldID0gX2NvbG9yTWFwW2ldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pc0Zyb3plbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBnZXRJZChjb2xvcikge1xuICAgIGlmIChjb2xvciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbG9yID0gY29sb3IudG9VcHBlckNhc2UoKTtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLl9jb2xvcjJpZFtjb2xvcl07XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pc0Zyb3plbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGNvbG9yIGluIGNvbG9yIG1hcCAtICR7Y29sb3J9YCk7XG4gICAgfVxuICAgIHZhbHVlID0gKyt0aGlzLl9sYXN0Q29sb3JJZDtcbiAgICB0aGlzLl9jb2xvcjJpZFtjb2xvcl0gPSB2YWx1ZTtcbiAgICB0aGlzLl9pZDJjb2xvclt2YWx1ZV0gPSBjb2xvcjtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZ2V0Q29sb3JNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkMmNvbG9yLnNsaWNlKDApO1xuICB9XG59O1xudmFyIGVtcHR5UGFyZW50U2NvcGVzID0gT2JqZWN0LmZyZWV6ZShbXSk7XG52YXIgVGhlbWVUcmllRWxlbWVudFJ1bGUgPSBjbGFzcyBfVGhlbWVUcmllRWxlbWVudFJ1bGUge1xuICBzY29wZURlcHRoO1xuICBwYXJlbnRTY29wZXM7XG4gIGZvbnRTdHlsZTtcbiAgZm9yZWdyb3VuZDtcbiAgYmFja2dyb3VuZDtcbiAgY29uc3RydWN0b3Ioc2NvcGVEZXB0aCwgcGFyZW50U2NvcGVzLCBmb250U3R5bGUsIGZvcmVncm91bmQsIGJhY2tncm91bmQpIHtcbiAgICB0aGlzLnNjb3BlRGVwdGggPSBzY29wZURlcHRoO1xuICAgIHRoaXMucGFyZW50U2NvcGVzID0gcGFyZW50U2NvcGVzIHx8IGVtcHR5UGFyZW50U2NvcGVzO1xuICAgIHRoaXMuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IGZvcmVncm91bmQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IF9UaGVtZVRyaWVFbGVtZW50UnVsZSh0aGlzLnNjb3BlRGVwdGgsIHRoaXMucGFyZW50U2NvcGVzLCB0aGlzLmZvbnRTdHlsZSwgdGhpcy5mb3JlZ3JvdW5kLCB0aGlzLmJhY2tncm91bmQpO1xuICB9XG4gIHN0YXRpYyBjbG9uZUFycihhcnIpIHtcbiAgICBsZXQgciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJbaV0gPSBhcnJbaV0uY2xvbmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgYWNjZXB0T3ZlcndyaXRlKHNjb3BlRGVwdGgsIGZvbnRTdHlsZSwgZm9yZWdyb3VuZCwgYmFja2dyb3VuZCkge1xuICAgIGlmICh0aGlzLnNjb3BlRGVwdGggPiBzY29wZURlcHRoKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImhvdyBkaWQgdGhpcyBoYXBwZW4/XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjb3BlRGVwdGggPSBzY29wZURlcHRoO1xuICAgIH1cbiAgICBpZiAoZm9udFN0eWxlICE9PSAtMSAvKiBOb3RTZXQgKi8pIHtcbiAgICAgIHRoaXMuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgIH1cbiAgICBpZiAoZm9yZWdyb3VuZCAhPT0gMCkge1xuICAgICAgdGhpcy5mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZDtcbiAgICB9XG4gICAgaWYgKGJhY2tncm91bmQgIT09IDApIHtcbiAgICAgIHRoaXMuYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XG4gICAgfVxuICB9XG59O1xudmFyIFRoZW1lVHJpZUVsZW1lbnQgPSBjbGFzcyBfVGhlbWVUcmllRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKF9tYWluUnVsZSwgcnVsZXNXaXRoUGFyZW50U2NvcGVzID0gW10sIF9jaGlsZHJlbiA9IHt9KSB7XG4gICAgdGhpcy5fbWFpblJ1bGUgPSBfbWFpblJ1bGU7XG4gICAgdGhpcy5fY2hpbGRyZW4gPSBfY2hpbGRyZW47XG4gICAgdGhpcy5fcnVsZXNXaXRoUGFyZW50U2NvcGVzID0gcnVsZXNXaXRoUGFyZW50U2NvcGVzO1xuICB9XG4gIF9ydWxlc1dpdGhQYXJlbnRTY29wZXM7XG4gIHN0YXRpYyBfY21wQnlTcGVjaWZpY2l0eShhLCBiKSB7XG4gICAgaWYgKGEuc2NvcGVEZXB0aCAhPT0gYi5zY29wZURlcHRoKSB7XG4gICAgICByZXR1cm4gYi5zY29wZURlcHRoIC0gYS5zY29wZURlcHRoO1xuICAgIH1cbiAgICBsZXQgYVBhcmVudEluZGV4ID0gMDtcbiAgICBsZXQgYlBhcmVudEluZGV4ID0gMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGEucGFyZW50U2NvcGVzW2FQYXJlbnRJbmRleF0gPT09IFwiPlwiKSB7XG4gICAgICAgIGFQYXJlbnRJbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKGIucGFyZW50U2NvcGVzW2JQYXJlbnRJbmRleF0gPT09IFwiPlwiKSB7XG4gICAgICAgIGJQYXJlbnRJbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKGFQYXJlbnRJbmRleCA+PSBhLnBhcmVudFNjb3Blcy5sZW5ndGggfHwgYlBhcmVudEluZGV4ID49IGIucGFyZW50U2NvcGVzLmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmVudFNjb3BlTGVuZ3RoRGlmZiA9IGIucGFyZW50U2NvcGVzW2JQYXJlbnRJbmRleF0ubGVuZ3RoIC0gYS5wYXJlbnRTY29wZXNbYVBhcmVudEluZGV4XS5sZW5ndGg7XG4gICAgICBpZiAocGFyZW50U2NvcGVMZW5ndGhEaWZmICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnRTY29wZUxlbmd0aERpZmY7XG4gICAgICB9XG4gICAgICBhUGFyZW50SW5kZXgrKztcbiAgICAgIGJQYXJlbnRJbmRleCsrO1xuICAgIH1cbiAgICByZXR1cm4gYi5wYXJlbnRTY29wZXMubGVuZ3RoIC0gYS5wYXJlbnRTY29wZXMubGVuZ3RoO1xuICB9XG4gIG1hdGNoKHNjb3BlKSB7XG4gICAgaWYgKHNjb3BlICE9PSBcIlwiKSB7XG4gICAgICBsZXQgZG90SW5kZXggPSBzY29wZS5pbmRleE9mKFwiLlwiKTtcbiAgICAgIGxldCBoZWFkO1xuICAgICAgbGV0IHRhaWw7XG4gICAgICBpZiAoZG90SW5kZXggPT09IC0xKSB7XG4gICAgICAgIGhlYWQgPSBzY29wZTtcbiAgICAgICAgdGFpbCA9IFwiXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFkID0gc2NvcGUuc3Vic3RyaW5nKDAsIGRvdEluZGV4KTtcbiAgICAgICAgdGFpbCA9IHNjb3BlLnN1YnN0cmluZyhkb3RJbmRleCArIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuLmhhc093blByb3BlcnR5KGhlYWQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbltoZWFkXS5tYXRjaCh0YWlsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcnVsZXMgPSB0aGlzLl9ydWxlc1dpdGhQYXJlbnRTY29wZXMuY29uY2F0KHRoaXMuX21haW5SdWxlKTtcbiAgICBydWxlcy5zb3J0KF9UaGVtZVRyaWVFbGVtZW50Ll9jbXBCeVNwZWNpZmljaXR5KTtcbiAgICByZXR1cm4gcnVsZXM7XG4gIH1cbiAgaW5zZXJ0KHNjb3BlRGVwdGgsIHNjb3BlLCBwYXJlbnRTY29wZXMsIGZvbnRTdHlsZSwgZm9yZWdyb3VuZCwgYmFja2dyb3VuZCkge1xuICAgIGlmIChzY29wZSA9PT0gXCJcIikge1xuICAgICAgdGhpcy5fZG9JbnNlcnRIZXJlKHNjb3BlRGVwdGgsIHBhcmVudFNjb3BlcywgZm9udFN0eWxlLCBmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGRvdEluZGV4ID0gc2NvcGUuaW5kZXhPZihcIi5cIik7XG4gICAgbGV0IGhlYWQ7XG4gICAgbGV0IHRhaWw7XG4gICAgaWYgKGRvdEluZGV4ID09PSAtMSkge1xuICAgICAgaGVhZCA9IHNjb3BlO1xuICAgICAgdGFpbCA9IFwiXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWQgPSBzY29wZS5zdWJzdHJpbmcoMCwgZG90SW5kZXgpO1xuICAgICAgdGFpbCA9IHNjb3BlLnN1YnN0cmluZyhkb3RJbmRleCArIDEpO1xuICAgIH1cbiAgICBsZXQgY2hpbGQ7XG4gICAgaWYgKHRoaXMuX2NoaWxkcmVuLmhhc093blByb3BlcnR5KGhlYWQpKSB7XG4gICAgICBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2hlYWRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZCA9IG5ldyBfVGhlbWVUcmllRWxlbWVudCh0aGlzLl9tYWluUnVsZS5jbG9uZSgpLCBUaGVtZVRyaWVFbGVtZW50UnVsZS5jbG9uZUFycih0aGlzLl9ydWxlc1dpdGhQYXJlbnRTY29wZXMpKTtcbiAgICAgIHRoaXMuX2NoaWxkcmVuW2hlYWRdID0gY2hpbGQ7XG4gICAgfVxuICAgIGNoaWxkLmluc2VydChzY29wZURlcHRoICsgMSwgdGFpbCwgcGFyZW50U2NvcGVzLCBmb250U3R5bGUsIGZvcmVncm91bmQsIGJhY2tncm91bmQpO1xuICB9XG4gIF9kb0luc2VydEhlcmUoc2NvcGVEZXB0aCwgcGFyZW50U2NvcGVzLCBmb250U3R5bGUsIGZvcmVncm91bmQsIGJhY2tncm91bmQpIHtcbiAgICBpZiAocGFyZW50U2NvcGVzID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9tYWluUnVsZS5hY2NlcHRPdmVyd3JpdGUoc2NvcGVEZXB0aCwgZm9udFN0eWxlLCBmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuX3J1bGVzV2l0aFBhcmVudFNjb3Blcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGV0IHJ1bGUgPSB0aGlzLl9ydWxlc1dpdGhQYXJlbnRTY29wZXNbaV07XG4gICAgICBpZiAoc3RyQXJyQ21wKHJ1bGUucGFyZW50U2NvcGVzLCBwYXJlbnRTY29wZXMpID09PSAwKSB7XG4gICAgICAgIHJ1bGUuYWNjZXB0T3ZlcndyaXRlKHNjb3BlRGVwdGgsIGZvbnRTdHlsZSwgZm9yZWdyb3VuZCwgYmFja2dyb3VuZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvbnRTdHlsZSA9PT0gLTEgLyogTm90U2V0ICovKSB7XG4gICAgICBmb250U3R5bGUgPSB0aGlzLl9tYWluUnVsZS5mb250U3R5bGU7XG4gICAgfVxuICAgIGlmIChmb3JlZ3JvdW5kID09PSAwKSB7XG4gICAgICBmb3JlZ3JvdW5kID0gdGhpcy5fbWFpblJ1bGUuZm9yZWdyb3VuZDtcbiAgICB9XG4gICAgaWYgKGJhY2tncm91bmQgPT09IDApIHtcbiAgICAgIGJhY2tncm91bmQgPSB0aGlzLl9tYWluUnVsZS5iYWNrZ3JvdW5kO1xuICAgIH1cbiAgICB0aGlzLl9ydWxlc1dpdGhQYXJlbnRTY29wZXMucHVzaChuZXcgVGhlbWVUcmllRWxlbWVudFJ1bGUoc2NvcGVEZXB0aCwgcGFyZW50U2NvcGVzLCBmb250U3R5bGUsIGZvcmVncm91bmQsIGJhY2tncm91bmQpKTtcbiAgfVxufTtcblxuLy8gc3JjL2VuY29kZWRUb2tlbkF0dHJpYnV0ZXMudHNcbnZhciBFbmNvZGVkVG9rZW5NZXRhZGF0YSA9IGNsYXNzIF9FbmNvZGVkVG9rZW5NZXRhZGF0YSB7XG4gIHN0YXRpYyB0b0JpbmFyeVN0cihlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMudG9TdHJpbmcoMikucGFkU3RhcnQoMzIsIFwiMFwiKTtcbiAgfVxuICBzdGF0aWMgcHJpbnQoZW5jb2RlZFRva2VuQXR0cmlidXRlcykge1xuICAgIGNvbnN0IGxhbmd1YWdlSWQgPSBfRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0TGFuZ3VhZ2VJZChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKTtcbiAgICBjb25zdCB0b2tlblR5cGUgPSBfRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0VG9rZW5UeXBlKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpO1xuICAgIGNvbnN0IGZvbnRTdHlsZSA9IF9FbmNvZGVkVG9rZW5NZXRhZGF0YS5nZXRGb250U3R5bGUoZW5jb2RlZFRva2VuQXR0cmlidXRlcyk7XG4gICAgY29uc3QgZm9yZWdyb3VuZCA9IF9FbmNvZGVkVG9rZW5NZXRhZGF0YS5nZXRGb3JlZ3JvdW5kKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpO1xuICAgIGNvbnN0IGJhY2tncm91bmQgPSBfRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0QmFja2dyb3VuZChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKTtcbiAgICBjb25zb2xlLmxvZyh7XG4gICAgICBsYW5ndWFnZUlkLFxuICAgICAgdG9rZW5UeXBlLFxuICAgICAgZm9udFN0eWxlLFxuICAgICAgZm9yZWdyb3VuZCxcbiAgICAgIGJhY2tncm91bmRcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0TGFuZ3VhZ2VJZChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzICYgMjU1IC8qIExBTkdVQUdFSURfTUFTSyAqLykgPj4+IDAgLyogTEFOR1VBR0VJRF9PRkZTRVQgKi87XG4gIH1cbiAgc3RhdGljIGdldFRva2VuVHlwZShlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzICYgNzY4IC8qIFRPS0VOX1RZUEVfTUFTSyAqLykgPj4+IDggLyogVE9LRU5fVFlQRV9PRkZTRVQgKi87XG4gIH1cbiAgc3RhdGljIGNvbnRhaW5zQmFsYW5jZWRCcmFja2V0cyhlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzICYgMTAyNCAvKiBCQUxBTkNFRF9CUkFDS0VUU19NQVNLICovKSAhPT0gMDtcbiAgfVxuICBzdGF0aWMgZ2V0Rm9udFN0eWxlKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMgJiAzMDcyMCAvKiBGT05UX1NUWUxFX01BU0sgKi8pID4+PiAxMSAvKiBGT05UX1NUWUxFX09GRlNFVCAqLztcbiAgfVxuICBzdGF0aWMgZ2V0Rm9yZWdyb3VuZChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzICYgMTY3NDQ0NDggLyogRk9SRUdST1VORF9NQVNLICovKSA+Pj4gMTUgLyogRk9SRUdST1VORF9PRkZTRVQgKi87XG4gIH1cbiAgc3RhdGljIGdldEJhY2tncm91bmQoZW5jb2RlZFRva2VuQXR0cmlidXRlcykge1xuICAgIHJldHVybiAoZW5jb2RlZFRva2VuQXR0cmlidXRlcyAmIDQyNzgxOTAwODAgLyogQkFDS0dST1VORF9NQVNLICovKSA+Pj4gMjQgLyogQkFDS0dST1VORF9PRkZTRVQgKi87XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGZpZWxkcyBpbiBgbWV0YWRhdGFgLlxuICAgKiBBIHZhbHVlIG9mIGAwYCwgYE5vdFNldGAgb3IgYG51bGxgIGluZGljYXRlcyB0aGF0IHRoZSBjb3JyZXNwb25kaW5nIGZpZWxkIHNob3VsZCBiZSBsZWZ0IGFzIGlzLlxuICAgKi9cbiAgc3RhdGljIHNldChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzLCBsYW5ndWFnZUlkLCB0b2tlblR5cGUsIGNvbnRhaW5zQmFsYW5jZWRCcmFja2V0cywgZm9udFN0eWxlLCBmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kKSB7XG4gICAgbGV0IF9sYW5ndWFnZUlkID0gX0VuY29kZWRUb2tlbk1ldGFkYXRhLmdldExhbmd1YWdlSWQoZW5jb2RlZFRva2VuQXR0cmlidXRlcyk7XG4gICAgbGV0IF90b2tlblR5cGUgPSBfRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0VG9rZW5UeXBlKGVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpO1xuICAgIGxldCBfY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzQml0ID0gX0VuY29kZWRUb2tlbk1ldGFkYXRhLmNvbnRhaW5zQmFsYW5jZWRCcmFja2V0cyhlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKSA/IDEgOiAwO1xuICAgIGxldCBfZm9udFN0eWxlID0gX0VuY29kZWRUb2tlbk1ldGFkYXRhLmdldEZvbnRTdHlsZShlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKTtcbiAgICBsZXQgX2ZvcmVncm91bmQgPSBfRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0Rm9yZWdyb3VuZChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKTtcbiAgICBsZXQgX2JhY2tncm91bmQgPSBfRW5jb2RlZFRva2VuTWV0YWRhdGEuZ2V0QmFja2dyb3VuZChlbmNvZGVkVG9rZW5BdHRyaWJ1dGVzKTtcbiAgICBpZiAobGFuZ3VhZ2VJZCAhPT0gMCkge1xuICAgICAgX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgIH1cbiAgICBpZiAodG9rZW5UeXBlICE9PSA4IC8qIE5vdFNldCAqLykge1xuICAgICAgX3Rva2VuVHlwZSA9IGZyb21PcHRpb25hbFRva2VuVHlwZSh0b2tlblR5cGUpO1xuICAgIH1cbiAgICBpZiAoY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzICE9PSBudWxsKSB7XG4gICAgICBfY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzQml0ID0gY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzID8gMSA6IDA7XG4gICAgfVxuICAgIGlmIChmb250U3R5bGUgIT09IC0xIC8qIE5vdFNldCAqLykge1xuICAgICAgX2ZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICB9XG4gICAgaWYgKGZvcmVncm91bmQgIT09IDApIHtcbiAgICAgIF9mb3JlZ3JvdW5kID0gZm9yZWdyb3VuZDtcbiAgICB9XG4gICAgaWYgKGJhY2tncm91bmQgIT09IDApIHtcbiAgICAgIF9iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcbiAgICB9XG4gICAgcmV0dXJuIChfbGFuZ3VhZ2VJZCA8PCAwIC8qIExBTkdVQUdFSURfT0ZGU0VUICovIHwgX3Rva2VuVHlwZSA8PCA4IC8qIFRPS0VOX1RZUEVfT0ZGU0VUICovIHwgX2NvbnRhaW5zQmFsYW5jZWRCcmFja2V0c0JpdCA8PCAxMCAvKiBCQUxBTkNFRF9CUkFDS0VUU19PRkZTRVQgKi8gfCBfZm9udFN0eWxlIDw8IDExIC8qIEZPTlRfU1RZTEVfT0ZGU0VUICovIHwgX2ZvcmVncm91bmQgPDwgMTUgLyogRk9SRUdST1VORF9PRkZTRVQgKi8gfCBfYmFja2dyb3VuZCA8PCAyNCAvKiBCQUNLR1JPVU5EX09GRlNFVCAqLykgPj4+IDA7XG4gIH1cbn07XG5mdW5jdGlvbiB0b09wdGlvbmFsVG9rZW5UeXBlKHN0YW5kYXJkVHlwZSkge1xuICByZXR1cm4gc3RhbmRhcmRUeXBlO1xufVxuZnVuY3Rpb24gZnJvbU9wdGlvbmFsVG9rZW5UeXBlKHN0YW5kYXJkVHlwZSkge1xuICByZXR1cm4gc3RhbmRhcmRUeXBlO1xufVxuXG4vLyBzcmMvbWF0Y2hlci50c1xuZnVuY3Rpb24gY3JlYXRlTWF0Y2hlcnMoc2VsZWN0b3IsIG1hdGNoZXNOYW1lKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgY29uc3QgdG9rZW5pemVyID0gbmV3VG9rZW5pemVyKHNlbGVjdG9yKTtcbiAgbGV0IHRva2VuID0gdG9rZW5pemVyLm5leHQoKTtcbiAgd2hpbGUgKHRva2VuICE9PSBudWxsKSB7XG4gICAgbGV0IHByaW9yaXR5ID0gMDtcbiAgICBpZiAodG9rZW4ubGVuZ3RoID09PSAyICYmIHRva2VuLmNoYXJBdCgxKSA9PT0gXCI6XCIpIHtcbiAgICAgIHN3aXRjaCAodG9rZW4uY2hhckF0KDApKSB7XG4gICAgICAgIGNhc2UgXCJSXCI6XG4gICAgICAgICAgcHJpb3JpdHkgPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgIHByaW9yaXR5ID0gLTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS5sb2coYFVua25vd24gcHJpb3JpdHkgJHt0b2tlbn0gaW4gc2NvcGUgc2VsZWN0b3JgKTtcbiAgICAgIH1cbiAgICAgIHRva2VuID0gdG9rZW5pemVyLm5leHQoKTtcbiAgICB9XG4gICAgbGV0IG1hdGNoZXIgPSBwYXJzZUNvbmp1bmN0aW9uKCk7XG4gICAgcmVzdWx0cy5wdXNoKHsgbWF0Y2hlciwgcHJpb3JpdHkgfSk7XG4gICAgaWYgKHRva2VuICE9PSBcIixcIikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRva2VuID0gdG9rZW5pemVyLm5leHQoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbiAgZnVuY3Rpb24gcGFyc2VPcGVyYW5kKCkge1xuICAgIGlmICh0b2tlbiA9PT0gXCItXCIpIHtcbiAgICAgIHRva2VuID0gdG9rZW5pemVyLm5leHQoKTtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb25Ub05lZ2F0ZSA9IHBhcnNlT3BlcmFuZCgpO1xuICAgICAgcmV0dXJuIChtYXRjaGVySW5wdXQpID0+ICEhZXhwcmVzc2lvblRvTmVnYXRlICYmICFleHByZXNzaW9uVG9OZWdhdGUobWF0Y2hlcklucHV0KTtcbiAgICB9XG4gICAgaWYgKHRva2VuID09PSBcIihcIikge1xuICAgICAgdG9rZW4gPSB0b2tlbml6ZXIubmV4dCgpO1xuICAgICAgY29uc3QgZXhwcmVzc2lvbkluUGFyZW50cyA9IHBhcnNlSW5uZXJFeHByZXNzaW9uKCk7XG4gICAgICBpZiAodG9rZW4gPT09IFwiKVwiKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5pemVyLm5leHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHByZXNzaW9uSW5QYXJlbnRzO1xuICAgIH1cbiAgICBpZiAoaXNJZGVudGlmaWVyKHRva2VuKSkge1xuICAgICAgY29uc3QgaWRlbnRpZmllcnMgPSBbXTtcbiAgICAgIGRvIHtcbiAgICAgICAgaWRlbnRpZmllcnMucHVzaCh0b2tlbik7XG4gICAgICAgIHRva2VuID0gdG9rZW5pemVyLm5leHQoKTtcbiAgICAgIH0gd2hpbGUgKGlzSWRlbnRpZmllcih0b2tlbikpO1xuICAgICAgcmV0dXJuIChtYXRjaGVySW5wdXQpID0+IG1hdGNoZXNOYW1lKGlkZW50aWZpZXJzLCBtYXRjaGVySW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBwYXJzZUNvbmp1bmN0aW9uKCkge1xuICAgIGNvbnN0IG1hdGNoZXJzID0gW107XG4gICAgbGV0IG1hdGNoZXIgPSBwYXJzZU9wZXJhbmQoKTtcbiAgICB3aGlsZSAobWF0Y2hlcikge1xuICAgICAgbWF0Y2hlcnMucHVzaChtYXRjaGVyKTtcbiAgICAgIG1hdGNoZXIgPSBwYXJzZU9wZXJhbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIChtYXRjaGVySW5wdXQpID0+IG1hdGNoZXJzLmV2ZXJ5KChtYXRjaGVyMikgPT4gbWF0Y2hlcjIobWF0Y2hlcklucHV0KSk7XG4gIH1cbiAgZnVuY3Rpb24gcGFyc2VJbm5lckV4cHJlc3Npb24oKSB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBbXTtcbiAgICBsZXQgbWF0Y2hlciA9IHBhcnNlQ29uanVuY3Rpb24oKTtcbiAgICB3aGlsZSAobWF0Y2hlcikge1xuICAgICAgbWF0Y2hlcnMucHVzaChtYXRjaGVyKTtcbiAgICAgIGlmICh0b2tlbiA9PT0gXCJ8XCIgfHwgdG9rZW4gPT09IFwiLFwiKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB0b2tlbiA9IHRva2VuaXplci5uZXh0KCk7XG4gICAgICAgIH0gd2hpbGUgKHRva2VuID09PSBcInxcIiB8fCB0b2tlbiA9PT0gXCIsXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtYXRjaGVyID0gcGFyc2VDb25qdW5jdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gKG1hdGNoZXJJbnB1dCkgPT4gbWF0Y2hlcnMuc29tZSgobWF0Y2hlcjIpID0+IG1hdGNoZXIyKG1hdGNoZXJJbnB1dCkpO1xuICB9XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXIodG9rZW4pIHtcbiAgcmV0dXJuICEhdG9rZW4gJiYgISF0b2tlbi5tYXRjaCgvW1xcd1xcLjpdKy8pO1xufVxuZnVuY3Rpb24gbmV3VG9rZW5pemVyKGlucHV0KSB7XG4gIGxldCByZWdleCA9IC8oW0xSXTp8W1xcd1xcLjpdW1xcd1xcLjpcXC1dKnxbXFwsXFx8XFwtXFwoXFwpXSkvZztcbiAgbGV0IG1hdGNoID0gcmVnZXguZXhlYyhpbnB1dCk7XG4gIHJldHVybiB7XG4gICAgbmV4dDogKCkgPT4ge1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcyA9IG1hdGNoWzBdO1xuICAgICAgbWF0Y2ggPSByZWdleC5leGVjKGlucHV0KTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvb25pZ0xpYi50c1xudmFyIEZpbmRPcHRpb24gPSAvKiBAX19QVVJFX18gKi8gKChGaW5kT3B0aW9uMikgPT4ge1xuICBGaW5kT3B0aW9uMltGaW5kT3B0aW9uMltcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICBGaW5kT3B0aW9uMltGaW5kT3B0aW9uMltcIk5vdEJlZ2luU3RyaW5nXCJdID0gMV0gPSBcIk5vdEJlZ2luU3RyaW5nXCI7XG4gIEZpbmRPcHRpb24yW0ZpbmRPcHRpb24yW1wiTm90RW5kU3RyaW5nXCJdID0gMl0gPSBcIk5vdEVuZFN0cmluZ1wiO1xuICBGaW5kT3B0aW9uMltGaW5kT3B0aW9uMltcIk5vdEJlZ2luUG9zaXRpb25cIl0gPSA0XSA9IFwiTm90QmVnaW5Qb3NpdGlvblwiO1xuICBGaW5kT3B0aW9uMltGaW5kT3B0aW9uMltcIkRlYnVnQ2FsbFwiXSA9IDhdID0gXCJEZWJ1Z0NhbGxcIjtcbiAgcmV0dXJuIEZpbmRPcHRpb24yO1xufSkoRmluZE9wdGlvbiB8fCB7fSk7XG5mdW5jdGlvbiBkaXNwb3NlT25pZ1N0cmluZyhzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIuZGlzcG9zZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgc3RyLmRpc3Bvc2UoKTtcbiAgfVxufVxuXG4vLyBzcmMvZ3JhbW1hci9ncmFtbWFyRGVwZW5kZW5jaWVzLnRzXG52YXIgVG9wTGV2ZWxSdWxlUmVmZXJlbmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihzY29wZU5hbWUpIHtcbiAgICB0aGlzLnNjb3BlTmFtZSA9IHNjb3BlTmFtZTtcbiAgfVxuICB0b0tleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZU5hbWU7XG4gIH1cbn07XG52YXIgVG9wTGV2ZWxSZXBvc2l0b3J5UnVsZVJlZmVyZW5jZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2NvcGVOYW1lLCBydWxlTmFtZSkge1xuICAgIHRoaXMuc2NvcGVOYW1lID0gc2NvcGVOYW1lO1xuICAgIHRoaXMucnVsZU5hbWUgPSBydWxlTmFtZTtcbiAgfVxuICB0b0tleSgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5zY29wZU5hbWV9IyR7dGhpcy5ydWxlTmFtZX1gO1xuICB9XG59O1xudmFyIEV4dGVybmFsUmVmZXJlbmNlQ29sbGVjdG9yID0gY2xhc3Mge1xuICBfcmVmZXJlbmNlcyA9IFtdO1xuICBfc2VlblJlZmVyZW5jZUtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBnZXQgcmVmZXJlbmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVmZXJlbmNlcztcbiAgfVxuICB2aXNpdGVkUnVsZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGFkZChyZWZlcmVuY2UpIHtcbiAgICBjb25zdCBrZXkgPSByZWZlcmVuY2UudG9LZXkoKTtcbiAgICBpZiAodGhpcy5fc2VlblJlZmVyZW5jZUtleXMuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc2VlblJlZmVyZW5jZUtleXMuYWRkKGtleSk7XG4gICAgdGhpcy5fcmVmZXJlbmNlcy5wdXNoKHJlZmVyZW5jZSk7XG4gIH1cbn07XG52YXIgU2NvcGVEZXBlbmRlbmN5UHJvY2Vzc29yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihyZXBvLCBpbml0aWFsU2NvcGVOYW1lKSB7XG4gICAgdGhpcy5yZXBvID0gcmVwbztcbiAgICB0aGlzLmluaXRpYWxTY29wZU5hbWUgPSBpbml0aWFsU2NvcGVOYW1lO1xuICAgIHRoaXMuc2VlbkZ1bGxTY29wZVJlcXVlc3RzLmFkZCh0aGlzLmluaXRpYWxTY29wZU5hbWUpO1xuICAgIHRoaXMuUSA9IFtuZXcgVG9wTGV2ZWxSdWxlUmVmZXJlbmNlKHRoaXMuaW5pdGlhbFNjb3BlTmFtZSldO1xuICB9XG4gIHNlZW5GdWxsU2NvcGVSZXF1ZXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHNlZW5QYXJ0aWFsU2NvcGVSZXF1ZXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIFE7XG4gIHByb2Nlc3NRdWV1ZSgpIHtcbiAgICBjb25zdCBxID0gdGhpcy5RO1xuICAgIHRoaXMuUSA9IFtdO1xuICAgIGNvbnN0IGRlcHMgPSBuZXcgRXh0ZXJuYWxSZWZlcmVuY2VDb2xsZWN0b3IoKTtcbiAgICBmb3IgKGNvbnN0IGRlcCBvZiBxKSB7XG4gICAgICBjb2xsZWN0UmVmZXJlbmNlc09mUmVmZXJlbmNlKGRlcCwgdGhpcy5pbml0aWFsU2NvcGVOYW1lLCB0aGlzLnJlcG8sIGRlcHMpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRlcCBvZiBkZXBzLnJlZmVyZW5jZXMpIHtcbiAgICAgIGlmIChkZXAgaW5zdGFuY2VvZiBUb3BMZXZlbFJ1bGVSZWZlcmVuY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VlbkZ1bGxTY29wZVJlcXVlc3RzLmhhcyhkZXAuc2NvcGVOYW1lKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VlbkZ1bGxTY29wZVJlcXVlc3RzLmFkZChkZXAuc2NvcGVOYW1lKTtcbiAgICAgICAgdGhpcy5RLnB1c2goZGVwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLnNlZW5GdWxsU2NvcGVSZXF1ZXN0cy5oYXMoZGVwLnNjb3BlTmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZWVuUGFydGlhbFNjb3BlUmVxdWVzdHMuaGFzKGRlcC50b0tleSgpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VlblBhcnRpYWxTY29wZVJlcXVlc3RzLmFkZChkZXAudG9LZXkoKSk7XG4gICAgICAgIHRoaXMuUS5wdXNoKGRlcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gY29sbGVjdFJlZmVyZW5jZXNPZlJlZmVyZW5jZShyZWZlcmVuY2UsIGJhc2VHcmFtbWFyU2NvcGVOYW1lLCByZXBvLCByZXN1bHQpIHtcbiAgY29uc3Qgc2VsZkdyYW1tYXIgPSByZXBvLmxvb2t1cChyZWZlcmVuY2Uuc2NvcGVOYW1lKTtcbiAgaWYgKCFzZWxmR3JhbW1hcikge1xuICAgIGlmIChyZWZlcmVuY2Uuc2NvcGVOYW1lID09PSBiYXNlR3JhbW1hclNjb3BlTmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBncmFtbWFyIHByb3ZpZGVkIGZvciA8JHtiYXNlR3JhbW1hclNjb3BlTmFtZX0+YCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBiYXNlR3JhbW1hciA9IHJlcG8ubG9va3VwKGJhc2VHcmFtbWFyU2NvcGVOYW1lKTtcbiAgaWYgKHJlZmVyZW5jZSBpbnN0YW5jZW9mIFRvcExldmVsUnVsZVJlZmVyZW5jZSkge1xuICAgIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblRvcExldmVsUnVsZSh7IGJhc2VHcmFtbWFyLCBzZWxmR3JhbW1hciB9LCByZXN1bHQpO1xuICB9IGVsc2Uge1xuICAgIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblRvcExldmVsUmVwb3NpdG9yeVJ1bGUoXG4gICAgICByZWZlcmVuY2UucnVsZU5hbWUsXG4gICAgICB7IGJhc2VHcmFtbWFyLCBzZWxmR3JhbW1hciwgcmVwb3NpdG9yeTogc2VsZkdyYW1tYXIucmVwb3NpdG9yeSB9LFxuICAgICAgcmVzdWx0XG4gICAgKTtcbiAgfVxuICBjb25zdCBpbmplY3Rpb25zID0gcmVwby5pbmplY3Rpb25zKHJlZmVyZW5jZS5zY29wZU5hbWUpO1xuICBpZiAoaW5qZWN0aW9ucykge1xuICAgIGZvciAoY29uc3QgaW5qZWN0aW9uIG9mIGluamVjdGlvbnMpIHtcbiAgICAgIHJlc3VsdC5hZGQobmV3IFRvcExldmVsUnVsZVJlZmVyZW5jZShpbmplY3Rpb24pKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblRvcExldmVsUmVwb3NpdG9yeVJ1bGUocnVsZU5hbWUsIGNvbnRleHQsIHJlc3VsdCkge1xuICBpZiAoY29udGV4dC5yZXBvc2l0b3J5ICYmIGNvbnRleHQucmVwb3NpdG9yeVtydWxlTmFtZV0pIHtcbiAgICBjb25zdCBydWxlID0gY29udGV4dC5yZXBvc2l0b3J5W3J1bGVOYW1lXTtcbiAgICBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5SdWxlcyhbcnVsZV0sIGNvbnRleHQsIHJlc3VsdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblRvcExldmVsUnVsZShjb250ZXh0LCByZXN1bHQpIHtcbiAgaWYgKGNvbnRleHQuc2VsZkdyYW1tYXIucGF0dGVybnMgJiYgQXJyYXkuaXNBcnJheShjb250ZXh0LnNlbGZHcmFtbWFyLnBhdHRlcm5zKSkge1xuICAgIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblJ1bGVzKFxuICAgICAgY29udGV4dC5zZWxmR3JhbW1hci5wYXR0ZXJucyxcbiAgICAgIHsgLi4uY29udGV4dCwgcmVwb3NpdG9yeTogY29udGV4dC5zZWxmR3JhbW1hci5yZXBvc2l0b3J5IH0sXG4gICAgICByZXN1bHRcbiAgICApO1xuICB9XG4gIGlmIChjb250ZXh0LnNlbGZHcmFtbWFyLmluamVjdGlvbnMpIHtcbiAgICBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5SdWxlcyhcbiAgICAgIE9iamVjdC52YWx1ZXMoY29udGV4dC5zZWxmR3JhbW1hci5pbmplY3Rpb25zKSxcbiAgICAgIHsgLi4uY29udGV4dCwgcmVwb3NpdG9yeTogY29udGV4dC5zZWxmR3JhbW1hci5yZXBvc2l0b3J5IH0sXG4gICAgICByZXN1bHRcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5SdWxlcyhydWxlcywgY29udGV4dCwgcmVzdWx0KSB7XG4gIGZvciAoY29uc3QgcnVsZSBvZiBydWxlcykge1xuICAgIGlmIChyZXN1bHQudmlzaXRlZFJ1bGUuaGFzKHJ1bGUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmVzdWx0LnZpc2l0ZWRSdWxlLmFkZChydWxlKTtcbiAgICBjb25zdCBwYXR0ZXJuUmVwb3NpdG9yeSA9IHJ1bGUucmVwb3NpdG9yeSA/IG1lcmdlT2JqZWN0cyh7fSwgY29udGV4dC5yZXBvc2l0b3J5LCBydWxlLnJlcG9zaXRvcnkpIDogY29udGV4dC5yZXBvc2l0b3J5O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJ1bGUucGF0dGVybnMpKSB7XG4gICAgICBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5SdWxlcyhydWxlLnBhdHRlcm5zLCB7IC4uLmNvbnRleHQsIHJlcG9zaXRvcnk6IHBhdHRlcm5SZXBvc2l0b3J5IH0sIHJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGluY2x1ZGUgPSBydWxlLmluY2x1ZGU7XG4gICAgaWYgKCFpbmNsdWRlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcmVmZXJlbmNlID0gcGFyc2VJbmNsdWRlKGluY2x1ZGUpO1xuICAgIHN3aXRjaCAocmVmZXJlbmNlLmtpbmQpIHtcbiAgICAgIGNhc2UgMCAvKiBCYXNlICovOlxuICAgICAgICBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5Ub3BMZXZlbFJ1bGUoeyAuLi5jb250ZXh0LCBzZWxmR3JhbW1hcjogY29udGV4dC5iYXNlR3JhbW1hciB9LCByZXN1bHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMSAvKiBTZWxmICovOlxuICAgICAgICBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5Ub3BMZXZlbFJ1bGUoY29udGV4dCwgcmVzdWx0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDIgLyogUmVsYXRpdmVSZWZlcmVuY2UgKi86XG4gICAgICAgIGNvbGxlY3RFeHRlcm5hbFJlZmVyZW5jZXNJblRvcExldmVsUmVwb3NpdG9yeVJ1bGUocmVmZXJlbmNlLnJ1bGVOYW1lLCB7IC4uLmNvbnRleHQsIHJlcG9zaXRvcnk6IHBhdHRlcm5SZXBvc2l0b3J5IH0sIHJlc3VsdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzIC8qIFRvcExldmVsUmVmZXJlbmNlICovOlxuICAgICAgY2FzZSA0IC8qIFRvcExldmVsUmVwb3NpdG9yeVJlZmVyZW5jZSAqLzpcbiAgICAgICAgY29uc3Qgc2VsZkdyYW1tYXIgPSByZWZlcmVuY2Uuc2NvcGVOYW1lID09PSBjb250ZXh0LnNlbGZHcmFtbWFyLnNjb3BlTmFtZSA/IGNvbnRleHQuc2VsZkdyYW1tYXIgOiByZWZlcmVuY2Uuc2NvcGVOYW1lID09PSBjb250ZXh0LmJhc2VHcmFtbWFyLnNjb3BlTmFtZSA/IGNvbnRleHQuYmFzZUdyYW1tYXIgOiB2b2lkIDA7XG4gICAgICAgIGlmIChzZWxmR3JhbW1hcikge1xuICAgICAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSB7IGJhc2VHcmFtbWFyOiBjb250ZXh0LmJhc2VHcmFtbWFyLCBzZWxmR3JhbW1hciwgcmVwb3NpdG9yeTogcGF0dGVyblJlcG9zaXRvcnkgfTtcbiAgICAgICAgICBpZiAocmVmZXJlbmNlLmtpbmQgPT09IDQgLyogVG9wTGV2ZWxSZXBvc2l0b3J5UmVmZXJlbmNlICovKSB7XG4gICAgICAgICAgICBjb2xsZWN0RXh0ZXJuYWxSZWZlcmVuY2VzSW5Ub3BMZXZlbFJlcG9zaXRvcnlSdWxlKHJlZmVyZW5jZS5ydWxlTmFtZSwgbmV3Q29udGV4dCwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sbGVjdEV4dGVybmFsUmVmZXJlbmNlc0luVG9wTGV2ZWxSdWxlKG5ld0NvbnRleHQsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyZWZlcmVuY2Uua2luZCA9PT0gNCAvKiBUb3BMZXZlbFJlcG9zaXRvcnlSZWZlcmVuY2UgKi8pIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQobmV3IFRvcExldmVsUmVwb3NpdG9yeVJ1bGVSZWZlcmVuY2UocmVmZXJlbmNlLnNjb3BlTmFtZSwgcmVmZXJlbmNlLnJ1bGVOYW1lKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5hZGQobmV3IFRvcExldmVsUnVsZVJlZmVyZW5jZShyZWZlcmVuY2Uuc2NvcGVOYW1lKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxudmFyIEJhc2VSZWZlcmVuY2UgPSBjbGFzcyB7XG4gIGtpbmQgPSAwIC8qIEJhc2UgKi87XG59O1xudmFyIFNlbGZSZWZlcmVuY2UgPSBjbGFzcyB7XG4gIGtpbmQgPSAxIC8qIFNlbGYgKi87XG59O1xudmFyIFJlbGF0aXZlUmVmZXJlbmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihydWxlTmFtZSkge1xuICAgIHRoaXMucnVsZU5hbWUgPSBydWxlTmFtZTtcbiAgfVxuICBraW5kID0gMiAvKiBSZWxhdGl2ZVJlZmVyZW5jZSAqLztcbn07XG52YXIgVG9wTGV2ZWxSZWZlcmVuY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHNjb3BlTmFtZSkge1xuICAgIHRoaXMuc2NvcGVOYW1lID0gc2NvcGVOYW1lO1xuICB9XG4gIGtpbmQgPSAzIC8qIFRvcExldmVsUmVmZXJlbmNlICovO1xufTtcbnZhciBUb3BMZXZlbFJlcG9zaXRvcnlSZWZlcmVuY2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHNjb3BlTmFtZSwgcnVsZU5hbWUpIHtcbiAgICB0aGlzLnNjb3BlTmFtZSA9IHNjb3BlTmFtZTtcbiAgICB0aGlzLnJ1bGVOYW1lID0gcnVsZU5hbWU7XG4gIH1cbiAga2luZCA9IDQgLyogVG9wTGV2ZWxSZXBvc2l0b3J5UmVmZXJlbmNlICovO1xufTtcbmZ1bmN0aW9uIHBhcnNlSW5jbHVkZShpbmNsdWRlKSB7XG4gIGlmIChpbmNsdWRlID09PSBcIiRiYXNlXCIpIHtcbiAgICByZXR1cm4gbmV3IEJhc2VSZWZlcmVuY2UoKTtcbiAgfSBlbHNlIGlmIChpbmNsdWRlID09PSBcIiRzZWxmXCIpIHtcbiAgICByZXR1cm4gbmV3IFNlbGZSZWZlcmVuY2UoKTtcbiAgfVxuICBjb25zdCBpbmRleE9mU2hhcnAgPSBpbmNsdWRlLmluZGV4T2YoXCIjXCIpO1xuICBpZiAoaW5kZXhPZlNoYXJwID09PSAtMSkge1xuICAgIHJldHVybiBuZXcgVG9wTGV2ZWxSZWZlcmVuY2UoaW5jbHVkZSk7XG4gIH0gZWxzZSBpZiAoaW5kZXhPZlNoYXJwID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBSZWxhdGl2ZVJlZmVyZW5jZShpbmNsdWRlLnN1YnN0cmluZygxKSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2NvcGVOYW1lID0gaW5jbHVkZS5zdWJzdHJpbmcoMCwgaW5kZXhPZlNoYXJwKTtcbiAgICBjb25zdCBydWxlTmFtZSA9IGluY2x1ZGUuc3Vic3RyaW5nKGluZGV4T2ZTaGFycCArIDEpO1xuICAgIHJldHVybiBuZXcgVG9wTGV2ZWxSZXBvc2l0b3J5UmVmZXJlbmNlKHNjb3BlTmFtZSwgcnVsZU5hbWUpO1xuICB9XG59XG5cbi8vIHNyYy9ydWxlLnRzXG52YXIgSEFTX0JBQ0tfUkVGRVJFTkNFUyA9IC9cXFxcKFxcZCspLztcbnZhciBCQUNLX1JFRkVSRU5DSU5HX0VORCA9IC9cXFxcKFxcZCspL2c7XG52YXIgcnVsZUlkU3ltYm9sID0gU3ltYm9sKFwiUnVsZUlkXCIpO1xudmFyIGVuZFJ1bGVJZCA9IC0xO1xudmFyIHdoaWxlUnVsZUlkID0gLTI7XG5mdW5jdGlvbiBydWxlSWRGcm9tTnVtYmVyKGlkKSB7XG4gIHJldHVybiBpZDtcbn1cbmZ1bmN0aW9uIHJ1bGVJZFRvTnVtYmVyKGlkKSB7XG4gIHJldHVybiBpZDtcbn1cbnZhciBSdWxlID0gY2xhc3Mge1xuICAkbG9jYXRpb247XG4gIGlkO1xuICBfbmFtZUlzQ2FwdHVyaW5nO1xuICBfbmFtZTtcbiAgX2NvbnRlbnROYW1lSXNDYXB0dXJpbmc7XG4gIF9jb250ZW50TmFtZTtcbiAgY29uc3RydWN0b3IoJGxvY2F0aW9uLCBpZCwgbmFtZSwgY29udGVudE5hbWUpIHtcbiAgICB0aGlzLiRsb2NhdGlvbiA9ICRsb2NhdGlvbjtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWUgfHwgbnVsbDtcbiAgICB0aGlzLl9uYW1lSXNDYXB0dXJpbmcgPSBSZWdleFNvdXJjZS5oYXNDYXB0dXJlcyh0aGlzLl9uYW1lKTtcbiAgICB0aGlzLl9jb250ZW50TmFtZSA9IGNvbnRlbnROYW1lIHx8IG51bGw7XG4gICAgdGhpcy5fY29udGVudE5hbWVJc0NhcHR1cmluZyA9IFJlZ2V4U291cmNlLmhhc0NhcHR1cmVzKHRoaXMuX2NvbnRlbnROYW1lKTtcbiAgfVxuICBnZXQgZGVidWdOYW1lKCkge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy4kbG9jYXRpb24gPyBgJHtiYXNlbmFtZSh0aGlzLiRsb2NhdGlvbi5maWxlbmFtZSl9OiR7dGhpcy4kbG9jYXRpb24ubGluZX1gIDogXCJ1bmtub3duXCI7XG4gICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0jJHt0aGlzLmlkfSBAICR7bG9jYXRpb259YDtcbiAgfVxuICBnZXROYW1lKGxpbmVUZXh0LCBjYXB0dXJlSW5kaWNlcykge1xuICAgIGlmICghdGhpcy5fbmFtZUlzQ2FwdHVyaW5nIHx8IHRoaXMuX25hbWUgPT09IG51bGwgfHwgbGluZVRleHQgPT09IG51bGwgfHwgY2FwdHVyZUluZGljZXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICByZXR1cm4gUmVnZXhTb3VyY2UucmVwbGFjZUNhcHR1cmVzKHRoaXMuX25hbWUsIGxpbmVUZXh0LCBjYXB0dXJlSW5kaWNlcyk7XG4gIH1cbiAgZ2V0Q29udGVudE5hbWUobGluZVRleHQsIGNhcHR1cmVJbmRpY2VzKSB7XG4gICAgaWYgKCF0aGlzLl9jb250ZW50TmFtZUlzQ2FwdHVyaW5nIHx8IHRoaXMuX2NvbnRlbnROYW1lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGVudE5hbWU7XG4gICAgfVxuICAgIHJldHVybiBSZWdleFNvdXJjZS5yZXBsYWNlQ2FwdHVyZXModGhpcy5fY29udGVudE5hbWUsIGxpbmVUZXh0LCBjYXB0dXJlSW5kaWNlcyk7XG4gIH1cbn07XG52YXIgQ2FwdHVyZVJ1bGUgPSBjbGFzcyBleHRlbmRzIFJ1bGUge1xuICByZXRva2VuaXplQ2FwdHVyZWRXaXRoUnVsZUlkO1xuICBjb25zdHJ1Y3RvcigkbG9jYXRpb24sIGlkLCBuYW1lLCBjb250ZW50TmFtZSwgcmV0b2tlbml6ZUNhcHR1cmVkV2l0aFJ1bGVJZCkge1xuICAgIHN1cGVyKCRsb2NhdGlvbiwgaWQsIG5hbWUsIGNvbnRlbnROYW1lKTtcbiAgICB0aGlzLnJldG9rZW5pemVDYXB0dXJlZFdpdGhSdWxlSWQgPSByZXRva2VuaXplQ2FwdHVyZWRXaXRoUnVsZUlkO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gIH1cbiAgY29sbGVjdFBhdHRlcm5zKGdyYW1tYXIsIG91dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBzdXBwb3J0ZWQhXCIpO1xuICB9XG4gIGNvbXBpbGUoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3Qgc3VwcG9ydGVkIVwiKTtcbiAgfVxuICBjb21waWxlQUcoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UsIGFsbG93QSwgYWxsb3dHKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHN1cHBvcnRlZCFcIik7XG4gIH1cbn07XG52YXIgTWF0Y2hSdWxlID0gY2xhc3MgZXh0ZW5kcyBSdWxlIHtcbiAgX21hdGNoO1xuICBjYXB0dXJlcztcbiAgX2NhY2hlZENvbXBpbGVkUGF0dGVybnM7XG4gIGNvbnN0cnVjdG9yKCRsb2NhdGlvbiwgaWQsIG5hbWUsIG1hdGNoLCBjYXB0dXJlcykge1xuICAgIHN1cGVyKCRsb2NhdGlvbiwgaWQsIG5hbWUsIG51bGwpO1xuICAgIHRoaXMuX21hdGNoID0gbmV3IFJlZ0V4cFNvdXJjZShtYXRjaCwgdGhpcy5pZCk7XG4gICAgdGhpcy5jYXB0dXJlcyA9IGNhcHR1cmVzO1xuICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMgPSBudWxsO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMpIHtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGdldCBkZWJ1Z01hdGNoUmVnRXhwKCkge1xuICAgIHJldHVybiBgJHt0aGlzLl9tYXRjaC5zb3VyY2V9YDtcbiAgfVxuICBjb2xsZWN0UGF0dGVybnMoZ3JhbW1hciwgb3V0KSB7XG4gICAgb3V0LnB1c2godGhpcy5fbWF0Y2gpO1xuICB9XG4gIGNvbXBpbGUoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyKS5jb21waWxlKGdyYW1tYXIpO1xuICB9XG4gIGNvbXBpbGVBRyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSwgYWxsb3dBLCBhbGxvd0cpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyKS5jb21waWxlQUcoZ3JhbW1hciwgYWxsb3dBLCBhbGxvd0cpO1xuICB9XG4gIF9nZXRDYWNoZWRDb21waWxlZFBhdHRlcm5zKGdyYW1tYXIpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMpIHtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMgPSBuZXcgUmVnRXhwU291cmNlTGlzdCgpO1xuICAgICAgdGhpcy5jb2xsZWN0UGF0dGVybnMoZ3JhbW1hciwgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zO1xuICB9XG59O1xudmFyIEluY2x1ZGVPbmx5UnVsZSA9IGNsYXNzIGV4dGVuZHMgUnVsZSB7XG4gIGhhc01pc3NpbmdQYXR0ZXJucztcbiAgcGF0dGVybnM7XG4gIF9jYWNoZWRDb21waWxlZFBhdHRlcm5zO1xuICBjb25zdHJ1Y3RvcigkbG9jYXRpb24sIGlkLCBuYW1lLCBjb250ZW50TmFtZSwgcGF0dGVybnMpIHtcbiAgICBzdXBlcigkbG9jYXRpb24sIGlkLCBuYW1lLCBjb250ZW50TmFtZSk7XG4gICAgdGhpcy5wYXR0ZXJucyA9IHBhdHRlcm5zLnBhdHRlcm5zO1xuICAgIHRoaXMuaGFzTWlzc2luZ1BhdHRlcm5zID0gcGF0dGVybnMuaGFzTWlzc2luZ1BhdHRlcm5zO1xuICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMgPSBudWxsO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMpIHtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGNvbGxlY3RQYXR0ZXJucyhncmFtbWFyLCBvdXQpIHtcbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgdGhpcy5wYXR0ZXJucykge1xuICAgICAgY29uc3QgcnVsZSA9IGdyYW1tYXIuZ2V0UnVsZShwYXR0ZXJuKTtcbiAgICAgIHJ1bGUuY29sbGVjdFBhdHRlcm5zKGdyYW1tYXIsIG91dCk7XG4gICAgfVxuICB9XG4gIGNvbXBpbGUoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyKS5jb21waWxlKGdyYW1tYXIpO1xuICB9XG4gIGNvbXBpbGVBRyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSwgYWxsb3dBLCBhbGxvd0cpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyKS5jb21waWxlQUcoZ3JhbW1hciwgYWxsb3dBLCBhbGxvd0cpO1xuICB9XG4gIF9nZXRDYWNoZWRDb21waWxlZFBhdHRlcm5zKGdyYW1tYXIpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMpIHtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMgPSBuZXcgUmVnRXhwU291cmNlTGlzdCgpO1xuICAgICAgdGhpcy5jb2xsZWN0UGF0dGVybnMoZ3JhbW1hciwgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zO1xuICB9XG59O1xudmFyIEJlZ2luRW5kUnVsZSA9IGNsYXNzIGV4dGVuZHMgUnVsZSB7XG4gIF9iZWdpbjtcbiAgYmVnaW5DYXB0dXJlcztcbiAgX2VuZDtcbiAgZW5kSGFzQmFja1JlZmVyZW5jZXM7XG4gIGVuZENhcHR1cmVzO1xuICBhcHBseUVuZFBhdHRlcm5MYXN0O1xuICBoYXNNaXNzaW5nUGF0dGVybnM7XG4gIHBhdHRlcm5zO1xuICBfY2FjaGVkQ29tcGlsZWRQYXR0ZXJucztcbiAgY29uc3RydWN0b3IoJGxvY2F0aW9uLCBpZCwgbmFtZSwgY29udGVudE5hbWUsIGJlZ2luLCBiZWdpbkNhcHR1cmVzLCBlbmQsIGVuZENhcHR1cmVzLCBhcHBseUVuZFBhdHRlcm5MYXN0LCBwYXR0ZXJucykge1xuICAgIHN1cGVyKCRsb2NhdGlvbiwgaWQsIG5hbWUsIGNvbnRlbnROYW1lKTtcbiAgICB0aGlzLl9iZWdpbiA9IG5ldyBSZWdFeHBTb3VyY2UoYmVnaW4sIHRoaXMuaWQpO1xuICAgIHRoaXMuYmVnaW5DYXB0dXJlcyA9IGJlZ2luQ2FwdHVyZXM7XG4gICAgdGhpcy5fZW5kID0gbmV3IFJlZ0V4cFNvdXJjZShlbmQgPyBlbmQgOiBcIlxcdUZGRkZcIiwgLTEpO1xuICAgIHRoaXMuZW5kSGFzQmFja1JlZmVyZW5jZXMgPSB0aGlzLl9lbmQuaGFzQmFja1JlZmVyZW5jZXM7XG4gICAgdGhpcy5lbmRDYXB0dXJlcyA9IGVuZENhcHR1cmVzO1xuICAgIHRoaXMuYXBwbHlFbmRQYXR0ZXJuTGFzdCA9IGFwcGx5RW5kUGF0dGVybkxhc3QgfHwgZmFsc2U7XG4gICAgdGhpcy5wYXR0ZXJucyA9IHBhdHRlcm5zLnBhdHRlcm5zO1xuICAgIHRoaXMuaGFzTWlzc2luZ1BhdHRlcm5zID0gcGF0dGVybnMuaGFzTWlzc2luZ1BhdHRlcm5zO1xuICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMgPSBudWxsO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMpIHtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGdldCBkZWJ1Z0JlZ2luUmVnRXhwKCkge1xuICAgIHJldHVybiBgJHt0aGlzLl9iZWdpbi5zb3VyY2V9YDtcbiAgfVxuICBnZXQgZGVidWdFbmRSZWdFeHAoKSB7XG4gICAgcmV0dXJuIGAke3RoaXMuX2VuZC5zb3VyY2V9YDtcbiAgfVxuICBnZXRFbmRXaXRoUmVzb2x2ZWRCYWNrUmVmZXJlbmNlcyhsaW5lVGV4dCwgY2FwdHVyZUluZGljZXMpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5kLnJlc29sdmVCYWNrUmVmZXJlbmNlcyhsaW5lVGV4dCwgY2FwdHVyZUluZGljZXMpO1xuICB9XG4gIGNvbGxlY3RQYXR0ZXJucyhncmFtbWFyLCBvdXQpIHtcbiAgICBvdXQucHVzaCh0aGlzLl9iZWdpbik7XG4gIH1cbiAgY29tcGlsZShncmFtbWFyLCBlbmRSZWdleFNvdXJjZSkge1xuICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZWRDb21waWxlZFBhdHRlcm5zKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKS5jb21waWxlKGdyYW1tYXIpO1xuICB9XG4gIGNvbXBpbGVBRyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSwgYWxsb3dBLCBhbGxvd0cpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSkuY29tcGlsZUFHKGdyYW1tYXIsIGFsbG93QSwgYWxsb3dHKTtcbiAgfVxuICBfZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSkge1xuICAgIGlmICghdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucykge1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucyA9IG5ldyBSZWdFeHBTb3VyY2VMaXN0KCk7XG4gICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgdGhpcy5wYXR0ZXJucykge1xuICAgICAgICBjb25zdCBydWxlID0gZ3JhbW1hci5nZXRSdWxlKHBhdHRlcm4pO1xuICAgICAgICBydWxlLmNvbGxlY3RQYXR0ZXJucyhncmFtbWFyLCB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmFwcGx5RW5kUGF0dGVybkxhc3QpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucy5wdXNoKHRoaXMuX2VuZC5oYXNCYWNrUmVmZXJlbmNlcyA/IHRoaXMuX2VuZC5jbG9uZSgpIDogdGhpcy5fZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMudW5zaGlmdCh0aGlzLl9lbmQuaGFzQmFja1JlZmVyZW5jZXMgPyB0aGlzLl9lbmQuY2xvbmUoKSA6IHRoaXMuX2VuZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl9lbmQuaGFzQmFja1JlZmVyZW5jZXMpIHtcbiAgICAgIGlmICh0aGlzLmFwcGx5RW5kUGF0dGVybkxhc3QpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucy5zZXRTb3VyY2UodGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucy5sZW5ndGgoKSAtIDEsIGVuZFJlZ2V4U291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMuc2V0U291cmNlKDAsIGVuZFJlZ2V4U291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnM7XG4gIH1cbn07XG52YXIgQmVnaW5XaGlsZVJ1bGUgPSBjbGFzcyBleHRlbmRzIFJ1bGUge1xuICBfYmVnaW47XG4gIGJlZ2luQ2FwdHVyZXM7XG4gIHdoaWxlQ2FwdHVyZXM7XG4gIF93aGlsZTtcbiAgd2hpbGVIYXNCYWNrUmVmZXJlbmNlcztcbiAgaGFzTWlzc2luZ1BhdHRlcm5zO1xuICBwYXR0ZXJucztcbiAgX2NhY2hlZENvbXBpbGVkUGF0dGVybnM7XG4gIF9jYWNoZWRDb21waWxlZFdoaWxlUGF0dGVybnM7XG4gIGNvbnN0cnVjdG9yKCRsb2NhdGlvbiwgaWQsIG5hbWUsIGNvbnRlbnROYW1lLCBiZWdpbiwgYmVnaW5DYXB0dXJlcywgX3doaWxlLCB3aGlsZUNhcHR1cmVzLCBwYXR0ZXJucykge1xuICAgIHN1cGVyKCRsb2NhdGlvbiwgaWQsIG5hbWUsIGNvbnRlbnROYW1lKTtcbiAgICB0aGlzLl9iZWdpbiA9IG5ldyBSZWdFeHBTb3VyY2UoYmVnaW4sIHRoaXMuaWQpO1xuICAgIHRoaXMuYmVnaW5DYXB0dXJlcyA9IGJlZ2luQ2FwdHVyZXM7XG4gICAgdGhpcy53aGlsZUNhcHR1cmVzID0gd2hpbGVDYXB0dXJlcztcbiAgICB0aGlzLl93aGlsZSA9IG5ldyBSZWdFeHBTb3VyY2UoX3doaWxlLCB3aGlsZVJ1bGVJZCk7XG4gICAgdGhpcy53aGlsZUhhc0JhY2tSZWZlcmVuY2VzID0gdGhpcy5fd2hpbGUuaGFzQmFja1JlZmVyZW5jZXM7XG4gICAgdGhpcy5wYXR0ZXJucyA9IHBhdHRlcm5zLnBhdHRlcm5zO1xuICAgIHRoaXMuaGFzTWlzc2luZ1BhdHRlcm5zID0gcGF0dGVybnMuaGFzTWlzc2luZ1BhdHRlcm5zO1xuICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMgPSBudWxsO1xuICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucyA9IG51bGw7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucykge1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucy5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucykge1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRXaGlsZVBhdHRlcm5zLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGdldCBkZWJ1Z0JlZ2luUmVnRXhwKCkge1xuICAgIHJldHVybiBgJHt0aGlzLl9iZWdpbi5zb3VyY2V9YDtcbiAgfVxuICBnZXQgZGVidWdXaGlsZVJlZ0V4cCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5fd2hpbGUuc291cmNlfWA7XG4gIH1cbiAgZ2V0V2hpbGVXaXRoUmVzb2x2ZWRCYWNrUmVmZXJlbmNlcyhsaW5lVGV4dCwgY2FwdHVyZUluZGljZXMpIHtcbiAgICByZXR1cm4gdGhpcy5fd2hpbGUucmVzb2x2ZUJhY2tSZWZlcmVuY2VzKGxpbmVUZXh0LCBjYXB0dXJlSW5kaWNlcyk7XG4gIH1cbiAgY29sbGVjdFBhdHRlcm5zKGdyYW1tYXIsIG91dCkge1xuICAgIG91dC5wdXNoKHRoaXMuX2JlZ2luKTtcbiAgfVxuICBjb21waWxlKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldENhY2hlZENvbXBpbGVkUGF0dGVybnMoZ3JhbW1hcikuY29tcGlsZShncmFtbWFyKTtcbiAgfVxuICBjb21waWxlQUcoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UsIGFsbG93QSwgYWxsb3dHKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldENhY2hlZENvbXBpbGVkUGF0dGVybnMoZ3JhbW1hcikuY29tcGlsZUFHKGdyYW1tYXIsIGFsbG93QSwgYWxsb3dHKTtcbiAgfVxuICBfZ2V0Q2FjaGVkQ29tcGlsZWRQYXR0ZXJucyhncmFtbWFyKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zKSB7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFBhdHRlcm5zID0gbmV3IFJlZ0V4cFNvdXJjZUxpc3QoKTtcbiAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiB0aGlzLnBhdHRlcm5zKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBncmFtbWFyLmdldFJ1bGUocGF0dGVybik7XG4gICAgICAgIHJ1bGUuY29sbGVjdFBhdHRlcm5zKGdyYW1tYXIsIHRoaXMuX2NhY2hlZENvbXBpbGVkUGF0dGVybnMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkQ29tcGlsZWRQYXR0ZXJucztcbiAgfVxuICBjb21waWxlV2hpbGUoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGVkQ29tcGlsZWRXaGlsZVBhdHRlcm5zKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKS5jb21waWxlKGdyYW1tYXIpO1xuICB9XG4gIGNvbXBpbGVXaGlsZUFHKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlLCBhbGxvd0EsIGFsbG93Rykge1xuICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZWRDb21waWxlZFdoaWxlUGF0dGVybnMoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UpLmNvbXBpbGVBRyhncmFtbWFyLCBhbGxvd0EsIGFsbG93Ryk7XG4gIH1cbiAgX2dldENhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSkge1xuICAgIGlmICghdGhpcy5fY2FjaGVkQ29tcGlsZWRXaGlsZVBhdHRlcm5zKSB7XG4gICAgICB0aGlzLl9jYWNoZWRDb21waWxlZFdoaWxlUGF0dGVybnMgPSBuZXcgUmVnRXhwU291cmNlTGlzdCgpO1xuICAgICAgdGhpcy5fY2FjaGVkQ29tcGlsZWRXaGlsZVBhdHRlcm5zLnB1c2godGhpcy5fd2hpbGUuaGFzQmFja1JlZmVyZW5jZXMgPyB0aGlzLl93aGlsZS5jbG9uZSgpIDogdGhpcy5fd2hpbGUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fd2hpbGUuaGFzQmFja1JlZmVyZW5jZXMpIHtcbiAgICAgIHRoaXMuX2NhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucy5zZXRTb3VyY2UoMCwgZW5kUmVnZXhTb3VyY2UgPyBlbmRSZWdleFNvdXJjZSA6IFwiXFx1RkZGRlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZENvbXBpbGVkV2hpbGVQYXR0ZXJucztcbiAgfVxufTtcbnZhciBSdWxlRmFjdG9yeSA9IGNsYXNzIF9SdWxlRmFjdG9yeSB7XG4gIHN0YXRpYyBjcmVhdGVDYXB0dXJlUnVsZShoZWxwZXIsICRsb2NhdGlvbiwgbmFtZSwgY29udGVudE5hbWUsIHJldG9rZW5pemVDYXB0dXJlZFdpdGhSdWxlSWQpIHtcbiAgICByZXR1cm4gaGVscGVyLnJlZ2lzdGVyUnVsZSgoaWQpID0+IHtcbiAgICAgIHJldHVybiBuZXcgQ2FwdHVyZVJ1bGUoJGxvY2F0aW9uLCBpZCwgbmFtZSwgY29udGVudE5hbWUsIHJldG9rZW5pemVDYXB0dXJlZFdpdGhSdWxlSWQpO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRDb21waWxlZFJ1bGVJZChkZXNjLCBoZWxwZXIsIHJlcG9zaXRvcnkpIHtcbiAgICBpZiAoIWRlc2MuaWQpIHtcbiAgICAgIGhlbHBlci5yZWdpc3RlclJ1bGUoKGlkKSA9PiB7XG4gICAgICAgIGRlc2MuaWQgPSBpZDtcbiAgICAgICAgaWYgKGRlc2MubWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IE1hdGNoUnVsZShcbiAgICAgICAgICAgIGRlc2MuJHZzY29kZVRleHRtYXRlTG9jYXRpb24sXG4gICAgICAgICAgICBkZXNjLmlkLFxuICAgICAgICAgICAgZGVzYy5uYW1lLFxuICAgICAgICAgICAgZGVzYy5tYXRjaCxcbiAgICAgICAgICAgIF9SdWxlRmFjdG9yeS5fY29tcGlsZUNhcHR1cmVzKGRlc2MuY2FwdHVyZXMsIGhlbHBlciwgcmVwb3NpdG9yeSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGVzYy5iZWdpbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGlmIChkZXNjLnJlcG9zaXRvcnkpIHtcbiAgICAgICAgICAgIHJlcG9zaXRvcnkgPSBtZXJnZU9iamVjdHMoe30sIHJlcG9zaXRvcnksIGRlc2MucmVwb3NpdG9yeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBwYXR0ZXJucyA9IGRlc2MucGF0dGVybnM7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJucyA9PT0gXCJ1bmRlZmluZWRcIiAmJiBkZXNjLmluY2x1ZGUpIHtcbiAgICAgICAgICAgIHBhdHRlcm5zID0gW3sgaW5jbHVkZTogZGVzYy5pbmNsdWRlIH1dO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IEluY2x1ZGVPbmx5UnVsZShcbiAgICAgICAgICAgIGRlc2MuJHZzY29kZVRleHRtYXRlTG9jYXRpb24sXG4gICAgICAgICAgICBkZXNjLmlkLFxuICAgICAgICAgICAgZGVzYy5uYW1lLFxuICAgICAgICAgICAgZGVzYy5jb250ZW50TmFtZSxcbiAgICAgICAgICAgIF9SdWxlRmFjdG9yeS5fY29tcGlsZVBhdHRlcm5zKHBhdHRlcm5zLCBoZWxwZXIsIHJlcG9zaXRvcnkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzYy53aGlsZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQmVnaW5XaGlsZVJ1bGUoXG4gICAgICAgICAgICBkZXNjLiR2c2NvZGVUZXh0bWF0ZUxvY2F0aW9uLFxuICAgICAgICAgICAgZGVzYy5pZCxcbiAgICAgICAgICAgIGRlc2MubmFtZSxcbiAgICAgICAgICAgIGRlc2MuY29udGVudE5hbWUsXG4gICAgICAgICAgICBkZXNjLmJlZ2luLFxuICAgICAgICAgICAgX1J1bGVGYWN0b3J5Ll9jb21waWxlQ2FwdHVyZXMoZGVzYy5iZWdpbkNhcHR1cmVzIHx8IGRlc2MuY2FwdHVyZXMsIGhlbHBlciwgcmVwb3NpdG9yeSksXG4gICAgICAgICAgICBkZXNjLndoaWxlLFxuICAgICAgICAgICAgX1J1bGVGYWN0b3J5Ll9jb21waWxlQ2FwdHVyZXMoZGVzYy53aGlsZUNhcHR1cmVzIHx8IGRlc2MuY2FwdHVyZXMsIGhlbHBlciwgcmVwb3NpdG9yeSksXG4gICAgICAgICAgICBfUnVsZUZhY3RvcnkuX2NvbXBpbGVQYXR0ZXJucyhkZXNjLnBhdHRlcm5zLCBoZWxwZXIsIHJlcG9zaXRvcnkpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJlZ2luRW5kUnVsZShcbiAgICAgICAgICBkZXNjLiR2c2NvZGVUZXh0bWF0ZUxvY2F0aW9uLFxuICAgICAgICAgIGRlc2MuaWQsXG4gICAgICAgICAgZGVzYy5uYW1lLFxuICAgICAgICAgIGRlc2MuY29udGVudE5hbWUsXG4gICAgICAgICAgZGVzYy5iZWdpbixcbiAgICAgICAgICBfUnVsZUZhY3RvcnkuX2NvbXBpbGVDYXB0dXJlcyhkZXNjLmJlZ2luQ2FwdHVyZXMgfHwgZGVzYy5jYXB0dXJlcywgaGVscGVyLCByZXBvc2l0b3J5KSxcbiAgICAgICAgICBkZXNjLmVuZCxcbiAgICAgICAgICBfUnVsZUZhY3RvcnkuX2NvbXBpbGVDYXB0dXJlcyhkZXNjLmVuZENhcHR1cmVzIHx8IGRlc2MuY2FwdHVyZXMsIGhlbHBlciwgcmVwb3NpdG9yeSksXG4gICAgICAgICAgZGVzYy5hcHBseUVuZFBhdHRlcm5MYXN0LFxuICAgICAgICAgIF9SdWxlRmFjdG9yeS5fY29tcGlsZVBhdHRlcm5zKGRlc2MucGF0dGVybnMsIGhlbHBlciwgcmVwb3NpdG9yeSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzYy5pZDtcbiAgfVxuICBzdGF0aWMgX2NvbXBpbGVDYXB0dXJlcyhjYXB0dXJlcywgaGVscGVyLCByZXBvc2l0b3J5KSB7XG4gICAgbGV0IHIgPSBbXTtcbiAgICBpZiAoY2FwdHVyZXMpIHtcbiAgICAgIGxldCBtYXhpbXVtQ2FwdHVyZUlkID0gMDtcbiAgICAgIGZvciAoY29uc3QgY2FwdHVyZUlkIGluIGNhcHR1cmVzKSB7XG4gICAgICAgIGlmIChjYXB0dXJlSWQgPT09IFwiJHZzY29kZVRleHRtYXRlTG9jYXRpb25cIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG51bWVyaWNDYXB0dXJlSWQgPSBwYXJzZUludChjYXB0dXJlSWQsIDEwKTtcbiAgICAgICAgaWYgKG51bWVyaWNDYXB0dXJlSWQgPiBtYXhpbXVtQ2FwdHVyZUlkKSB7XG4gICAgICAgICAgbWF4aW11bUNhcHR1cmVJZCA9IG51bWVyaWNDYXB0dXJlSWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG1heGltdW1DYXB0dXJlSWQ7IGkrKykge1xuICAgICAgICByW2ldID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2FwdHVyZUlkIGluIGNhcHR1cmVzKSB7XG4gICAgICAgIGlmIChjYXB0dXJlSWQgPT09IFwiJHZzY29kZVRleHRtYXRlTG9jYXRpb25cIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG51bWVyaWNDYXB0dXJlSWQgPSBwYXJzZUludChjYXB0dXJlSWQsIDEwKTtcbiAgICAgICAgbGV0IHJldG9rZW5pemVDYXB0dXJlZFdpdGhSdWxlSWQgPSAwO1xuICAgICAgICBpZiAoY2FwdHVyZXNbY2FwdHVyZUlkXS5wYXR0ZXJucykge1xuICAgICAgICAgIHJldG9rZW5pemVDYXB0dXJlZFdpdGhSdWxlSWQgPSBfUnVsZUZhY3RvcnkuZ2V0Q29tcGlsZWRSdWxlSWQoY2FwdHVyZXNbY2FwdHVyZUlkXSwgaGVscGVyLCByZXBvc2l0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByW251bWVyaWNDYXB0dXJlSWRdID0gX1J1bGVGYWN0b3J5LmNyZWF0ZUNhcHR1cmVSdWxlKGhlbHBlciwgY2FwdHVyZXNbY2FwdHVyZUlkXS4kdnNjb2RlVGV4dG1hdGVMb2NhdGlvbiwgY2FwdHVyZXNbY2FwdHVyZUlkXS5uYW1lLCBjYXB0dXJlc1tjYXB0dXJlSWRdLmNvbnRlbnROYW1lLCByZXRva2VuaXplQ2FwdHVyZWRXaXRoUnVsZUlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgc3RhdGljIF9jb21waWxlUGF0dGVybnMocGF0dGVybnMsIGhlbHBlciwgcmVwb3NpdG9yeSkge1xuICAgIGxldCByID0gW107XG4gICAgaWYgKHBhdHRlcm5zKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGF0dGVybnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHBhdHRlcm5zW2ldO1xuICAgICAgICBsZXQgcnVsZUlkID0gLTE7XG4gICAgICAgIGlmIChwYXR0ZXJuLmluY2x1ZGUpIHtcbiAgICAgICAgICBjb25zdCByZWZlcmVuY2UgPSBwYXJzZUluY2x1ZGUocGF0dGVybi5pbmNsdWRlKTtcbiAgICAgICAgICBzd2l0Y2ggKHJlZmVyZW5jZS5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIDAgLyogQmFzZSAqLzpcbiAgICAgICAgICAgIGNhc2UgMSAvKiBTZWxmICovOlxuICAgICAgICAgICAgICBydWxlSWQgPSBfUnVsZUZhY3RvcnkuZ2V0Q29tcGlsZWRSdWxlSWQocmVwb3NpdG9yeVtwYXR0ZXJuLmluY2x1ZGVdLCBoZWxwZXIsIHJlcG9zaXRvcnkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMiAvKiBSZWxhdGl2ZVJlZmVyZW5jZSAqLzpcbiAgICAgICAgICAgICAgbGV0IGxvY2FsSW5jbHVkZWRSdWxlID0gcmVwb3NpdG9yeVtyZWZlcmVuY2UucnVsZU5hbWVdO1xuICAgICAgICAgICAgICBpZiAobG9jYWxJbmNsdWRlZFJ1bGUpIHtcbiAgICAgICAgICAgICAgICBydWxlSWQgPSBfUnVsZUZhY3RvcnkuZ2V0Q29tcGlsZWRSdWxlSWQobG9jYWxJbmNsdWRlZFJ1bGUsIGhlbHBlciwgcmVwb3NpdG9yeSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDMgLyogVG9wTGV2ZWxSZWZlcmVuY2UgKi86XG4gICAgICAgICAgICBjYXNlIDQgLyogVG9wTGV2ZWxSZXBvc2l0b3J5UmVmZXJlbmNlICovOlxuICAgICAgICAgICAgICBjb25zdCBleHRlcm5hbEdyYW1tYXJOYW1lID0gcmVmZXJlbmNlLnNjb3BlTmFtZTtcbiAgICAgICAgICAgICAgY29uc3QgZXh0ZXJuYWxHcmFtbWFySW5jbHVkZSA9IHJlZmVyZW5jZS5raW5kID09PSA0IC8qIFRvcExldmVsUmVwb3NpdG9yeVJlZmVyZW5jZSAqLyA/IHJlZmVyZW5jZS5ydWxlTmFtZSA6IG51bGw7XG4gICAgICAgICAgICAgIGNvbnN0IGV4dGVybmFsR3JhbW1hciA9IGhlbHBlci5nZXRFeHRlcm5hbEdyYW1tYXIoZXh0ZXJuYWxHcmFtbWFyTmFtZSwgcmVwb3NpdG9yeSk7XG4gICAgICAgICAgICAgIGlmIChleHRlcm5hbEdyYW1tYXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZXJuYWxHcmFtbWFySW5jbHVkZSkge1xuICAgICAgICAgICAgICAgICAgbGV0IGV4dGVybmFsSW5jbHVkZWRSdWxlID0gZXh0ZXJuYWxHcmFtbWFyLnJlcG9zaXRvcnlbZXh0ZXJuYWxHcmFtbWFySW5jbHVkZV07XG4gICAgICAgICAgICAgICAgICBpZiAoZXh0ZXJuYWxJbmNsdWRlZFJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkID0gX1J1bGVGYWN0b3J5LmdldENvbXBpbGVkUnVsZUlkKGV4dGVybmFsSW5jbHVkZWRSdWxlLCBoZWxwZXIsIGV4dGVybmFsR3JhbW1hci5yZXBvc2l0b3J5KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJ1bGVJZCA9IF9SdWxlRmFjdG9yeS5nZXRDb21waWxlZFJ1bGVJZChleHRlcm5hbEdyYW1tYXIucmVwb3NpdG9yeS4kc2VsZiwgaGVscGVyLCBleHRlcm5hbEdyYW1tYXIucmVwb3NpdG9yeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBydWxlSWQgPSBfUnVsZUZhY3RvcnkuZ2V0Q29tcGlsZWRSdWxlSWQocGF0dGVybiwgaGVscGVyLCByZXBvc2l0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVsZUlkICE9PSAtMSkge1xuICAgICAgICAgIGNvbnN0IHJ1bGUgPSBoZWxwZXIuZ2V0UnVsZShydWxlSWQpO1xuICAgICAgICAgIGxldCBza2lwUnVsZSA9IGZhbHNlO1xuICAgICAgICAgIGlmIChydWxlIGluc3RhbmNlb2YgSW5jbHVkZU9ubHlSdWxlIHx8IHJ1bGUgaW5zdGFuY2VvZiBCZWdpbkVuZFJ1bGUgfHwgcnVsZSBpbnN0YW5jZW9mIEJlZ2luV2hpbGVSdWxlKSB7XG4gICAgICAgICAgICBpZiAocnVsZS5oYXNNaXNzaW5nUGF0dGVybnMgJiYgcnVsZS5wYXR0ZXJucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgc2tpcFJ1bGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2tpcFJ1bGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByLnB1c2gocnVsZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGF0dGVybnM6IHIsXG4gICAgICBoYXNNaXNzaW5nUGF0dGVybnM6IChwYXR0ZXJucyA/IHBhdHRlcm5zLmxlbmd0aCA6IDApICE9PSByLmxlbmd0aFxuICAgIH07XG4gIH1cbn07XG52YXIgUmVnRXhwU291cmNlID0gY2xhc3MgX1JlZ0V4cFNvdXJjZSB7XG4gIHNvdXJjZTtcbiAgcnVsZUlkO1xuICBoYXNBbmNob3I7XG4gIGhhc0JhY2tSZWZlcmVuY2VzO1xuICBfYW5jaG9yQ2FjaGU7XG4gIGNvbnN0cnVjdG9yKHJlZ0V4cFNvdXJjZSwgcnVsZUlkKSB7XG4gICAgaWYgKHJlZ0V4cFNvdXJjZSAmJiB0eXBlb2YgcmVnRXhwU291cmNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBsZW4gPSByZWdFeHBTb3VyY2UubGVuZ3RoO1xuICAgICAgbGV0IGxhc3RQdXNoZWRQb3MgPSAwO1xuICAgICAgbGV0IG91dHB1dCA9IFtdO1xuICAgICAgbGV0IGhhc0FuY2hvciA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOyBwb3MrKykge1xuICAgICAgICBjb25zdCBjaCA9IHJlZ0V4cFNvdXJjZS5jaGFyQXQocG9zKTtcbiAgICAgICAgaWYgKGNoID09PSBcIlxcXFxcIikge1xuICAgICAgICAgIGlmIChwb3MgKyAxIDwgbGVuKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0Q2ggPSByZWdFeHBTb3VyY2UuY2hhckF0KHBvcyArIDEpO1xuICAgICAgICAgICAgaWYgKG5leHRDaCA9PT0gXCJ6XCIpIHtcbiAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocmVnRXhwU291cmNlLnN1YnN0cmluZyhsYXN0UHVzaGVkUG9zLCBwb3MpKTtcbiAgICAgICAgICAgICAgb3V0cHV0LnB1c2goXCIkKD8hXFxcXG4pKD88IVxcXFxuKVwiKTtcbiAgICAgICAgICAgICAgbGFzdFB1c2hlZFBvcyA9IHBvcyArIDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRDaCA9PT0gXCJBXCIgfHwgbmV4dENoID09PSBcIkdcIikge1xuICAgICAgICAgICAgICBoYXNBbmNob3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmhhc0FuY2hvciA9IGhhc0FuY2hvcjtcbiAgICAgIGlmIChsYXN0UHVzaGVkUG9zID09PSAwKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gcmVnRXhwU291cmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2gocmVnRXhwU291cmNlLnN1YnN0cmluZyhsYXN0UHVzaGVkUG9zLCBsZW4pKTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBvdXRwdXQuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYXNBbmNob3IgPSBmYWxzZTtcbiAgICAgIHRoaXMuc291cmNlID0gcmVnRXhwU291cmNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNBbmNob3IpIHtcbiAgICAgIHRoaXMuX2FuY2hvckNhY2hlID0gdGhpcy5fYnVpbGRBbmNob3JDYWNoZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hbmNob3JDYWNoZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucnVsZUlkID0gcnVsZUlkO1xuICAgIGlmICh0eXBlb2YgdGhpcy5zb3VyY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuaGFzQmFja1JlZmVyZW5jZXMgPSBIQVNfQkFDS19SRUZFUkVOQ0VTLnRlc3QodGhpcy5zb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhc0JhY2tSZWZlcmVuY2VzID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgX1JlZ0V4cFNvdXJjZSh0aGlzLnNvdXJjZSwgdGhpcy5ydWxlSWQpO1xuICB9XG4gIHNldFNvdXJjZShuZXdTb3VyY2UpIHtcbiAgICBpZiAodGhpcy5zb3VyY2UgPT09IG5ld1NvdXJjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNvdXJjZSA9IG5ld1NvdXJjZTtcbiAgICBpZiAodGhpcy5oYXNBbmNob3IpIHtcbiAgICAgIHRoaXMuX2FuY2hvckNhY2hlID0gdGhpcy5fYnVpbGRBbmNob3JDYWNoZSgpO1xuICAgIH1cbiAgfVxuICByZXNvbHZlQmFja1JlZmVyZW5jZXMobGluZVRleHQsIGNhcHR1cmVJbmRpY2VzKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGlmIHRoZSBzb3VyY2UgaXMgYSBzdHJpbmdcIik7XG4gICAgfVxuICAgIGxldCBjYXB0dXJlZFZhbHVlcyA9IGNhcHR1cmVJbmRpY2VzLm1hcCgoY2FwdHVyZSkgPT4ge1xuICAgICAgcmV0dXJuIGxpbmVUZXh0LnN1YnN0cmluZyhjYXB0dXJlLnN0YXJ0LCBjYXB0dXJlLmVuZCk7XG4gICAgfSk7XG4gICAgQkFDS19SRUZFUkVOQ0lOR19FTkQubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UucmVwbGFjZShCQUNLX1JFRkVSRU5DSU5HX0VORCwgKG1hdGNoLCBnMSkgPT4ge1xuICAgICAgcmV0dXJuIGVzY2FwZVJlZ0V4cENoYXJhY3RlcnMoY2FwdHVyZWRWYWx1ZXNbcGFyc2VJbnQoZzEsIDEwKV0gfHwgXCJcIik7XG4gICAgfSk7XG4gIH1cbiAgX2J1aWxkQW5jaG9yQ2FjaGUoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNvdXJjZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGlmIHRoZSBzb3VyY2UgaXMgYSBzdHJpbmdcIik7XG4gICAgfVxuICAgIGxldCBBMF9HMF9yZXN1bHQgPSBbXTtcbiAgICBsZXQgQTBfRzFfcmVzdWx0ID0gW107XG4gICAgbGV0IEExX0cwX3Jlc3VsdCA9IFtdO1xuICAgIGxldCBBMV9HMV9yZXN1bHQgPSBbXTtcbiAgICBsZXQgcG9zLCBsZW4sIGNoLCBuZXh0Q2g7XG4gICAgZm9yIChwb3MgPSAwLCBsZW4gPSB0aGlzLnNvdXJjZS5sZW5ndGg7IHBvcyA8IGxlbjsgcG9zKyspIHtcbiAgICAgIGNoID0gdGhpcy5zb3VyY2UuY2hhckF0KHBvcyk7XG4gICAgICBBMF9HMF9yZXN1bHRbcG9zXSA9IGNoO1xuICAgICAgQTBfRzFfcmVzdWx0W3Bvc10gPSBjaDtcbiAgICAgIEExX0cwX3Jlc3VsdFtwb3NdID0gY2g7XG4gICAgICBBMV9HMV9yZXN1bHRbcG9zXSA9IGNoO1xuICAgICAgaWYgKGNoID09PSBcIlxcXFxcIikge1xuICAgICAgICBpZiAocG9zICsgMSA8IGxlbikge1xuICAgICAgICAgIG5leHRDaCA9IHRoaXMuc291cmNlLmNoYXJBdChwb3MgKyAxKTtcbiAgICAgICAgICBpZiAobmV4dENoID09PSBcIkFcIikge1xuICAgICAgICAgICAgQTBfRzBfcmVzdWx0W3BvcyArIDFdID0gXCJcXHVGRkZGXCI7XG4gICAgICAgICAgICBBMF9HMV9yZXN1bHRbcG9zICsgMV0gPSBcIlxcdUZGRkZcIjtcbiAgICAgICAgICAgIEExX0cwX3Jlc3VsdFtwb3MgKyAxXSA9IFwiQVwiO1xuICAgICAgICAgICAgQTFfRzFfcmVzdWx0W3BvcyArIDFdID0gXCJBXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0Q2ggPT09IFwiR1wiKSB7XG4gICAgICAgICAgICBBMF9HMF9yZXN1bHRbcG9zICsgMV0gPSBcIlxcdUZGRkZcIjtcbiAgICAgICAgICAgIEEwX0cxX3Jlc3VsdFtwb3MgKyAxXSA9IFwiR1wiO1xuICAgICAgICAgICAgQTFfRzBfcmVzdWx0W3BvcyArIDFdID0gXCJcXHVGRkZGXCI7XG4gICAgICAgICAgICBBMV9HMV9yZXN1bHRbcG9zICsgMV0gPSBcIkdcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQTBfRzBfcmVzdWx0W3BvcyArIDFdID0gbmV4dENoO1xuICAgICAgICAgICAgQTBfRzFfcmVzdWx0W3BvcyArIDFdID0gbmV4dENoO1xuICAgICAgICAgICAgQTFfRzBfcmVzdWx0W3BvcyArIDFdID0gbmV4dENoO1xuICAgICAgICAgICAgQTFfRzFfcmVzdWx0W3BvcyArIDFdID0gbmV4dENoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgQTBfRzA6IEEwX0cwX3Jlc3VsdC5qb2luKFwiXCIpLFxuICAgICAgQTBfRzE6IEEwX0cxX3Jlc3VsdC5qb2luKFwiXCIpLFxuICAgICAgQTFfRzA6IEExX0cwX3Jlc3VsdC5qb2luKFwiXCIpLFxuICAgICAgQTFfRzE6IEExX0cxX3Jlc3VsdC5qb2luKFwiXCIpXG4gICAgfTtcbiAgfVxuICByZXNvbHZlQW5jaG9ycyhhbGxvd0EsIGFsbG93Rykge1xuICAgIGlmICghdGhpcy5oYXNBbmNob3IgfHwgIXRoaXMuX2FuY2hvckNhY2hlIHx8IHR5cGVvZiB0aGlzLnNvdXJjZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dBKSB7XG4gICAgICBpZiAoYWxsb3dHKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JDYWNoZS5BMV9HMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JDYWNoZS5BMV9HMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGFsbG93Rykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzA7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIFJlZ0V4cFNvdXJjZUxpc3QgPSBjbGFzcyB7XG4gIF9pdGVtcztcbiAgX2hhc0FuY2hvcnM7XG4gIF9jYWNoZWQ7XG4gIF9hbmNob3JDYWNoZTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICB0aGlzLl9oYXNBbmNob3JzID0gZmFsc2U7XG4gICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcbiAgICB0aGlzLl9hbmNob3JDYWNoZSA9IHtcbiAgICAgIEEwX0cwOiBudWxsLFxuICAgICAgQTBfRzE6IG51bGwsXG4gICAgICBBMV9HMDogbnVsbCxcbiAgICAgIEExX0cxOiBudWxsXG4gICAgfTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2Rpc3Bvc2VDYWNoZXMoKTtcbiAgfVxuICBfZGlzcG9zZUNhY2hlcygpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkKSB7XG4gICAgICB0aGlzLl9jYWNoZWQuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2FuY2hvckNhY2hlLkEwX0cwKSB7XG4gICAgICB0aGlzLl9hbmNob3JDYWNoZS5BMF9HMC5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9hbmNob3JDYWNoZS5BMF9HMCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLl9hbmNob3JDYWNoZS5BMF9HMSkge1xuICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzEuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzEgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYW5jaG9yQ2FjaGUuQTFfRzApIHtcbiAgICAgIHRoaXMuX2FuY2hvckNhY2hlLkExX0cwLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2FuY2hvckNhY2hlLkExX0cwID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2FuY2hvckNhY2hlLkExX0cxKSB7XG4gICAgICB0aGlzLl9hbmNob3JDYWNoZS5BMV9HMS5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9hbmNob3JDYWNoZS5BMV9HMSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHB1c2goaXRlbSkge1xuICAgIHRoaXMuX2l0ZW1zLnB1c2goaXRlbSk7XG4gICAgdGhpcy5faGFzQW5jaG9ycyA9IHRoaXMuX2hhc0FuY2hvcnMgfHwgaXRlbS5oYXNBbmNob3I7XG4gIH1cbiAgdW5zaGlmdChpdGVtKSB7XG4gICAgdGhpcy5faXRlbXMudW5zaGlmdChpdGVtKTtcbiAgICB0aGlzLl9oYXNBbmNob3JzID0gdGhpcy5faGFzQW5jaG9ycyB8fCBpdGVtLmhhc0FuY2hvcjtcbiAgfVxuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmxlbmd0aDtcbiAgfVxuICBzZXRTb3VyY2UoaW5kZXgsIG5ld1NvdXJjZSkge1xuICAgIGlmICh0aGlzLl9pdGVtc1tpbmRleF0uc291cmNlICE9PSBuZXdTb3VyY2UpIHtcbiAgICAgIHRoaXMuX2Rpc3Bvc2VDYWNoZXMoKTtcbiAgICAgIHRoaXMuX2l0ZW1zW2luZGV4XS5zZXRTb3VyY2UobmV3U291cmNlKTtcbiAgICB9XG4gIH1cbiAgY29tcGlsZShvbmlnTGliKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZWQpIHtcbiAgICAgIGxldCByZWdFeHBzID0gdGhpcy5faXRlbXMubWFwKChlKSA9PiBlLnNvdXJjZSk7XG4gICAgICB0aGlzLl9jYWNoZWQgPSBuZXcgQ29tcGlsZWRSdWxlKG9uaWdMaWIsIHJlZ0V4cHMsIHRoaXMuX2l0ZW1zLm1hcCgoZSkgPT4gZS5ydWxlSWQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZDtcbiAgfVxuICBjb21waWxlQUcob25pZ0xpYiwgYWxsb3dBLCBhbGxvd0cpIHtcbiAgICBpZiAoIXRoaXMuX2hhc0FuY2hvcnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGUob25pZ0xpYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhbGxvd0EpIHtcbiAgICAgICAgaWYgKGFsbG93Rykge1xuICAgICAgICAgIGlmICghdGhpcy5fYW5jaG9yQ2FjaGUuQTFfRzEpIHtcbiAgICAgICAgICAgIHRoaXMuX2FuY2hvckNhY2hlLkExX0cxID0gdGhpcy5fcmVzb2x2ZUFuY2hvcnMob25pZ0xpYiwgYWxsb3dBLCBhbGxvd0cpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yQ2FjaGUuQTFfRzE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9hbmNob3JDYWNoZS5BMV9HMCkge1xuICAgICAgICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUuQTFfRzAgPSB0aGlzLl9yZXNvbHZlQW5jaG9ycyhvbmlnTGliLCBhbGxvd0EsIGFsbG93Ryk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JDYWNoZS5BMV9HMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFsbG93Rykge1xuICAgICAgICAgIGlmICghdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzEpIHtcbiAgICAgICAgICAgIHRoaXMuX2FuY2hvckNhY2hlLkEwX0cxID0gdGhpcy5fcmVzb2x2ZUFuY2hvcnMob25pZ0xpYiwgYWxsb3dBLCBhbGxvd0cpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9hbmNob3JDYWNoZS5BMF9HMCkge1xuICAgICAgICAgICAgdGhpcy5fYW5jaG9yQ2FjaGUuQTBfRzAgPSB0aGlzLl9yZXNvbHZlQW5jaG9ycyhvbmlnTGliLCBhbGxvd0EsIGFsbG93Ryk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9hbmNob3JDYWNoZS5BMF9HMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfcmVzb2x2ZUFuY2hvcnMob25pZ0xpYiwgYWxsb3dBLCBhbGxvd0cpIHtcbiAgICBsZXQgcmVnRXhwcyA9IHRoaXMuX2l0ZW1zLm1hcCgoZSkgPT4gZS5yZXNvbHZlQW5jaG9ycyhhbGxvd0EsIGFsbG93RykpO1xuICAgIHJldHVybiBuZXcgQ29tcGlsZWRSdWxlKG9uaWdMaWIsIHJlZ0V4cHMsIHRoaXMuX2l0ZW1zLm1hcCgoZSkgPT4gZS5ydWxlSWQpKTtcbiAgfVxufTtcbnZhciBDb21waWxlZFJ1bGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9uaWdMaWIsIHJlZ0V4cHMsIHJ1bGVzKSB7XG4gICAgdGhpcy5yZWdFeHBzID0gcmVnRXhwcztcbiAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgdGhpcy5zY2FubmVyID0gb25pZ0xpYi5jcmVhdGVPbmlnU2Nhbm5lcihyZWdFeHBzKTtcbiAgfVxuICBzY2FubmVyO1xuICBkaXNwb3NlKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zY2FubmVyLmRpc3Bvc2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy5zY2FubmVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLnJ1bGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByLnB1c2goXCIgICAtIFwiICsgdGhpcy5ydWxlc1tpXSArIFwiOiBcIiArIHRoaXMucmVnRXhwc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgZmluZE5leHRNYXRjaFN5bmMoc3RyaW5nLCBzdGFydFBvc2l0aW9uLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zY2FubmVyLmZpbmROZXh0TWF0Y2hTeW5jKHN0cmluZywgc3RhcnRQb3NpdGlvbiwgb3B0aW9ucyk7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcnVsZUlkOiB0aGlzLnJ1bGVzW3Jlc3VsdC5pbmRleF0sXG4gICAgICBjYXB0dXJlSW5kaWNlczogcmVzdWx0LmNhcHR1cmVJbmRpY2VzXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL2dyYW1tYXIvYmFzaWNTY29wZXNBdHRyaWJ1dGVQcm92aWRlci50c1xudmFyIEJhc2ljU2NvcGVBdHRyaWJ1dGVzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihsYW5ndWFnZUlkLCB0b2tlblR5cGUpIHtcbiAgICB0aGlzLmxhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgIHRoaXMudG9rZW5UeXBlID0gdG9rZW5UeXBlO1xuICB9XG59O1xudmFyIEJhc2ljU2NvcGVBdHRyaWJ1dGVzUHJvdmlkZXIgPSBjbGFzcyBfQmFzaWNTY29wZUF0dHJpYnV0ZXNQcm92aWRlciB7XG4gIF9kZWZhdWx0QXR0cmlidXRlcztcbiAgX2VtYmVkZGVkTGFuZ3VhZ2VzTWF0Y2hlcjtcbiAgY29uc3RydWN0b3IoaW5pdGlhbExhbmd1YWdlSWQsIGVtYmVkZGVkTGFuZ3VhZ2VzKSB7XG4gICAgdGhpcy5fZGVmYXVsdEF0dHJpYnV0ZXMgPSBuZXcgQmFzaWNTY29wZUF0dHJpYnV0ZXMoaW5pdGlhbExhbmd1YWdlSWQsIDggLyogTm90U2V0ICovKTtcbiAgICB0aGlzLl9lbWJlZGRlZExhbmd1YWdlc01hdGNoZXIgPSBuZXcgU2NvcGVNYXRjaGVyKE9iamVjdC5lbnRyaWVzKGVtYmVkZGVkTGFuZ3VhZ2VzIHx8IHt9KSk7XG4gIH1cbiAgZ2V0RGVmYXVsdEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRBdHRyaWJ1dGVzO1xuICB9XG4gIGdldEJhc2ljU2NvcGVBdHRyaWJ1dGVzKHNjb3BlTmFtZSkge1xuICAgIGlmIChzY29wZU5hbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBfQmFzaWNTY29wZUF0dHJpYnV0ZXNQcm92aWRlci5fTlVMTF9TQ09QRV9NRVRBREFUQTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dldEJhc2ljU2NvcGVBdHRyaWJ1dGVzLmdldChzY29wZU5hbWUpO1xuICB9XG4gIHN0YXRpYyBfTlVMTF9TQ09QRV9NRVRBREFUQSA9IG5ldyBCYXNpY1Njb3BlQXR0cmlidXRlcygwLCAwKTtcbiAgX2dldEJhc2ljU2NvcGVBdHRyaWJ1dGVzID0gbmV3IENhY2hlZEZuKChzY29wZU5hbWUpID0+IHtcbiAgICBjb25zdCBsYW5ndWFnZUlkID0gdGhpcy5fc2NvcGVUb0xhbmd1YWdlKHNjb3BlTmFtZSk7XG4gICAgY29uc3Qgc3RhbmRhcmRUb2tlblR5cGUgPSB0aGlzLl90b1N0YW5kYXJkVG9rZW5UeXBlKHNjb3BlTmFtZSk7XG4gICAgcmV0dXJuIG5ldyBCYXNpY1Njb3BlQXR0cmlidXRlcyhsYW5ndWFnZUlkLCBzdGFuZGFyZFRva2VuVHlwZSk7XG4gIH0pO1xuICAvKipcbiAgICogR2l2ZW4gYSBwcm9kdWNlZCBUTSBzY29wZSwgcmV0dXJuIHRoZSBsYW5ndWFnZSB0aGF0IHRva2VuIGRlc2NyaWJlcyBvciBudWxsIGlmIHVua25vd24uXG4gICAqIGUuZy4gc291cmNlLmh0bWwgPT4gaHRtbCwgc291cmNlLmNzcy5lbWJlZGRlZC5odG1sID0+IGNzcywgcHVuY3R1YXRpb24uZGVmaW5pdGlvbi50YWcuaHRtbCA9PiBudWxsXG4gICAqL1xuICBfc2NvcGVUb0xhbmd1YWdlKHNjb3BlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtYmVkZGVkTGFuZ3VhZ2VzTWF0Y2hlci5tYXRjaChzY29wZSkgfHwgMDtcbiAgfVxuICBfdG9TdGFuZGFyZFRva2VuVHlwZShzY29wZU5hbWUpIHtcbiAgICBjb25zdCBtID0gc2NvcGVOYW1lLm1hdGNoKF9CYXNpY1Njb3BlQXR0cmlidXRlc1Byb3ZpZGVyLlNUQU5EQVJEX1RPS0VOX1RZUEVfUkVHRVhQKTtcbiAgICBpZiAoIW0pIHtcbiAgICAgIHJldHVybiA4IC8qIE5vdFNldCAqLztcbiAgICB9XG4gICAgc3dpdGNoIChtWzFdKSB7XG4gICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICByZXR1cm4gMSAvKiBDb21tZW50ICovO1xuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICByZXR1cm4gMiAvKiBTdHJpbmcgKi87XG4gICAgICBjYXNlIFwicmVnZXhcIjpcbiAgICAgICAgcmV0dXJuIDMgLyogUmVnRXggKi87XG4gICAgICBjYXNlIFwibWV0YS5lbWJlZGRlZFwiOlxuICAgICAgICByZXR1cm4gMCAvKiBPdGhlciAqLztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtYXRjaCBmb3Igc3RhbmRhcmQgdG9rZW4gdHlwZSFcIik7XG4gIH1cbiAgc3RhdGljIFNUQU5EQVJEX1RPS0VOX1RZUEVfUkVHRVhQID0gL1xcYihjb21tZW50fHN0cmluZ3xyZWdleHxtZXRhXFwuZW1iZWRkZWQpXFxiLztcbn07XG52YXIgU2NvcGVNYXRjaGVyID0gY2xhc3Mge1xuICB2YWx1ZXM7XG4gIHNjb3Blc1JlZ0V4cDtcbiAgY29uc3RydWN0b3IodmFsdWVzKSB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMudmFsdWVzID0gbnVsbDtcbiAgICAgIHRoaXMuc2NvcGVzUmVnRXhwID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgTWFwKHZhbHVlcyk7XG4gICAgICBjb25zdCBlc2NhcGVkU2NvcGVzID0gdmFsdWVzLm1hcChcbiAgICAgICAgKFtzY29wZU5hbWUsIHZhbHVlXSkgPT4gZXNjYXBlUmVnRXhwQ2hhcmFjdGVycyhzY29wZU5hbWUpXG4gICAgICApO1xuICAgICAgZXNjYXBlZFNjb3Blcy5zb3J0KCk7XG4gICAgICBlc2NhcGVkU2NvcGVzLnJldmVyc2UoKTtcbiAgICAgIHRoaXMuc2NvcGVzUmVnRXhwID0gbmV3IFJlZ0V4cChcbiAgICAgICAgYF4oKCR7ZXNjYXBlZFNjb3Blcy5qb2luKFwiKXwoXCIpfSkpKCR8XFxcXC4pYCxcbiAgICAgICAgXCJcIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgbWF0Y2goc2NvcGUpIHtcbiAgICBpZiAoIXRoaXMuc2NvcGVzUmVnRXhwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCBtID0gc2NvcGUubWF0Y2godGhpcy5zY29wZXNSZWdFeHApO1xuICAgIGlmICghbSkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzLmdldChtWzFdKTtcbiAgfVxufTtcblxuLy8gc3JjL2RlYnVnLnRzXG52YXIgRGVidWdGbGFncyA9IHtcbiAgSW5EZWJ1Z01vZGU6IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmICEhcHJvY2Vzcy5lbnZbXCJWU0NPREVfVEVYVE1BVEVfREVCVUdcIl1cbn07XG52YXIgVXNlT25pZ3VydW1hRmluZE9wdGlvbnMgPSBmYWxzZTtcblxuLy8gc3JjL2dyYW1tYXIvdG9rZW5pemVTdHJpbmcudHNcbnZhciBUb2tlbml6ZVN0cmluZ1Jlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc3RhY2ssIHN0b3BwZWRFYXJseSkge1xuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLnN0b3BwZWRFYXJseSA9IHN0b3BwZWRFYXJseTtcbiAgfVxufTtcbmZ1bmN0aW9uIF90b2tlbml6ZVN0cmluZyhncmFtbWFyLCBsaW5lVGV4dCwgaXNGaXJzdExpbmUsIGxpbmVQb3MsIHN0YWNrLCBsaW5lVG9rZW5zLCBjaGVja1doaWxlQ29uZGl0aW9ucywgdGltZUxpbWl0KSB7XG4gIGNvbnN0IGxpbmVMZW5ndGggPSBsaW5lVGV4dC5jb250ZW50Lmxlbmd0aDtcbiAgbGV0IFNUT1AgPSBmYWxzZTtcbiAgbGV0IGFuY2hvclBvc2l0aW9uID0gLTE7XG4gIGlmIChjaGVja1doaWxlQ29uZGl0aW9ucykge1xuICAgIGNvbnN0IHdoaWxlQ2hlY2tSZXN1bHQgPSBfY2hlY2tXaGlsZUNvbmRpdGlvbnMoXG4gICAgICBncmFtbWFyLFxuICAgICAgbGluZVRleHQsXG4gICAgICBpc0ZpcnN0TGluZSxcbiAgICAgIGxpbmVQb3MsXG4gICAgICBzdGFjayxcbiAgICAgIGxpbmVUb2tlbnNcbiAgICApO1xuICAgIHN0YWNrID0gd2hpbGVDaGVja1Jlc3VsdC5zdGFjaztcbiAgICBsaW5lUG9zID0gd2hpbGVDaGVja1Jlc3VsdC5saW5lUG9zO1xuICAgIGlzRmlyc3RMaW5lID0gd2hpbGVDaGVja1Jlc3VsdC5pc0ZpcnN0TGluZTtcbiAgICBhbmNob3JQb3NpdGlvbiA9IHdoaWxlQ2hlY2tSZXN1bHQuYW5jaG9yUG9zaXRpb247XG4gIH1cbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgd2hpbGUgKCFTVE9QKSB7XG4gICAgaWYgKHRpbWVMaW1pdCAhPT0gMCkge1xuICAgICAgY29uc3QgZWxhcHNlZFRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgICAgaWYgKGVsYXBzZWRUaW1lID4gdGltZUxpbWl0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW5pemVTdHJpbmdSZXN1bHQoc3RhY2ssIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBzY2FuTmV4dCgpO1xuICB9XG4gIHJldHVybiBuZXcgVG9rZW5pemVTdHJpbmdSZXN1bHQoc3RhY2ssIGZhbHNlKTtcbiAgZnVuY3Rpb24gc2Nhbk5leHQoKSB7XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlwiKTtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBgQEBzY2FuTmV4dCAke2xpbmVQb3N9OiB8JHtsaW5lVGV4dC5jb250ZW50LnN1YnN0cihsaW5lUG9zKS5yZXBsYWNlKC9cXG4kLywgXCJcXFxcblwiKX18YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgciA9IG1hdGNoUnVsZU9ySW5qZWN0aW9ucyhcbiAgICAgIGdyYW1tYXIsXG4gICAgICBsaW5lVGV4dCxcbiAgICAgIGlzRmlyc3RMaW5lLFxuICAgICAgbGluZVBvcyxcbiAgICAgIHN0YWNrLFxuICAgICAgYW5jaG9yUG9zaXRpb25cbiAgICApO1xuICAgIGlmICghcikge1xuICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHN0YWNrLCBsaW5lTGVuZ3RoKTtcbiAgICAgIFNUT1AgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjYXB0dXJlSW5kaWNlcyA9IHIuY2FwdHVyZUluZGljZXM7XG4gICAgY29uc3QgbWF0Y2hlZFJ1bGVJZCA9IHIubWF0Y2hlZFJ1bGVJZDtcbiAgICBjb25zdCBoYXNBZHZhbmNlZCA9IGNhcHR1cmVJbmRpY2VzICYmIGNhcHR1cmVJbmRpY2VzLmxlbmd0aCA+IDAgPyBjYXB0dXJlSW5kaWNlc1swXS5lbmQgPiBsaW5lUG9zIDogZmFsc2U7XG4gICAgaWYgKG1hdGNoZWRSdWxlSWQgPT09IGVuZFJ1bGVJZCkge1xuICAgICAgY29uc3QgcG9wcGVkUnVsZSA9IHN0YWNrLmdldFJ1bGUoZ3JhbW1hcik7XG4gICAgICBpZiAoZmFsc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgXCIgIHBvcHBpbmcgXCIgKyBwb3BwZWRSdWxlLmRlYnVnTmFtZSArIFwiIC0gXCIgKyBwb3BwZWRSdWxlLmRlYnVnRW5kUmVnRXhwXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uoc3RhY2ssIGNhcHR1cmVJbmRpY2VzWzBdLnN0YXJ0KTtcbiAgICAgIHN0YWNrID0gc3RhY2sud2l0aENvbnRlbnROYW1lU2NvcGVzTGlzdChzdGFjay5uYW1lU2NvcGVzTGlzdCk7XG4gICAgICBoYW5kbGVDYXB0dXJlcyhcbiAgICAgICAgZ3JhbW1hcixcbiAgICAgICAgbGluZVRleHQsXG4gICAgICAgIGlzRmlyc3RMaW5lLFxuICAgICAgICBzdGFjayxcbiAgICAgICAgbGluZVRva2VucyxcbiAgICAgICAgcG9wcGVkUnVsZS5lbmRDYXB0dXJlcyxcbiAgICAgICAgY2FwdHVyZUluZGljZXNcbiAgICAgICk7XG4gICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uoc3RhY2ssIGNhcHR1cmVJbmRpY2VzWzBdLmVuZCk7XG4gICAgICBjb25zdCBwb3BwZWQgPSBzdGFjaztcbiAgICAgIHN0YWNrID0gc3RhY2sucGFyZW50O1xuICAgICAgYW5jaG9yUG9zaXRpb24gPSBwb3BwZWQuZ2V0QW5jaG9yUG9zKCk7XG4gICAgICBpZiAoIWhhc0FkdmFuY2VkICYmIHBvcHBlZC5nZXRFbnRlclBvcygpID09PSBsaW5lUG9zKSB7XG4gICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBcIlsxXSAtIEdyYW1tYXIgaXMgaW4gYW4gZW5kbGVzcyBsb29wIC0gR3JhbW1hciBwdXNoZWQgJiBwb3BwZWQgYSBydWxlIHdpdGhvdXQgYWR2YW5jaW5nXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrID0gcG9wcGVkO1xuICAgICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uoc3RhY2ssIGxpbmVMZW5ndGgpO1xuICAgICAgICBTVE9QID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBfcnVsZSA9IGdyYW1tYXIuZ2V0UnVsZShtYXRjaGVkUnVsZUlkKTtcbiAgICAgIGxpbmVUb2tlbnMucHJvZHVjZShzdGFjaywgY2FwdHVyZUluZGljZXNbMF0uc3RhcnQpO1xuICAgICAgY29uc3QgYmVmb3JlUHVzaCA9IHN0YWNrO1xuICAgICAgY29uc3Qgc2NvcGVOYW1lID0gX3J1bGUuZ2V0TmFtZShsaW5lVGV4dC5jb250ZW50LCBjYXB0dXJlSW5kaWNlcyk7XG4gICAgICBjb25zdCBuYW1lU2NvcGVzTGlzdCA9IHN0YWNrLmNvbnRlbnROYW1lU2NvcGVzTGlzdC5wdXNoQXR0cmlidXRlZChcbiAgICAgICAgc2NvcGVOYW1lLFxuICAgICAgICBncmFtbWFyXG4gICAgICApO1xuICAgICAgc3RhY2sgPSBzdGFjay5wdXNoKFxuICAgICAgICBtYXRjaGVkUnVsZUlkLFxuICAgICAgICBsaW5lUG9zLFxuICAgICAgICBhbmNob3JQb3NpdGlvbixcbiAgICAgICAgY2FwdHVyZUluZGljZXNbMF0uZW5kID09PSBsaW5lTGVuZ3RoLFxuICAgICAgICBudWxsLFxuICAgICAgICBuYW1lU2NvcGVzTGlzdCxcbiAgICAgICAgbmFtZVNjb3Blc0xpc3RcbiAgICAgICk7XG4gICAgICBpZiAoX3J1bGUgaW5zdGFuY2VvZiBCZWdpbkVuZFJ1bGUpIHtcbiAgICAgICAgY29uc3QgcHVzaGVkUnVsZSA9IF9ydWxlO1xuICAgICAgICBpZiAoZmFsc2UpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIFwiICBwdXNoaW5nIFwiICsgcHVzaGVkUnVsZS5kZWJ1Z05hbWUgKyBcIiAtIFwiICsgcHVzaGVkUnVsZS5kZWJ1Z0JlZ2luUmVnRXhwXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVDYXB0dXJlcyhcbiAgICAgICAgICBncmFtbWFyLFxuICAgICAgICAgIGxpbmVUZXh0LFxuICAgICAgICAgIGlzRmlyc3RMaW5lLFxuICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgIGxpbmVUb2tlbnMsXG4gICAgICAgICAgcHVzaGVkUnVsZS5iZWdpbkNhcHR1cmVzLFxuICAgICAgICAgIGNhcHR1cmVJbmRpY2VzXG4gICAgICAgICk7XG4gICAgICAgIGxpbmVUb2tlbnMucHJvZHVjZShzdGFjaywgY2FwdHVyZUluZGljZXNbMF0uZW5kKTtcbiAgICAgICAgYW5jaG9yUG9zaXRpb24gPSBjYXB0dXJlSW5kaWNlc1swXS5lbmQ7XG4gICAgICAgIGNvbnN0IGNvbnRlbnROYW1lID0gcHVzaGVkUnVsZS5nZXRDb250ZW50TmFtZShcbiAgICAgICAgICBsaW5lVGV4dC5jb250ZW50LFxuICAgICAgICAgIGNhcHR1cmVJbmRpY2VzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnROYW1lU2NvcGVzTGlzdCA9IG5hbWVTY29wZXNMaXN0LnB1c2hBdHRyaWJ1dGVkKFxuICAgICAgICAgIGNvbnRlbnROYW1lLFxuICAgICAgICAgIGdyYW1tYXJcbiAgICAgICAgKTtcbiAgICAgICAgc3RhY2sgPSBzdGFjay53aXRoQ29udGVudE5hbWVTY29wZXNMaXN0KGNvbnRlbnROYW1lU2NvcGVzTGlzdCk7XG4gICAgICAgIGlmIChwdXNoZWRSdWxlLmVuZEhhc0JhY2tSZWZlcmVuY2VzKSB7XG4gICAgICAgICAgc3RhY2sgPSBzdGFjay53aXRoRW5kUnVsZShcbiAgICAgICAgICAgIHB1c2hlZFJ1bGUuZ2V0RW5kV2l0aFJlc29sdmVkQmFja1JlZmVyZW5jZXMoXG4gICAgICAgICAgICAgIGxpbmVUZXh0LmNvbnRlbnQsXG4gICAgICAgICAgICAgIGNhcHR1cmVJbmRpY2VzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0FkdmFuY2VkICYmIGJlZm9yZVB1c2guaGFzU2FtZVJ1bGVBcyhzdGFjaykpIHtcbiAgICAgICAgICBpZiAoZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiWzJdIC0gR3JhbW1hciBpcyBpbiBhbiBlbmRsZXNzIGxvb3AgLSBHcmFtbWFyIHB1c2hlZCB0aGUgc2FtZSBydWxlIHdpdGhvdXQgYWR2YW5jaW5nXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YWNrID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHN0YWNrLCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICBTVE9QID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX3J1bGUgaW5zdGFuY2VvZiBCZWdpbldoaWxlUnVsZSkge1xuICAgICAgICBjb25zdCBwdXNoZWRSdWxlID0gX3J1bGU7XG4gICAgICAgIGlmIChmYWxzZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiICBwdXNoaW5nIFwiICsgcHVzaGVkUnVsZS5kZWJ1Z05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZUNhcHR1cmVzKFxuICAgICAgICAgIGdyYW1tYXIsXG4gICAgICAgICAgbGluZVRleHQsXG4gICAgICAgICAgaXNGaXJzdExpbmUsXG4gICAgICAgICAgc3RhY2ssXG4gICAgICAgICAgbGluZVRva2VucyxcbiAgICAgICAgICBwdXNoZWRSdWxlLmJlZ2luQ2FwdHVyZXMsXG4gICAgICAgICAgY2FwdHVyZUluZGljZXNcbiAgICAgICAgKTtcbiAgICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHN0YWNrLCBjYXB0dXJlSW5kaWNlc1swXS5lbmQpO1xuICAgICAgICBhbmNob3JQb3NpdGlvbiA9IGNhcHR1cmVJbmRpY2VzWzBdLmVuZDtcbiAgICAgICAgY29uc3QgY29udGVudE5hbWUgPSBwdXNoZWRSdWxlLmdldENvbnRlbnROYW1lKFxuICAgICAgICAgIGxpbmVUZXh0LmNvbnRlbnQsXG4gICAgICAgICAgY2FwdHVyZUluZGljZXNcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY29udGVudE5hbWVTY29wZXNMaXN0ID0gbmFtZVNjb3Blc0xpc3QucHVzaEF0dHJpYnV0ZWQoXG4gICAgICAgICAgY29udGVudE5hbWUsXG4gICAgICAgICAgZ3JhbW1hclxuICAgICAgICApO1xuICAgICAgICBzdGFjayA9IHN0YWNrLndpdGhDb250ZW50TmFtZVNjb3Blc0xpc3QoY29udGVudE5hbWVTY29wZXNMaXN0KTtcbiAgICAgICAgaWYgKHB1c2hlZFJ1bGUud2hpbGVIYXNCYWNrUmVmZXJlbmNlcykge1xuICAgICAgICAgIHN0YWNrID0gc3RhY2sud2l0aEVuZFJ1bGUoXG4gICAgICAgICAgICBwdXNoZWRSdWxlLmdldFdoaWxlV2l0aFJlc29sdmVkQmFja1JlZmVyZW5jZXMoXG4gICAgICAgICAgICAgIGxpbmVUZXh0LmNvbnRlbnQsXG4gICAgICAgICAgICAgIGNhcHR1cmVJbmRpY2VzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0FkdmFuY2VkICYmIGJlZm9yZVB1c2guaGFzU2FtZVJ1bGVBcyhzdGFjaykpIHtcbiAgICAgICAgICBpZiAoZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiWzNdIC0gR3JhbW1hciBpcyBpbiBhbiBlbmRsZXNzIGxvb3AgLSBHcmFtbWFyIHB1c2hlZCB0aGUgc2FtZSBydWxlIHdpdGhvdXQgYWR2YW5jaW5nXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YWNrID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHN0YWNrLCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICBTVE9QID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1hdGNoaW5nUnVsZSA9IF9ydWxlO1xuICAgICAgICBpZiAoZmFsc2UpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIFwiICBtYXRjaGVkIFwiICsgbWF0Y2hpbmdSdWxlLmRlYnVnTmFtZSArIFwiIC0gXCIgKyBtYXRjaGluZ1J1bGUuZGVidWdNYXRjaFJlZ0V4cFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlQ2FwdHVyZXMoXG4gICAgICAgICAgZ3JhbW1hcixcbiAgICAgICAgICBsaW5lVGV4dCxcbiAgICAgICAgICBpc0ZpcnN0TGluZSxcbiAgICAgICAgICBzdGFjayxcbiAgICAgICAgICBsaW5lVG9rZW5zLFxuICAgICAgICAgIG1hdGNoaW5nUnVsZS5jYXB0dXJlcyxcbiAgICAgICAgICBjYXB0dXJlSW5kaWNlc1xuICAgICAgICApO1xuICAgICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uoc3RhY2ssIGNhcHR1cmVJbmRpY2VzWzBdLmVuZCk7XG4gICAgICAgIHN0YWNrID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGlmICghaGFzQWR2YW5jZWQpIHtcbiAgICAgICAgICBpZiAoZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiWzRdIC0gR3JhbW1hciBpcyBpbiBhbiBlbmRsZXNzIGxvb3AgLSBHcmFtbWFyIGlzIG5vdCBhZHZhbmNpbmcsIG5vciBpcyBpdCBwdXNoaW5nL3BvcHBpbmdcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhY2sgPSBzdGFjay5zYWZlUG9wKCk7XG4gICAgICAgICAgbGluZVRva2Vucy5wcm9kdWNlKHN0YWNrLCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICBTVE9QID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNhcHR1cmVJbmRpY2VzWzBdLmVuZCA+IGxpbmVQb3MpIHtcbiAgICAgIGxpbmVQb3MgPSBjYXB0dXJlSW5kaWNlc1swXS5lbmQ7XG4gICAgICBpc0ZpcnN0TGluZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX2NoZWNrV2hpbGVDb25kaXRpb25zKGdyYW1tYXIsIGxpbmVUZXh0LCBpc0ZpcnN0TGluZSwgbGluZVBvcywgc3RhY2ssIGxpbmVUb2tlbnMpIHtcbiAgbGV0IGFuY2hvclBvc2l0aW9uID0gc3RhY2suYmVnaW5SdWxlQ2FwdHVyZWRFT0wgPyAwIDogLTE7XG4gIGNvbnN0IHdoaWxlUnVsZXMgPSBbXTtcbiAgZm9yIChsZXQgbm9kZSA9IHN0YWNrOyBub2RlOyBub2RlID0gbm9kZS5wb3AoKSkge1xuICAgIGNvbnN0IG5vZGVSdWxlID0gbm9kZS5nZXRSdWxlKGdyYW1tYXIpO1xuICAgIGlmIChub2RlUnVsZSBpbnN0YW5jZW9mIEJlZ2luV2hpbGVSdWxlKSB7XG4gICAgICB3aGlsZVJ1bGVzLnB1c2goe1xuICAgICAgICBydWxlOiBub2RlUnVsZSxcbiAgICAgICAgc3RhY2s6IG5vZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCB3aGlsZVJ1bGUgPSB3aGlsZVJ1bGVzLnBvcCgpOyB3aGlsZVJ1bGU7IHdoaWxlUnVsZSA9IHdoaWxlUnVsZXMucG9wKCkpIHtcbiAgICBjb25zdCB7IHJ1bGVTY2FubmVyLCBmaW5kT3B0aW9ucyB9ID0gcHJlcGFyZVJ1bGVXaGlsZVNlYXJjaCh3aGlsZVJ1bGUucnVsZSwgZ3JhbW1hciwgd2hpbGVSdWxlLnN0YWNrLmVuZFJ1bGUsIGlzRmlyc3RMaW5lLCBsaW5lUG9zID09PSBhbmNob3JQb3NpdGlvbik7XG4gICAgY29uc3QgciA9IHJ1bGVTY2FubmVyLmZpbmROZXh0TWF0Y2hTeW5jKGxpbmVUZXh0LCBsaW5lUG9zLCBmaW5kT3B0aW9ucyk7XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIiAgc2Nhbm5pbmcgZm9yIHdoaWxlIHJ1bGVcIik7XG4gICAgICBjb25zb2xlLmxvZyhydWxlU2Nhbm5lci50b1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKHIpIHtcbiAgICAgIGNvbnN0IG1hdGNoZWRSdWxlSWQgPSByLnJ1bGVJZDtcbiAgICAgIGlmIChtYXRjaGVkUnVsZUlkICE9PSB3aGlsZVJ1bGVJZCkge1xuICAgICAgICBzdGFjayA9IHdoaWxlUnVsZS5zdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoci5jYXB0dXJlSW5kaWNlcyAmJiByLmNhcHR1cmVJbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uod2hpbGVSdWxlLnN0YWNrLCByLmNhcHR1cmVJbmRpY2VzWzBdLnN0YXJ0KTtcbiAgICAgICAgaGFuZGxlQ2FwdHVyZXMoZ3JhbW1hciwgbGluZVRleHQsIGlzRmlyc3RMaW5lLCB3aGlsZVJ1bGUuc3RhY2ssIGxpbmVUb2tlbnMsIHdoaWxlUnVsZS5ydWxlLndoaWxlQ2FwdHVyZXMsIHIuY2FwdHVyZUluZGljZXMpO1xuICAgICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uod2hpbGVSdWxlLnN0YWNrLCByLmNhcHR1cmVJbmRpY2VzWzBdLmVuZCk7XG4gICAgICAgIGFuY2hvclBvc2l0aW9uID0gci5jYXB0dXJlSW5kaWNlc1swXS5lbmQ7XG4gICAgICAgIGlmIChyLmNhcHR1cmVJbmRpY2VzWzBdLmVuZCA+IGxpbmVQb3MpIHtcbiAgICAgICAgICBsaW5lUG9zID0gci5jYXB0dXJlSW5kaWNlc1swXS5lbmQ7XG4gICAgICAgICAgaXNGaXJzdExpbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmFsc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCIgIHBvcHBpbmcgXCIgKyB3aGlsZVJ1bGUucnVsZS5kZWJ1Z05hbWUgKyBcIiAtIFwiICsgd2hpbGVSdWxlLnJ1bGUuZGVidWdXaGlsZVJlZ0V4cCk7XG4gICAgICB9XG4gICAgICBzdGFjayA9IHdoaWxlUnVsZS5zdGFjay5wb3AoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBzdGFjaywgbGluZVBvcywgYW5jaG9yUG9zaXRpb24sIGlzRmlyc3RMaW5lIH07XG59XG5mdW5jdGlvbiBtYXRjaFJ1bGVPckluamVjdGlvbnMoZ3JhbW1hciwgbGluZVRleHQsIGlzRmlyc3RMaW5lLCBsaW5lUG9zLCBzdGFjaywgYW5jaG9yUG9zaXRpb24pIHtcbiAgY29uc3QgbWF0Y2hSZXN1bHQgPSBtYXRjaFJ1bGUoZ3JhbW1hciwgbGluZVRleHQsIGlzRmlyc3RMaW5lLCBsaW5lUG9zLCBzdGFjaywgYW5jaG9yUG9zaXRpb24pO1xuICBjb25zdCBpbmplY3Rpb25zID0gZ3JhbW1hci5nZXRJbmplY3Rpb25zKCk7XG4gIGlmIChpbmplY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBtYXRjaFJlc3VsdDtcbiAgfVxuICBjb25zdCBpbmplY3Rpb25SZXN1bHQgPSBtYXRjaEluamVjdGlvbnMoaW5qZWN0aW9ucywgZ3JhbW1hciwgbGluZVRleHQsIGlzRmlyc3RMaW5lLCBsaW5lUG9zLCBzdGFjaywgYW5jaG9yUG9zaXRpb24pO1xuICBpZiAoIWluamVjdGlvblJlc3VsdCkge1xuICAgIHJldHVybiBtYXRjaFJlc3VsdDtcbiAgfVxuICBpZiAoIW1hdGNoUmVzdWx0KSB7XG4gICAgcmV0dXJuIGluamVjdGlvblJlc3VsdDtcbiAgfVxuICBjb25zdCBtYXRjaFJlc3VsdFNjb3JlID0gbWF0Y2hSZXN1bHQuY2FwdHVyZUluZGljZXNbMF0uc3RhcnQ7XG4gIGNvbnN0IGluamVjdGlvblJlc3VsdFNjb3JlID0gaW5qZWN0aW9uUmVzdWx0LmNhcHR1cmVJbmRpY2VzWzBdLnN0YXJ0O1xuICBpZiAoaW5qZWN0aW9uUmVzdWx0U2NvcmUgPCBtYXRjaFJlc3VsdFNjb3JlIHx8IGluamVjdGlvblJlc3VsdC5wcmlvcml0eU1hdGNoICYmIGluamVjdGlvblJlc3VsdFNjb3JlID09PSBtYXRjaFJlc3VsdFNjb3JlKSB7XG4gICAgcmV0dXJuIGluamVjdGlvblJlc3VsdDtcbiAgfVxuICByZXR1cm4gbWF0Y2hSZXN1bHQ7XG59XG5mdW5jdGlvbiBtYXRjaFJ1bGUoZ3JhbW1hciwgbGluZVRleHQsIGlzRmlyc3RMaW5lLCBsaW5lUG9zLCBzdGFjaywgYW5jaG9yUG9zaXRpb24pIHtcbiAgY29uc3QgcnVsZSA9IHN0YWNrLmdldFJ1bGUoZ3JhbW1hcik7XG4gIGNvbnN0IHsgcnVsZVNjYW5uZXIsIGZpbmRPcHRpb25zIH0gPSBwcmVwYXJlUnVsZVNlYXJjaChydWxlLCBncmFtbWFyLCBzdGFjay5lbmRSdWxlLCBpc0ZpcnN0TGluZSwgbGluZVBvcyA9PT0gYW5jaG9yUG9zaXRpb24pO1xuICBjb25zdCByID0gcnVsZVNjYW5uZXIuZmluZE5leHRNYXRjaFN5bmMobGluZVRleHQsIGxpbmVQb3MsIGZpbmRPcHRpb25zKTtcbiAgaWYgKHIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2FwdHVyZUluZGljZXM6IHIuY2FwdHVyZUluZGljZXMsXG4gICAgICBtYXRjaGVkUnVsZUlkOiByLnJ1bGVJZFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtYXRjaEluamVjdGlvbnMoaW5qZWN0aW9ucywgZ3JhbW1hciwgbGluZVRleHQsIGlzRmlyc3RMaW5lLCBsaW5lUG9zLCBzdGFjaywgYW5jaG9yUG9zaXRpb24pIHtcbiAgbGV0IGJlc3RNYXRjaFJhdGluZyA9IE51bWJlci5NQVhfVkFMVUU7XG4gIGxldCBiZXN0TWF0Y2hDYXB0dXJlSW5kaWNlcyA9IG51bGw7XG4gIGxldCBiZXN0TWF0Y2hSdWxlSWQ7XG4gIGxldCBiZXN0TWF0Y2hSZXN1bHRQcmlvcml0eSA9IDA7XG4gIGNvbnN0IHNjb3BlcyA9IHN0YWNrLmNvbnRlbnROYW1lU2NvcGVzTGlzdC5nZXRTY29wZU5hbWVzKCk7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBpbmplY3Rpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgaW5qZWN0aW9uID0gaW5qZWN0aW9uc1tpXTtcbiAgICBpZiAoIWluamVjdGlvbi5tYXRjaGVyKHNjb3BlcykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBydWxlID0gZ3JhbW1hci5nZXRSdWxlKGluamVjdGlvbi5ydWxlSWQpO1xuICAgIGNvbnN0IHsgcnVsZVNjYW5uZXIsIGZpbmRPcHRpb25zIH0gPSBwcmVwYXJlUnVsZVNlYXJjaChydWxlLCBncmFtbWFyLCBudWxsLCBpc0ZpcnN0TGluZSwgbGluZVBvcyA9PT0gYW5jaG9yUG9zaXRpb24pO1xuICAgIGNvbnN0IG1hdGNoUmVzdWx0ID0gcnVsZVNjYW5uZXIuZmluZE5leHRNYXRjaFN5bmMobGluZVRleHQsIGxpbmVQb3MsIGZpbmRPcHRpb25zKTtcbiAgICBpZiAoIW1hdGNoUmVzdWx0KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICBjb25zb2xlLmxvZyhgICBtYXRjaGVkIGluamVjdGlvbjogJHtpbmplY3Rpb24uZGVidWdTZWxlY3Rvcn1gKTtcbiAgICAgIGNvbnNvbGUubG9nKHJ1bGVTY2FubmVyLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaFJhdGluZyA9IG1hdGNoUmVzdWx0LmNhcHR1cmVJbmRpY2VzWzBdLnN0YXJ0O1xuICAgIGlmIChtYXRjaFJhdGluZyA+PSBiZXN0TWF0Y2hSYXRpbmcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBiZXN0TWF0Y2hSYXRpbmcgPSBtYXRjaFJhdGluZztcbiAgICBiZXN0TWF0Y2hDYXB0dXJlSW5kaWNlcyA9IG1hdGNoUmVzdWx0LmNhcHR1cmVJbmRpY2VzO1xuICAgIGJlc3RNYXRjaFJ1bGVJZCA9IG1hdGNoUmVzdWx0LnJ1bGVJZDtcbiAgICBiZXN0TWF0Y2hSZXN1bHRQcmlvcml0eSA9IGluamVjdGlvbi5wcmlvcml0eTtcbiAgICBpZiAoYmVzdE1hdGNoUmF0aW5nID09PSBsaW5lUG9zKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGJlc3RNYXRjaENhcHR1cmVJbmRpY2VzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByaW9yaXR5TWF0Y2g6IGJlc3RNYXRjaFJlc3VsdFByaW9yaXR5ID09PSAtMSxcbiAgICAgIGNhcHR1cmVJbmRpY2VzOiBiZXN0TWF0Y2hDYXB0dXJlSW5kaWNlcyxcbiAgICAgIG1hdGNoZWRSdWxlSWQ6IGJlc3RNYXRjaFJ1bGVJZFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwcmVwYXJlUnVsZVNlYXJjaChydWxlLCBncmFtbWFyLCBlbmRSZWdleFNvdXJjZSwgYWxsb3dBLCBhbGxvd0cpIHtcbiAgaWYgKFVzZU9uaWd1cnVtYUZpbmRPcHRpb25zKSB7XG4gICAgY29uc3QgcnVsZVNjYW5uZXIyID0gcnVsZS5jb21waWxlKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKTtcbiAgICBjb25zdCBmaW5kT3B0aW9ucyA9IGdldEZpbmRPcHRpb25zKGFsbG93QSwgYWxsb3dHKTtcbiAgICByZXR1cm4geyBydWxlU2Nhbm5lcjogcnVsZVNjYW5uZXIyLCBmaW5kT3B0aW9ucyB9O1xuICB9XG4gIGNvbnN0IHJ1bGVTY2FubmVyID0gcnVsZS5jb21waWxlQUcoZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UsIGFsbG93QSwgYWxsb3dHKTtcbiAgcmV0dXJuIHsgcnVsZVNjYW5uZXIsIGZpbmRPcHRpb25zOiAwIC8qIE5vbmUgKi8gfTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVSdWxlV2hpbGVTZWFyY2gocnVsZSwgZ3JhbW1hciwgZW5kUmVnZXhTb3VyY2UsIGFsbG93QSwgYWxsb3dHKSB7XG4gIGlmIChVc2VPbmlndXJ1bWFGaW5kT3B0aW9ucykge1xuICAgIGNvbnN0IHJ1bGVTY2FubmVyMiA9IHJ1bGUuY29tcGlsZVdoaWxlKGdyYW1tYXIsIGVuZFJlZ2V4U291cmNlKTtcbiAgICBjb25zdCBmaW5kT3B0aW9ucyA9IGdldEZpbmRPcHRpb25zKGFsbG93QSwgYWxsb3dHKTtcbiAgICByZXR1cm4geyBydWxlU2Nhbm5lcjogcnVsZVNjYW5uZXIyLCBmaW5kT3B0aW9ucyB9O1xuICB9XG4gIGNvbnN0IHJ1bGVTY2FubmVyID0gcnVsZS5jb21waWxlV2hpbGVBRyhncmFtbWFyLCBlbmRSZWdleFNvdXJjZSwgYWxsb3dBLCBhbGxvd0cpO1xuICByZXR1cm4geyBydWxlU2Nhbm5lciwgZmluZE9wdGlvbnM6IDAgLyogTm9uZSAqLyB9O1xufVxuZnVuY3Rpb24gZ2V0RmluZE9wdGlvbnMoYWxsb3dBLCBhbGxvd0cpIHtcbiAgbGV0IG9wdGlvbnMgPSAwIC8qIE5vbmUgKi87XG4gIGlmICghYWxsb3dBKSB7XG4gICAgb3B0aW9ucyB8PSAxIC8qIE5vdEJlZ2luU3RyaW5nICovO1xuICB9XG4gIGlmICghYWxsb3dHKSB7XG4gICAgb3B0aW9ucyB8PSA0IC8qIE5vdEJlZ2luUG9zaXRpb24gKi87XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBoYW5kbGVDYXB0dXJlcyhncmFtbWFyLCBsaW5lVGV4dCwgaXNGaXJzdExpbmUsIHN0YWNrLCBsaW5lVG9rZW5zLCBjYXB0dXJlcywgY2FwdHVyZUluZGljZXMpIHtcbiAgaWYgKGNhcHR1cmVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBsaW5lVGV4dENvbnRlbnQgPSBsaW5lVGV4dC5jb250ZW50O1xuICBjb25zdCBsZW4gPSBNYXRoLm1pbihjYXB0dXJlcy5sZW5ndGgsIGNhcHR1cmVJbmRpY2VzLmxlbmd0aCk7XG4gIGNvbnN0IGxvY2FsU3RhY2sgPSBbXTtcbiAgY29uc3QgbWF4RW5kID0gY2FwdHVyZUluZGljZXNbMF0uZW5kO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY2FwdHVyZVJ1bGUgPSBjYXB0dXJlc1tpXTtcbiAgICBpZiAoY2FwdHVyZVJ1bGUgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBjYXB0dXJlSW5kZXggPSBjYXB0dXJlSW5kaWNlc1tpXTtcbiAgICBpZiAoY2FwdHVyZUluZGV4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjYXB0dXJlSW5kZXguc3RhcnQgPiBtYXhFbmQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB3aGlsZSAobG9jYWxTdGFjay5sZW5ndGggPiAwICYmIGxvY2FsU3RhY2tbbG9jYWxTdGFjay5sZW5ndGggLSAxXS5lbmRQb3MgPD0gY2FwdHVyZUluZGV4LnN0YXJ0KSB7XG4gICAgICBsaW5lVG9rZW5zLnByb2R1Y2VGcm9tU2NvcGVzKGxvY2FsU3RhY2tbbG9jYWxTdGFjay5sZW5ndGggLSAxXS5zY29wZXMsIGxvY2FsU3RhY2tbbG9jYWxTdGFjay5sZW5ndGggLSAxXS5lbmRQb3MpO1xuICAgICAgbG9jYWxTdGFjay5wb3AoKTtcbiAgICB9XG4gICAgaWYgKGxvY2FsU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgbGluZVRva2Vucy5wcm9kdWNlRnJvbVNjb3Blcyhsb2NhbFN0YWNrW2xvY2FsU3RhY2subGVuZ3RoIC0gMV0uc2NvcGVzLCBjYXB0dXJlSW5kZXguc3RhcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lVG9rZW5zLnByb2R1Y2Uoc3RhY2ssIGNhcHR1cmVJbmRleC5zdGFydCk7XG4gICAgfVxuICAgIGlmIChjYXB0dXJlUnVsZS5yZXRva2VuaXplQ2FwdHVyZWRXaXRoUnVsZUlkKSB7XG4gICAgICBjb25zdCBzY29wZU5hbWUgPSBjYXB0dXJlUnVsZS5nZXROYW1lKGxpbmVUZXh0Q29udGVudCwgY2FwdHVyZUluZGljZXMpO1xuICAgICAgY29uc3QgbmFtZVNjb3Blc0xpc3QgPSBzdGFjay5jb250ZW50TmFtZVNjb3Blc0xpc3QucHVzaEF0dHJpYnV0ZWQoc2NvcGVOYW1lLCBncmFtbWFyKTtcbiAgICAgIGNvbnN0IGNvbnRlbnROYW1lID0gY2FwdHVyZVJ1bGUuZ2V0Q29udGVudE5hbWUobGluZVRleHRDb250ZW50LCBjYXB0dXJlSW5kaWNlcyk7XG4gICAgICBjb25zdCBjb250ZW50TmFtZVNjb3Blc0xpc3QgPSBuYW1lU2NvcGVzTGlzdC5wdXNoQXR0cmlidXRlZChjb250ZW50TmFtZSwgZ3JhbW1hcik7XG4gICAgICBjb25zdCBzdGFja0Nsb25lID0gc3RhY2sucHVzaChjYXB0dXJlUnVsZS5yZXRva2VuaXplQ2FwdHVyZWRXaXRoUnVsZUlkLCBjYXB0dXJlSW5kZXguc3RhcnQsIC0xLCBmYWxzZSwgbnVsbCwgbmFtZVNjb3Blc0xpc3QsIGNvbnRlbnROYW1lU2NvcGVzTGlzdCk7XG4gICAgICBjb25zdCBvbmlnU3ViU3RyID0gZ3JhbW1hci5jcmVhdGVPbmlnU3RyaW5nKGxpbmVUZXh0Q29udGVudC5zdWJzdHJpbmcoMCwgY2FwdHVyZUluZGV4LmVuZCkpO1xuICAgICAgX3Rva2VuaXplU3RyaW5nKFxuICAgICAgICBncmFtbWFyLFxuICAgICAgICBvbmlnU3ViU3RyLFxuICAgICAgICBpc0ZpcnN0TGluZSAmJiBjYXB0dXJlSW5kZXguc3RhcnQgPT09IDAsXG4gICAgICAgIGNhcHR1cmVJbmRleC5zdGFydCxcbiAgICAgICAgc3RhY2tDbG9uZSxcbiAgICAgICAgbGluZVRva2VucyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIC8qIG5vIHRpbWUgbGltaXQgKi9cbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIGRpc3Bvc2VPbmlnU3RyaW5nKG9uaWdTdWJTdHIpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGNhcHR1cmVSdWxlU2NvcGVOYW1lID0gY2FwdHVyZVJ1bGUuZ2V0TmFtZShsaW5lVGV4dENvbnRlbnQsIGNhcHR1cmVJbmRpY2VzKTtcbiAgICBpZiAoY2FwdHVyZVJ1bGVTY29wZU5hbWUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGJhc2UgPSBsb2NhbFN0YWNrLmxlbmd0aCA+IDAgPyBsb2NhbFN0YWNrW2xvY2FsU3RhY2subGVuZ3RoIC0gMV0uc2NvcGVzIDogc3RhY2suY29udGVudE5hbWVTY29wZXNMaXN0O1xuICAgICAgY29uc3QgY2FwdHVyZVJ1bGVTY29wZXNMaXN0ID0gYmFzZS5wdXNoQXR0cmlidXRlZChjYXB0dXJlUnVsZVNjb3BlTmFtZSwgZ3JhbW1hcik7XG4gICAgICBsb2NhbFN0YWNrLnB1c2gobmV3IExvY2FsU3RhY2tFbGVtZW50KGNhcHR1cmVSdWxlU2NvcGVzTGlzdCwgY2FwdHVyZUluZGV4LmVuZCkpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAobG9jYWxTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgbGluZVRva2Vucy5wcm9kdWNlRnJvbVNjb3Blcyhsb2NhbFN0YWNrW2xvY2FsU3RhY2subGVuZ3RoIC0gMV0uc2NvcGVzLCBsb2NhbFN0YWNrW2xvY2FsU3RhY2subGVuZ3RoIC0gMV0uZW5kUG9zKTtcbiAgICBsb2NhbFN0YWNrLnBvcCgpO1xuICB9XG59XG52YXIgTG9jYWxTdGFja0VsZW1lbnQgPSBjbGFzcyB7XG4gIHNjb3BlcztcbiAgZW5kUG9zO1xuICBjb25zdHJ1Y3RvcihzY29wZXMsIGVuZFBvcykge1xuICAgIHRoaXMuc2NvcGVzID0gc2NvcGVzO1xuICAgIHRoaXMuZW5kUG9zID0gZW5kUG9zO1xuICB9XG59O1xuXG4vLyBzcmMvZ3JhbW1hci9ncmFtbWFyLnRzXG5mdW5jdGlvbiBjcmVhdGVHcmFtbWFyKHNjb3BlTmFtZSwgZ3JhbW1hciwgaW5pdGlhbExhbmd1YWdlLCBlbWJlZGRlZExhbmd1YWdlcywgdG9rZW5UeXBlcywgYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzLCBncmFtbWFyUmVwb3NpdG9yeSwgb25pZ0xpYikge1xuICByZXR1cm4gbmV3IEdyYW1tYXIoXG4gICAgc2NvcGVOYW1lLFxuICAgIGdyYW1tYXIsXG4gICAgaW5pdGlhbExhbmd1YWdlLFxuICAgIGVtYmVkZGVkTGFuZ3VhZ2VzLFxuICAgIHRva2VuVHlwZXMsXG4gICAgYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzLFxuICAgIGdyYW1tYXJSZXBvc2l0b3J5LFxuICAgIG9uaWdMaWJcbiAgKTtcbn1cbmZ1bmN0aW9uIGNvbGxlY3RJbmplY3Rpb25zKHJlc3VsdCwgc2VsZWN0b3IsIHJ1bGUsIHJ1bGVGYWN0b3J5SGVscGVyLCBncmFtbWFyKSB7XG4gIGNvbnN0IG1hdGNoZXJzID0gY3JlYXRlTWF0Y2hlcnMoc2VsZWN0b3IsIG5hbWVNYXRjaGVyKTtcbiAgY29uc3QgcnVsZUlkID0gUnVsZUZhY3RvcnkuZ2V0Q29tcGlsZWRSdWxlSWQocnVsZSwgcnVsZUZhY3RvcnlIZWxwZXIsIGdyYW1tYXIucmVwb3NpdG9yeSk7XG4gIGZvciAoY29uc3QgbWF0Y2hlciBvZiBtYXRjaGVycykge1xuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgIGRlYnVnU2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgbWF0Y2hlcjogbWF0Y2hlci5tYXRjaGVyLFxuICAgICAgcnVsZUlkLFxuICAgICAgZ3JhbW1hcixcbiAgICAgIHByaW9yaXR5OiBtYXRjaGVyLnByaW9yaXR5XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5hbWVNYXRjaGVyKGlkZW50aWZlcnMsIHNjb3Blcykge1xuICBpZiAoc2NvcGVzLmxlbmd0aCA8IGlkZW50aWZlcnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBsYXN0SW5kZXggPSAwO1xuICByZXR1cm4gaWRlbnRpZmVycy5ldmVyeSgoaWRlbnRpZmllcikgPT4ge1xuICAgIGZvciAobGV0IGkgPSBsYXN0SW5kZXg7IGkgPCBzY29wZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzY29wZXNBcmVNYXRjaGluZyhzY29wZXNbaV0sIGlkZW50aWZpZXIpKSB7XG4gICAgICAgIGxhc3RJbmRleCA9IGkgKyAxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNjb3Blc0FyZU1hdGNoaW5nKHRoaXNTY29wZU5hbWUsIHNjb3BlTmFtZSkge1xuICBpZiAoIXRoaXNTY29wZU5hbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHRoaXNTY29wZU5hbWUgPT09IHNjb3BlTmFtZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGxlbiA9IHNjb3BlTmFtZS5sZW5ndGg7XG4gIHJldHVybiB0aGlzU2NvcGVOYW1lLmxlbmd0aCA+IGxlbiAmJiB0aGlzU2NvcGVOYW1lLnN1YnN0cigwLCBsZW4pID09PSBzY29wZU5hbWUgJiYgdGhpc1Njb3BlTmFtZVtsZW5dID09PSBcIi5cIjtcbn1cbnZhciBHcmFtbWFyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihfcm9vdFNjb3BlTmFtZSwgZ3JhbW1hciwgaW5pdGlhbExhbmd1YWdlLCBlbWJlZGRlZExhbmd1YWdlcywgdG9rZW5UeXBlcywgYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzLCBncmFtbWFyUmVwb3NpdG9yeSwgX29uaWdMaWIpIHtcbiAgICB0aGlzLl9yb290U2NvcGVOYW1lID0gX3Jvb3RTY29wZU5hbWU7XG4gICAgdGhpcy5iYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMgPSBiYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnM7XG4gICAgdGhpcy5fb25pZ0xpYiA9IF9vbmlnTGliO1xuICAgIHRoaXMuX2Jhc2ljU2NvcGVBdHRyaWJ1dGVzUHJvdmlkZXIgPSBuZXcgQmFzaWNTY29wZUF0dHJpYnV0ZXNQcm92aWRlcihcbiAgICAgIGluaXRpYWxMYW5ndWFnZSxcbiAgICAgIGVtYmVkZGVkTGFuZ3VhZ2VzXG4gICAgKTtcbiAgICB0aGlzLl9yb290SWQgPSAtMTtcbiAgICB0aGlzLl9sYXN0UnVsZUlkID0gMDtcbiAgICB0aGlzLl9ydWxlSWQyZGVzYyA9IFtudWxsXTtcbiAgICB0aGlzLl9pbmNsdWRlZEdyYW1tYXJzID0ge307XG4gICAgdGhpcy5fZ3JhbW1hclJlcG9zaXRvcnkgPSBncmFtbWFyUmVwb3NpdG9yeTtcbiAgICB0aGlzLl9ncmFtbWFyID0gaW5pdEdyYW1tYXIoZ3JhbW1hciwgbnVsbCk7XG4gICAgdGhpcy5faW5qZWN0aW9ucyA9IG51bGw7XG4gICAgdGhpcy5fdG9rZW5UeXBlTWF0Y2hlcnMgPSBbXTtcbiAgICBpZiAodG9rZW5UeXBlcykge1xuICAgICAgZm9yIChjb25zdCBzZWxlY3RvciBvZiBPYmplY3Qua2V5cyh0b2tlblR5cGVzKSkge1xuICAgICAgICBjb25zdCBtYXRjaGVycyA9IGNyZWF0ZU1hdGNoZXJzKHNlbGVjdG9yLCBuYW1lTWF0Y2hlcik7XG4gICAgICAgIGZvciAoY29uc3QgbWF0Y2hlciBvZiBtYXRjaGVycykge1xuICAgICAgICAgIHRoaXMuX3Rva2VuVHlwZU1hdGNoZXJzLnB1c2goe1xuICAgICAgICAgICAgbWF0Y2hlcjogbWF0Y2hlci5tYXRjaGVyLFxuICAgICAgICAgICAgdHlwZTogdG9rZW5UeXBlc1tzZWxlY3Rvcl1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfcm9vdElkO1xuICBfbGFzdFJ1bGVJZDtcbiAgX3J1bGVJZDJkZXNjO1xuICBfaW5jbHVkZWRHcmFtbWFycztcbiAgX2dyYW1tYXJSZXBvc2l0b3J5O1xuICBfZ3JhbW1hcjtcbiAgX2luamVjdGlvbnM7XG4gIF9iYXNpY1Njb3BlQXR0cmlidXRlc1Byb3ZpZGVyO1xuICBfdG9rZW5UeXBlTWF0Y2hlcnM7XG4gIGdldCB0aGVtZVByb3ZpZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9ncmFtbWFyUmVwb3NpdG9yeTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGZvciAoY29uc3QgcnVsZSBvZiB0aGlzLl9ydWxlSWQyZGVzYykge1xuICAgICAgaWYgKHJ1bGUpIHtcbiAgICAgICAgcnVsZS5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNyZWF0ZU9uaWdTY2FubmVyKHNvdXJjZXMpIHtcbiAgICByZXR1cm4gdGhpcy5fb25pZ0xpYi5jcmVhdGVPbmlnU2Nhbm5lcihzb3VyY2VzKTtcbiAgfVxuICBjcmVhdGVPbmlnU3RyaW5nKHNvdXJjZXMpIHtcbiAgICByZXR1cm4gdGhpcy5fb25pZ0xpYi5jcmVhdGVPbmlnU3RyaW5nKHNvdXJjZXMpO1xuICB9XG4gIGdldE1ldGFkYXRhRm9yU2NvcGUoc2NvcGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFzaWNTY29wZUF0dHJpYnV0ZXNQcm92aWRlci5nZXRCYXNpY1Njb3BlQXR0cmlidXRlcyhzY29wZSk7XG4gIH1cbiAgX2NvbGxlY3RJbmplY3Rpb25zKCkge1xuICAgIGNvbnN0IGdyYW1tYXJSZXBvc2l0b3J5ID0ge1xuICAgICAgbG9va3VwOiAoc2NvcGVOYW1lMikgPT4ge1xuICAgICAgICBpZiAoc2NvcGVOYW1lMiA9PT0gdGhpcy5fcm9vdFNjb3BlTmFtZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9ncmFtbWFyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEV4dGVybmFsR3JhbW1hcihzY29wZU5hbWUyKTtcbiAgICAgIH0sXG4gICAgICBpbmplY3Rpb25zOiAoc2NvcGVOYW1lMikgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhbW1hclJlcG9zaXRvcnkuaW5qZWN0aW9ucyhzY29wZU5hbWUyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHNjb3BlTmFtZSA9IHRoaXMuX3Jvb3RTY29wZU5hbWU7XG4gICAgY29uc3QgZ3JhbW1hciA9IGdyYW1tYXJSZXBvc2l0b3J5Lmxvb2t1cChzY29wZU5hbWUpO1xuICAgIGlmIChncmFtbWFyKSB7XG4gICAgICBjb25zdCByYXdJbmplY3Rpb25zID0gZ3JhbW1hci5pbmplY3Rpb25zO1xuICAgICAgaWYgKHJhd0luamVjdGlvbnMpIHtcbiAgICAgICAgZm9yIChsZXQgZXhwcmVzc2lvbiBpbiByYXdJbmplY3Rpb25zKSB7XG4gICAgICAgICAgY29sbGVjdEluamVjdGlvbnMoXG4gICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICAgICAgcmF3SW5qZWN0aW9uc1tleHByZXNzaW9uXSxcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBncmFtbWFyXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaW5qZWN0aW9uU2NvcGVOYW1lcyA9IHRoaXMuX2dyYW1tYXJSZXBvc2l0b3J5LmluamVjdGlvbnMoc2NvcGVOYW1lKTtcbiAgICAgIGlmIChpbmplY3Rpb25TY29wZU5hbWVzKSB7XG4gICAgICAgIGluamVjdGlvblNjb3BlTmFtZXMuZm9yRWFjaCgoaW5qZWN0aW9uU2NvcGVOYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5qZWN0aW9uR3JhbW1hciA9IHRoaXMuZ2V0RXh0ZXJuYWxHcmFtbWFyKGluamVjdGlvblNjb3BlTmFtZSk7XG4gICAgICAgICAgaWYgKGluamVjdGlvbkdyYW1tYXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gaW5qZWN0aW9uR3JhbW1hci5pbmplY3Rpb25TZWxlY3RvcjtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICBjb2xsZWN0SW5qZWN0aW9ucyhcbiAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgaW5qZWN0aW9uR3JhbW1hcixcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGluamVjdGlvbkdyYW1tYXJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc29ydCgoaTEsIGkyKSA9PiBpMS5wcmlvcml0eSAtIGkyLnByaW9yaXR5KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldEluamVjdGlvbnMoKSB7XG4gICAgaWYgKHRoaXMuX2luamVjdGlvbnMgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2luamVjdGlvbnMgPSB0aGlzLl9jb2xsZWN0SW5qZWN0aW9ucygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faW5qZWN0aW9ucztcbiAgfVxuICByZWdpc3RlclJ1bGUoZmFjdG9yeSkge1xuICAgIGNvbnN0IGlkID0gKyt0aGlzLl9sYXN0UnVsZUlkO1xuICAgIGNvbnN0IHJlc3VsdCA9IGZhY3RvcnkocnVsZUlkRnJvbU51bWJlcihpZCkpO1xuICAgIHRoaXMuX3J1bGVJZDJkZXNjW2lkXSA9IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldFJ1bGUocnVsZUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3J1bGVJZDJkZXNjW3J1bGVJZFRvTnVtYmVyKHJ1bGVJZCldO1xuICB9XG4gIGdldEV4dGVybmFsR3JhbW1hcihzY29wZU5hbWUsIHJlcG9zaXRvcnkpIHtcbiAgICBpZiAodGhpcy5faW5jbHVkZWRHcmFtbWFyc1tzY29wZU5hbWVdKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5jbHVkZWRHcmFtbWFyc1tzY29wZU5hbWVdO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZ3JhbW1hclJlcG9zaXRvcnkpIHtcbiAgICAgIGNvbnN0IHJhd0luY2x1ZGVkR3JhbW1hciA9IHRoaXMuX2dyYW1tYXJSZXBvc2l0b3J5Lmxvb2t1cChzY29wZU5hbWUpO1xuICAgICAgaWYgKHJhd0luY2x1ZGVkR3JhbW1hcikge1xuICAgICAgICB0aGlzLl9pbmNsdWRlZEdyYW1tYXJzW3Njb3BlTmFtZV0gPSBpbml0R3JhbW1hcihcbiAgICAgICAgICByYXdJbmNsdWRlZEdyYW1tYXIsXG4gICAgICAgICAgcmVwb3NpdG9yeSAmJiByZXBvc2l0b3J5LiRiYXNlXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmNsdWRlZEdyYW1tYXJzW3Njb3BlTmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgdG9rZW5pemVMaW5lKGxpbmVUZXh0LCBwcmV2U3RhdGUsIHRpbWVMaW1pdCA9IDApIHtcbiAgICBjb25zdCByID0gdGhpcy5fdG9rZW5pemUobGluZVRleHQsIHByZXZTdGF0ZSwgZmFsc2UsIHRpbWVMaW1pdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2Vuczogci5saW5lVG9rZW5zLmdldFJlc3VsdChyLnJ1bGVTdGFjaywgci5saW5lTGVuZ3RoKSxcbiAgICAgIHJ1bGVTdGFjazogci5ydWxlU3RhY2ssXG4gICAgICBzdG9wcGVkRWFybHk6IHIuc3RvcHBlZEVhcmx5XG4gICAgfTtcbiAgfVxuICB0b2tlbml6ZUxpbmUyKGxpbmVUZXh0LCBwcmV2U3RhdGUsIHRpbWVMaW1pdCA9IDApIHtcbiAgICBjb25zdCByID0gdGhpcy5fdG9rZW5pemUobGluZVRleHQsIHByZXZTdGF0ZSwgdHJ1ZSwgdGltZUxpbWl0KTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5zOiByLmxpbmVUb2tlbnMuZ2V0QmluYXJ5UmVzdWx0KHIucnVsZVN0YWNrLCByLmxpbmVMZW5ndGgpLFxuICAgICAgcnVsZVN0YWNrOiByLnJ1bGVTdGFjayxcbiAgICAgIHN0b3BwZWRFYXJseTogci5zdG9wcGVkRWFybHlcbiAgICB9O1xuICB9XG4gIF90b2tlbml6ZShsaW5lVGV4dCwgcHJldlN0YXRlLCBlbWl0QmluYXJ5VG9rZW5zLCB0aW1lTGltaXQpIHtcbiAgICBpZiAodGhpcy5fcm9vdElkID09PSAtMSkge1xuICAgICAgdGhpcy5fcm9vdElkID0gUnVsZUZhY3RvcnkuZ2V0Q29tcGlsZWRSdWxlSWQoXG4gICAgICAgIHRoaXMuX2dyYW1tYXIucmVwb3NpdG9yeS4kc2VsZixcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5fZ3JhbW1hci5yZXBvc2l0b3J5XG4gICAgICApO1xuICAgICAgdGhpcy5nZXRJbmplY3Rpb25zKCk7XG4gICAgfVxuICAgIGxldCBpc0ZpcnN0TGluZTtcbiAgICBpZiAoIXByZXZTdGF0ZSB8fCBwcmV2U3RhdGUgPT09IFN0YXRlU3RhY2tJbXBsLk5VTEwpIHtcbiAgICAgIGlzRmlyc3RMaW5lID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHJhd0RlZmF1bHRNZXRhZGF0YSA9IHRoaXMuX2Jhc2ljU2NvcGVBdHRyaWJ1dGVzUHJvdmlkZXIuZ2V0RGVmYXVsdEF0dHJpYnV0ZXMoKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHRoaXMudGhlbWVQcm92aWRlci5nZXREZWZhdWx0cygpO1xuICAgICAgY29uc3QgZGVmYXVsdE1ldGFkYXRhID0gRW5jb2RlZFRva2VuTWV0YWRhdGEuc2V0KFxuICAgICAgICAwLFxuICAgICAgICByYXdEZWZhdWx0TWV0YWRhdGEubGFuZ3VhZ2VJZCxcbiAgICAgICAgcmF3RGVmYXVsdE1ldGFkYXRhLnRva2VuVHlwZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgZGVmYXVsdFN0eWxlLmZvbnRTdHlsZSxcbiAgICAgICAgZGVmYXVsdFN0eWxlLmZvcmVncm91bmRJZCxcbiAgICAgICAgZGVmYXVsdFN0eWxlLmJhY2tncm91bmRJZFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJvb3RTY29wZU5hbWUgPSB0aGlzLmdldFJ1bGUodGhpcy5fcm9vdElkKS5nZXROYW1lKFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgICAgbGV0IHNjb3BlTGlzdDtcbiAgICAgIGlmIChyb290U2NvcGVOYW1lKSB7XG4gICAgICAgIHNjb3BlTGlzdCA9IEF0dHJpYnV0ZWRTY29wZVN0YWNrLmNyZWF0ZVJvb3RBbmRMb29rVXBTY29wZU5hbWUoXG4gICAgICAgICAgcm9vdFNjb3BlTmFtZSxcbiAgICAgICAgICBkZWZhdWx0TWV0YWRhdGEsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NvcGVMaXN0ID0gQXR0cmlidXRlZFNjb3BlU3RhY2suY3JlYXRlUm9vdChcbiAgICAgICAgICBcInVua25vd25cIixcbiAgICAgICAgICBkZWZhdWx0TWV0YWRhdGFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByZXZTdGF0ZSA9IG5ldyBTdGF0ZVN0YWNrSW1wbChcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdGhpcy5fcm9vdElkLFxuICAgICAgICAtMSxcbiAgICAgICAgLTEsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBudWxsLFxuICAgICAgICBzY29wZUxpc3QsXG4gICAgICAgIHNjb3BlTGlzdFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNGaXJzdExpbmUgPSBmYWxzZTtcbiAgICAgIHByZXZTdGF0ZS5yZXNldCgpO1xuICAgIH1cbiAgICBsaW5lVGV4dCA9IGxpbmVUZXh0ICsgXCJcXG5cIjtcbiAgICBjb25zdCBvbmlnTGluZVRleHQgPSB0aGlzLmNyZWF0ZU9uaWdTdHJpbmcobGluZVRleHQpO1xuICAgIGNvbnN0IGxpbmVMZW5ndGggPSBvbmlnTGluZVRleHQuY29udGVudC5sZW5ndGg7XG4gICAgY29uc3QgbGluZVRva2VucyA9IG5ldyBMaW5lVG9rZW5zKFxuICAgICAgZW1pdEJpbmFyeVRva2VucyxcbiAgICAgIGxpbmVUZXh0LFxuICAgICAgdGhpcy5fdG9rZW5UeXBlTWF0Y2hlcnMsXG4gICAgICB0aGlzLmJhbGFuY2VkQnJhY2tldFNlbGVjdG9yc1xuICAgICk7XG4gICAgY29uc3QgciA9IF90b2tlbml6ZVN0cmluZyhcbiAgICAgIHRoaXMsXG4gICAgICBvbmlnTGluZVRleHQsXG4gICAgICBpc0ZpcnN0TGluZSxcbiAgICAgIDAsXG4gICAgICBwcmV2U3RhdGUsXG4gICAgICBsaW5lVG9rZW5zLFxuICAgICAgdHJ1ZSxcbiAgICAgIHRpbWVMaW1pdFxuICAgICk7XG4gICAgZGlzcG9zZU9uaWdTdHJpbmcob25pZ0xpbmVUZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZUxlbmd0aCxcbiAgICAgIGxpbmVUb2tlbnMsXG4gICAgICBydWxlU3RhY2s6IHIuc3RhY2ssXG4gICAgICBzdG9wcGVkRWFybHk6IHIuc3RvcHBlZEVhcmx5XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIGluaXRHcmFtbWFyKGdyYW1tYXIsIGJhc2UpIHtcbiAgZ3JhbW1hciA9IGNsb25lKGdyYW1tYXIpO1xuICBncmFtbWFyLnJlcG9zaXRvcnkgPSBncmFtbWFyLnJlcG9zaXRvcnkgfHwge307XG4gIGdyYW1tYXIucmVwb3NpdG9yeS4kc2VsZiA9IHtcbiAgICAkdnNjb2RlVGV4dG1hdGVMb2NhdGlvbjogZ3JhbW1hci4kdnNjb2RlVGV4dG1hdGVMb2NhdGlvbixcbiAgICBwYXR0ZXJuczogZ3JhbW1hci5wYXR0ZXJucyxcbiAgICBuYW1lOiBncmFtbWFyLnNjb3BlTmFtZVxuICB9O1xuICBncmFtbWFyLnJlcG9zaXRvcnkuJGJhc2UgPSBiYXNlIHx8IGdyYW1tYXIucmVwb3NpdG9yeS4kc2VsZjtcbiAgcmV0dXJuIGdyYW1tYXI7XG59XG52YXIgQXR0cmlidXRlZFNjb3BlU3RhY2sgPSBjbGFzcyBfQXR0cmlidXRlZFNjb3BlU3RhY2sge1xuICAvKipcbiAgICogSW52YXJpYW50OlxuICAgKiBgYGBcbiAgICogaWYgKHBhcmVudCAmJiAhc2NvcGVQYXRoLmV4dGVuZHMocGFyZW50LnNjb3BlUGF0aCkpIHtcbiAgICogXHR0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgc2NvcGVQYXRoLCB0b2tlbkF0dHJpYnV0ZXMpIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLnNjb3BlUGF0aCA9IHNjb3BlUGF0aDtcbiAgICB0aGlzLnRva2VuQXR0cmlidXRlcyA9IHRva2VuQXR0cmlidXRlcztcbiAgfVxuICBzdGF0aWMgZnJvbUV4dGVuc2lvbihuYW1lc1Njb3BlTGlzdCwgY29udGVudE5hbWVTY29wZXNMaXN0KSB7XG4gICAgbGV0IGN1cnJlbnQgPSBuYW1lc1Njb3BlTGlzdDtcbiAgICBsZXQgc2NvcGVOYW1lcyA9IG5hbWVzU2NvcGVMaXN0Py5zY29wZVBhdGggPz8gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGZyYW1lIG9mIGNvbnRlbnROYW1lU2NvcGVzTGlzdCkge1xuICAgICAgc2NvcGVOYW1lcyA9IFNjb3BlU3RhY2sucHVzaChzY29wZU5hbWVzLCBmcmFtZS5zY29wZU5hbWVzKTtcbiAgICAgIGN1cnJlbnQgPSBuZXcgX0F0dHJpYnV0ZWRTY29wZVN0YWNrKGN1cnJlbnQsIHNjb3BlTmFtZXMsIGZyYW1lLmVuY29kZWRUb2tlbkF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuICBzdGF0aWMgY3JlYXRlUm9vdChzY29wZU5hbWUsIHRva2VuQXR0cmlidXRlcykge1xuICAgIHJldHVybiBuZXcgX0F0dHJpYnV0ZWRTY29wZVN0YWNrKG51bGwsIG5ldyBTY29wZVN0YWNrKG51bGwsIHNjb3BlTmFtZSksIHRva2VuQXR0cmlidXRlcyk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZVJvb3RBbmRMb29rVXBTY29wZU5hbWUoc2NvcGVOYW1lLCB0b2tlbkF0dHJpYnV0ZXMsIGdyYW1tYXIpIHtcbiAgICBjb25zdCByYXdSb290TWV0YWRhdGEgPSBncmFtbWFyLmdldE1ldGFkYXRhRm9yU2NvcGUoc2NvcGVOYW1lKTtcbiAgICBjb25zdCBzY29wZVBhdGggPSBuZXcgU2NvcGVTdGFjayhudWxsLCBzY29wZU5hbWUpO1xuICAgIGNvbnN0IHJvb3RTdHlsZSA9IGdyYW1tYXIudGhlbWVQcm92aWRlci50aGVtZU1hdGNoKHNjb3BlUGF0aCk7XG4gICAgY29uc3QgcmVzb2x2ZWRUb2tlbkF0dHJpYnV0ZXMgPSBfQXR0cmlidXRlZFNjb3BlU3RhY2subWVyZ2VBdHRyaWJ1dGVzKFxuICAgICAgdG9rZW5BdHRyaWJ1dGVzLFxuICAgICAgcmF3Um9vdE1ldGFkYXRhLFxuICAgICAgcm9vdFN0eWxlXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IF9BdHRyaWJ1dGVkU2NvcGVTdGFjayhudWxsLCBzY29wZVBhdGgsIHJlc29sdmVkVG9rZW5BdHRyaWJ1dGVzKTtcbiAgfVxuICBnZXQgc2NvcGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnNjb3BlUGF0aC5zY29wZU5hbWU7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2NvcGVOYW1lcygpLmpvaW4oXCIgXCIpO1xuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBfQXR0cmlidXRlZFNjb3BlU3RhY2suZXF1YWxzKHRoaXMsIG90aGVyKTtcbiAgfVxuICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICBkbyB7XG4gICAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghYSB8fCAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoYS5zY29wZU5hbWUgIT09IGIuc2NvcGVOYW1lIHx8IGEudG9rZW5BdHRyaWJ1dGVzICE9PSBiLnRva2VuQXR0cmlidXRlcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBhID0gYS5wYXJlbnQ7XG4gICAgICBiID0gYi5wYXJlbnQ7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG4gIH1cbiAgc3RhdGljIG1lcmdlQXR0cmlidXRlcyhleGlzdGluZ1Rva2VuQXR0cmlidXRlcywgYmFzaWNTY29wZUF0dHJpYnV0ZXMsIHN0eWxlQXR0cmlidXRlcykge1xuICAgIGxldCBmb250U3R5bGUgPSAtMSAvKiBOb3RTZXQgKi87XG4gICAgbGV0IGZvcmVncm91bmQgPSAwO1xuICAgIGxldCBiYWNrZ3JvdW5kID0gMDtcbiAgICBpZiAoc3R5bGVBdHRyaWJ1dGVzICE9PSBudWxsKSB7XG4gICAgICBmb250U3R5bGUgPSBzdHlsZUF0dHJpYnV0ZXMuZm9udFN0eWxlO1xuICAgICAgZm9yZWdyb3VuZCA9IHN0eWxlQXR0cmlidXRlcy5mb3JlZ3JvdW5kSWQ7XG4gICAgICBiYWNrZ3JvdW5kID0gc3R5bGVBdHRyaWJ1dGVzLmJhY2tncm91bmRJZDtcbiAgICB9XG4gICAgcmV0dXJuIEVuY29kZWRUb2tlbk1ldGFkYXRhLnNldChcbiAgICAgIGV4aXN0aW5nVG9rZW5BdHRyaWJ1dGVzLFxuICAgICAgYmFzaWNTY29wZUF0dHJpYnV0ZXMubGFuZ3VhZ2VJZCxcbiAgICAgIGJhc2ljU2NvcGVBdHRyaWJ1dGVzLnRva2VuVHlwZSxcbiAgICAgIG51bGwsXG4gICAgICBmb250U3R5bGUsXG4gICAgICBmb3JlZ3JvdW5kLFxuICAgICAgYmFja2dyb3VuZFxuICAgICk7XG4gIH1cbiAgcHVzaEF0dHJpYnV0ZWQoc2NvcGVQYXRoLCBncmFtbWFyKSB7XG4gICAgaWYgKHNjb3BlUGF0aCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChzY29wZVBhdGguaW5kZXhPZihcIiBcIikgPT09IC0xKSB7XG4gICAgICByZXR1cm4gX0F0dHJpYnV0ZWRTY29wZVN0YWNrLl9wdXNoQXR0cmlidXRlZCh0aGlzLCBzY29wZVBhdGgsIGdyYW1tYXIpO1xuICAgIH1cbiAgICBjb25zdCBzY29wZXMgPSBzY29wZVBhdGguc3BsaXQoLyAvZyk7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXM7XG4gICAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICAgIHJlc3VsdCA9IF9BdHRyaWJ1dGVkU2NvcGVTdGFjay5fcHVzaEF0dHJpYnV0ZWQocmVzdWx0LCBzY29wZSwgZ3JhbW1hcik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc3RhdGljIF9wdXNoQXR0cmlidXRlZCh0YXJnZXQsIHNjb3BlTmFtZSwgZ3JhbW1hcikge1xuICAgIGNvbnN0IHJhd01ldGFkYXRhID0gZ3JhbW1hci5nZXRNZXRhZGF0YUZvclNjb3BlKHNjb3BlTmFtZSk7XG4gICAgY29uc3QgbmV3UGF0aCA9IHRhcmdldC5zY29wZVBhdGgucHVzaChzY29wZU5hbWUpO1xuICAgIGNvbnN0IHNjb3BlVGhlbWVNYXRjaFJlc3VsdCA9IGdyYW1tYXIudGhlbWVQcm92aWRlci50aGVtZU1hdGNoKG5ld1BhdGgpO1xuICAgIGNvbnN0IG1ldGFkYXRhID0gX0F0dHJpYnV0ZWRTY29wZVN0YWNrLm1lcmdlQXR0cmlidXRlcyhcbiAgICAgIHRhcmdldC50b2tlbkF0dHJpYnV0ZXMsXG4gICAgICByYXdNZXRhZGF0YSxcbiAgICAgIHNjb3BlVGhlbWVNYXRjaFJlc3VsdFxuICAgICk7XG4gICAgcmV0dXJuIG5ldyBfQXR0cmlidXRlZFNjb3BlU3RhY2sodGFyZ2V0LCBuZXdQYXRoLCBtZXRhZGF0YSk7XG4gIH1cbiAgZ2V0U2NvcGVOYW1lcygpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZVBhdGguZ2V0U2VnbWVudHMoKTtcbiAgfVxuICBnZXRFeHRlbnNpb25JZkRlZmluZWQoYmFzZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICB3aGlsZSAoc2VsZiAmJiBzZWxmICE9PSBiYXNlKSB7XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIGVuY29kZWRUb2tlbkF0dHJpYnV0ZXM6IHNlbGYudG9rZW5BdHRyaWJ1dGVzLFxuICAgICAgICBzY29wZU5hbWVzOiBzZWxmLnNjb3BlUGF0aC5nZXRFeHRlbnNpb25JZkRlZmluZWQoc2VsZi5wYXJlbnQ/LnNjb3BlUGF0aCA/PyBudWxsKVxuICAgICAgfSk7XG4gICAgICBzZWxmID0gc2VsZi5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBzZWxmID09PSBiYXNlID8gcmVzdWx0LnJldmVyc2UoKSA6IHZvaWQgMDtcbiAgfVxufTtcbnZhciBTdGF0ZVN0YWNrSW1wbCA9IGNsYXNzIF9TdGF0ZVN0YWNrSW1wbCB7XG4gIC8qKlxuICAgKiBJbnZhcmlhbnQ6XG4gICAqIGBgYFxuICAgKiBpZiAoY29udGVudE5hbWVTY29wZXNMaXN0ICE9PSBuYW1lU2NvcGVzTGlzdCAmJiBjb250ZW50TmFtZVNjb3Blc0xpc3Q/LnBhcmVudCAhPT0gbmFtZVNjb3Blc0xpc3QpIHtcbiAgICogXHR0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICogfVxuICAgKiBpZiAodGhpcy5wYXJlbnQgJiYgIW5hbWVTY29wZXNMaXN0LmV4dGVuZHModGhpcy5wYXJlbnQuY29udGVudE5hbWVTY29wZXNMaXN0KSkge1xuICAgKiBcdHRocm93IG5ldyBFcnJvcigpO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgY29uc3RydWN0b3IocGFyZW50LCBydWxlSWQsIGVudGVyUG9zLCBhbmNob3JQb3MsIGJlZ2luUnVsZUNhcHR1cmVkRU9MLCBlbmRSdWxlLCBuYW1lU2NvcGVzTGlzdCwgY29udGVudE5hbWVTY29wZXNMaXN0KSB7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5ydWxlSWQgPSBydWxlSWQ7XG4gICAgdGhpcy5iZWdpblJ1bGVDYXB0dXJlZEVPTCA9IGJlZ2luUnVsZUNhcHR1cmVkRU9MO1xuICAgIHRoaXMuZW5kUnVsZSA9IGVuZFJ1bGU7XG4gICAgdGhpcy5uYW1lU2NvcGVzTGlzdCA9IG5hbWVTY29wZXNMaXN0O1xuICAgIHRoaXMuY29udGVudE5hbWVTY29wZXNMaXN0ID0gY29udGVudE5hbWVTY29wZXNMaXN0O1xuICAgIHRoaXMuZGVwdGggPSB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmRlcHRoICsgMSA6IDE7XG4gICAgdGhpcy5fZW50ZXJQb3MgPSBlbnRlclBvcztcbiAgICB0aGlzLl9hbmNob3JQb3MgPSBhbmNob3JQb3M7XG4gIH1cbiAgX3N0YWNrRWxlbWVudEJyYW5kID0gdm9pZCAwO1xuICAvLyBUT0RPIHJlbW92ZSBtZVxuICBzdGF0aWMgTlVMTCA9IG5ldyBfU3RhdGVTdGFja0ltcGwoXG4gICAgbnVsbCxcbiAgICAwLFxuICAgIDAsXG4gICAgMCxcbiAgICBmYWxzZSxcbiAgICBudWxsLFxuICAgIG51bGwsXG4gICAgbnVsbFxuICApO1xuICAvKipcbiAgICogVGhlIHBvc2l0aW9uIG9uIHRoZSBjdXJyZW50IGxpbmUgd2hlcmUgdGhpcyBzdGF0ZSB3YXMgcHVzaGVkLlxuICAgKiBUaGlzIGlzIHJlbGV2YW50IG9ubHkgd2hpbGUgdG9rZW5pemluZyBhIGxpbmUsIHRvIGRldGVjdCBlbmRsZXNzIGxvb3BzLlxuICAgKiBJdHMgdmFsdWUgaXMgbWVhbmluZ2xlc3MgYWNyb3NzIGxpbmVzLlxuICAgKi9cbiAgX2VudGVyUG9zO1xuICAvKipcbiAgICogVGhlIGNhcHR1cmVkIGFuY2hvciBwb3NpdGlvbiB3aGVuIHRoaXMgc3RhY2sgZWxlbWVudCB3YXMgcHVzaGVkLlxuICAgKiBUaGlzIGlzIHJlbGV2YW50IG9ubHkgd2hpbGUgdG9rZW5pemluZyBhIGxpbmUsIHRvIHJlc3RvcmUgdGhlIGFuY2hvciBwb3NpdGlvbiB3aGVuIHBvcHBpbmcuXG4gICAqIEl0cyB2YWx1ZSBpcyBtZWFuaW5nbGVzcyBhY3Jvc3MgbGluZXMuXG4gICAqL1xuICBfYW5jaG9yUG9zO1xuICAvKipcbiAgICogVGhlIGRlcHRoIG9mIHRoZSBzdGFjay5cbiAgICovXG4gIGRlcHRoO1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAob3RoZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIF9TdGF0ZVN0YWNrSW1wbC5fZXF1YWxzKHRoaXMsIG90aGVyKTtcbiAgfVxuICBzdGF0aWMgX2VxdWFscyhhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3N0cnVjdHVyYWxFcXVhbHMoYSwgYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIEF0dHJpYnV0ZWRTY29wZVN0YWNrLmVxdWFscyhhLmNvbnRlbnROYW1lU2NvcGVzTGlzdCwgYi5jb250ZW50TmFtZVNjb3Blc0xpc3QpO1xuICB9XG4gIC8qKlxuICAgKiBBIHN0cnVjdHVyYWwgZXF1YWxzIGNoZWNrLiBEb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCBgc2NvcGVzYC5cbiAgICovXG4gIHN0YXRpYyBfc3RydWN0dXJhbEVxdWFscyhhLCBiKSB7XG4gICAgZG8ge1xuICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWEgfHwgIWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGEuZGVwdGggIT09IGIuZGVwdGggfHwgYS5ydWxlSWQgIT09IGIucnVsZUlkIHx8IGEuZW5kUnVsZSAhPT0gYi5lbmRSdWxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGEgPSBhLnBhcmVudDtcbiAgICAgIGIgPSBiLnBhcmVudDtcbiAgICB9IHdoaWxlICh0cnVlKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzdGF0aWMgX3Jlc2V0KGVsKSB7XG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICBlbC5fZW50ZXJQb3MgPSAtMTtcbiAgICAgIGVsLl9hbmNob3JQb3MgPSAtMTtcbiAgICAgIGVsID0gZWwucGFyZW50O1xuICAgIH1cbiAgfVxuICByZXNldCgpIHtcbiAgICBfU3RhdGVTdGFja0ltcGwuX3Jlc2V0KHRoaXMpO1xuICB9XG4gIHBvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gIH1cbiAgc2FmZVBvcCgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcHVzaChydWxlSWQsIGVudGVyUG9zLCBhbmNob3JQb3MsIGJlZ2luUnVsZUNhcHR1cmVkRU9MLCBlbmRSdWxlLCBuYW1lU2NvcGVzTGlzdCwgY29udGVudE5hbWVTY29wZXNMaXN0KSB7XG4gICAgcmV0dXJuIG5ldyBfU3RhdGVTdGFja0ltcGwoXG4gICAgICB0aGlzLFxuICAgICAgcnVsZUlkLFxuICAgICAgZW50ZXJQb3MsXG4gICAgICBhbmNob3JQb3MsXG4gICAgICBiZWdpblJ1bGVDYXB0dXJlZEVPTCxcbiAgICAgIGVuZFJ1bGUsXG4gICAgICBuYW1lU2NvcGVzTGlzdCxcbiAgICAgIGNvbnRlbnROYW1lU2NvcGVzTGlzdFxuICAgICk7XG4gIH1cbiAgZ2V0RW50ZXJQb3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VudGVyUG9zO1xuICB9XG4gIGdldEFuY2hvclBvcygpIHtcbiAgICByZXR1cm4gdGhpcy5fYW5jaG9yUG9zO1xuICB9XG4gIGdldFJ1bGUoZ3JhbW1hcikge1xuICAgIHJldHVybiBncmFtbWFyLmdldFJ1bGUodGhpcy5ydWxlSWQpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICB0aGlzLl93cml0ZVN0cmluZyhyLCAwKTtcbiAgICByZXR1cm4gXCJbXCIgKyByLmpvaW4oXCIsXCIpICsgXCJdXCI7XG4gIH1cbiAgX3dyaXRlU3RyaW5nKHJlcywgb3V0SW5kZXgpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIG91dEluZGV4ID0gdGhpcy5wYXJlbnQuX3dyaXRlU3RyaW5nKHJlcywgb3V0SW5kZXgpO1xuICAgIH1cbiAgICByZXNbb3V0SW5kZXgrK10gPSBgKCR7dGhpcy5ydWxlSWR9LCAke3RoaXMubmFtZVNjb3Blc0xpc3Q/LnRvU3RyaW5nKCl9LCAke3RoaXMuY29udGVudE5hbWVTY29wZXNMaXN0Py50b1N0cmluZygpfSlgO1xuICAgIHJldHVybiBvdXRJbmRleDtcbiAgfVxuICB3aXRoQ29udGVudE5hbWVTY29wZXNMaXN0KGNvbnRlbnROYW1lU2NvcGVTdGFjaykge1xuICAgIGlmICh0aGlzLmNvbnRlbnROYW1lU2NvcGVzTGlzdCA9PT0gY29udGVudE5hbWVTY29wZVN0YWNrKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyZW50LnB1c2goXG4gICAgICB0aGlzLnJ1bGVJZCxcbiAgICAgIHRoaXMuX2VudGVyUG9zLFxuICAgICAgdGhpcy5fYW5jaG9yUG9zLFxuICAgICAgdGhpcy5iZWdpblJ1bGVDYXB0dXJlZEVPTCxcbiAgICAgIHRoaXMuZW5kUnVsZSxcbiAgICAgIHRoaXMubmFtZVNjb3Blc0xpc3QsXG4gICAgICBjb250ZW50TmFtZVNjb3BlU3RhY2tcbiAgICApO1xuICB9XG4gIHdpdGhFbmRSdWxlKGVuZFJ1bGUpIHtcbiAgICBpZiAodGhpcy5lbmRSdWxlID09PSBlbmRSdWxlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfU3RhdGVTdGFja0ltcGwoXG4gICAgICB0aGlzLnBhcmVudCxcbiAgICAgIHRoaXMucnVsZUlkLFxuICAgICAgdGhpcy5fZW50ZXJQb3MsXG4gICAgICB0aGlzLl9hbmNob3JQb3MsXG4gICAgICB0aGlzLmJlZ2luUnVsZUNhcHR1cmVkRU9MLFxuICAgICAgZW5kUnVsZSxcbiAgICAgIHRoaXMubmFtZVNjb3Blc0xpc3QsXG4gICAgICB0aGlzLmNvbnRlbnROYW1lU2NvcGVzTGlzdFxuICAgICk7XG4gIH1cbiAgLy8gVXNlZCB0byB3YXJuIG9mIGVuZGxlc3MgbG9vcHNcbiAgaGFzU2FtZVJ1bGVBcyhvdGhlcikge1xuICAgIGxldCBlbCA9IHRoaXM7XG4gICAgd2hpbGUgKGVsICYmIGVsLl9lbnRlclBvcyA9PT0gb3RoZXIuX2VudGVyUG9zKSB7XG4gICAgICBpZiAoZWwucnVsZUlkID09PSBvdGhlci5ydWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBlbCA9IGVsLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRvU3RhdGVTdGFja0ZyYW1lKCkge1xuICAgIHJldHVybiB7XG4gICAgICBydWxlSWQ6IHJ1bGVJZFRvTnVtYmVyKHRoaXMucnVsZUlkKSxcbiAgICAgIGJlZ2luUnVsZUNhcHR1cmVkRU9MOiB0aGlzLmJlZ2luUnVsZUNhcHR1cmVkRU9MLFxuICAgICAgZW5kUnVsZTogdGhpcy5lbmRSdWxlLFxuICAgICAgbmFtZVNjb3Blc0xpc3Q6IHRoaXMubmFtZVNjb3Blc0xpc3Q/LmdldEV4dGVuc2lvbklmRGVmaW5lZCh0aGlzLnBhcmVudD8ubmFtZVNjb3Blc0xpc3QgPz8gbnVsbCkgPz8gW10sXG4gICAgICBjb250ZW50TmFtZVNjb3Blc0xpc3Q6IHRoaXMuY29udGVudE5hbWVTY29wZXNMaXN0Py5nZXRFeHRlbnNpb25JZkRlZmluZWQodGhpcy5uYW1lU2NvcGVzTGlzdCkgPz8gW11cbiAgICB9O1xuICB9XG4gIHN0YXRpYyBwdXNoRnJhbWUoc2VsZiwgZnJhbWUpIHtcbiAgICBjb25zdCBuYW1lc1Njb3BlTGlzdCA9IEF0dHJpYnV0ZWRTY29wZVN0YWNrLmZyb21FeHRlbnNpb24oc2VsZj8ubmFtZVNjb3Blc0xpc3QgPz8gbnVsbCwgZnJhbWUubmFtZVNjb3Blc0xpc3QpO1xuICAgIHJldHVybiBuZXcgX1N0YXRlU3RhY2tJbXBsKFxuICAgICAgc2VsZixcbiAgICAgIHJ1bGVJZEZyb21OdW1iZXIoZnJhbWUucnVsZUlkKSxcbiAgICAgIGZyYW1lLmVudGVyUG9zID8/IC0xLFxuICAgICAgZnJhbWUuYW5jaG9yUG9zID8/IC0xLFxuICAgICAgZnJhbWUuYmVnaW5SdWxlQ2FwdHVyZWRFT0wsXG4gICAgICBmcmFtZS5lbmRSdWxlLFxuICAgICAgbmFtZXNTY29wZUxpc3QsXG4gICAgICBBdHRyaWJ1dGVkU2NvcGVTdGFjay5mcm9tRXh0ZW5zaW9uKG5hbWVzU2NvcGVMaXN0LCBmcmFtZS5jb250ZW50TmFtZVNjb3Blc0xpc3QpXG4gICAgKTtcbiAgfVxufTtcbnZhciBCYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMgPSBjbGFzcyB7XG4gIGJhbGFuY2VkQnJhY2tldFNjb3BlcztcbiAgdW5iYWxhbmNlZEJyYWNrZXRTY29wZXM7XG4gIGFsbG93QW55ID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKGJhbGFuY2VkQnJhY2tldFNjb3BlcywgdW5iYWxhbmNlZEJyYWNrZXRTY29wZXMpIHtcbiAgICB0aGlzLmJhbGFuY2VkQnJhY2tldFNjb3BlcyA9IGJhbGFuY2VkQnJhY2tldFNjb3Blcy5mbGF0TWFwKFxuICAgICAgKHNlbGVjdG9yKSA9PiB7XG4gICAgICAgIGlmIChzZWxlY3RvciA9PT0gXCIqXCIpIHtcbiAgICAgICAgICB0aGlzLmFsbG93QW55ID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZU1hdGNoZXJzKHNlbGVjdG9yLCBuYW1lTWF0Y2hlcikubWFwKChtKSA9PiBtLm1hdGNoZXIpO1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy51bmJhbGFuY2VkQnJhY2tldFNjb3BlcyA9IHVuYmFsYW5jZWRCcmFja2V0U2NvcGVzLmZsYXRNYXAoXG4gICAgICAoc2VsZWN0b3IpID0+IGNyZWF0ZU1hdGNoZXJzKHNlbGVjdG9yLCBuYW1lTWF0Y2hlcikubWFwKChtKSA9PiBtLm1hdGNoZXIpXG4gICAgKTtcbiAgfVxuICBnZXQgbWF0Y2hlc0Fsd2F5cygpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxvd0FueSAmJiB0aGlzLnVuYmFsYW5jZWRCcmFja2V0U2NvcGVzLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBnZXQgbWF0Y2hlc05ldmVyKCkge1xuICAgIHJldHVybiB0aGlzLmJhbGFuY2VkQnJhY2tldFNjb3Blcy5sZW5ndGggPT09IDAgJiYgIXRoaXMuYWxsb3dBbnk7XG4gIH1cbiAgbWF0Y2goc2NvcGVzKSB7XG4gICAgZm9yIChjb25zdCBleGNsdWRlciBvZiB0aGlzLnVuYmFsYW5jZWRCcmFja2V0U2NvcGVzKSB7XG4gICAgICBpZiAoZXhjbHVkZXIoc2NvcGVzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgaW5jbHVkZXIgb2YgdGhpcy5iYWxhbmNlZEJyYWNrZXRTY29wZXMpIHtcbiAgICAgIGlmIChpbmNsdWRlcihzY29wZXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hbGxvd0FueTtcbiAgfVxufTtcbnZhciBMaW5lVG9rZW5zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlbWl0QmluYXJ5VG9rZW5zLCBsaW5lVGV4dCwgdG9rZW5UeXBlT3ZlcnJpZGVzLCBiYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMpIHtcbiAgICB0aGlzLmJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycyA9IGJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycztcbiAgICB0aGlzLl9lbWl0QmluYXJ5VG9rZW5zID0gZW1pdEJpbmFyeVRva2VucztcbiAgICB0aGlzLl90b2tlblR5cGVPdmVycmlkZXMgPSB0b2tlblR5cGVPdmVycmlkZXM7XG4gICAgaWYgKGZhbHNlKSB7XG4gICAgICB0aGlzLl9saW5lVGV4dCA9IGxpbmVUZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9saW5lVGV4dCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3Rva2VucyA9IFtdO1xuICAgIHRoaXMuX2JpbmFyeVRva2VucyA9IFtdO1xuICAgIHRoaXMuX2xhc3RUb2tlbkVuZEluZGV4ID0gMDtcbiAgfVxuICBfZW1pdEJpbmFyeVRva2VucztcbiAgLyoqXG4gICAqIGRlZmluZWQgb25seSBpZiBgZmFsc2VgLlxuICAgKi9cbiAgX2xpbmVUZXh0O1xuICAvKipcbiAgICogdXNlZCBvbmx5IGlmIGBfZW1pdEJpbmFyeVRva2Vuc2AgaXMgZmFsc2UuXG4gICAqL1xuICBfdG9rZW5zO1xuICAvKipcbiAgICogdXNlZCBvbmx5IGlmIGBfZW1pdEJpbmFyeVRva2Vuc2AgaXMgdHJ1ZS5cbiAgICovXG4gIF9iaW5hcnlUb2tlbnM7XG4gIF9sYXN0VG9rZW5FbmRJbmRleDtcbiAgX3Rva2VuVHlwZU92ZXJyaWRlcztcbiAgcHJvZHVjZShzdGFjaywgZW5kSW5kZXgpIHtcbiAgICB0aGlzLnByb2R1Y2VGcm9tU2NvcGVzKHN0YWNrLmNvbnRlbnROYW1lU2NvcGVzTGlzdCwgZW5kSW5kZXgpO1xuICB9XG4gIHByb2R1Y2VGcm9tU2NvcGVzKHNjb3Blc0xpc3QsIGVuZEluZGV4KSB7XG4gICAgaWYgKHRoaXMuX2xhc3RUb2tlbkVuZEluZGV4ID49IGVuZEluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9lbWl0QmluYXJ5VG9rZW5zKSB7XG4gICAgICBsZXQgbWV0YWRhdGEgPSBzY29wZXNMaXN0Py50b2tlbkF0dHJpYnV0ZXMgPz8gMDtcbiAgICAgIGxldCBjb250YWluc0JhbGFuY2VkQnJhY2tldHMgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycz8ubWF0Y2hlc0Fsd2F5cykge1xuICAgICAgICBjb250YWluc0JhbGFuY2VkQnJhY2tldHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3Rva2VuVHlwZU92ZXJyaWRlcy5sZW5ndGggPiAwIHx8IHRoaXMuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzICYmICF0aGlzLmJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycy5tYXRjaGVzQWx3YXlzICYmICF0aGlzLmJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycy5tYXRjaGVzTmV2ZXIpIHtcbiAgICAgICAgY29uc3Qgc2NvcGVzMiA9IHNjb3Blc0xpc3Q/LmdldFNjb3BlTmFtZXMoKSA/PyBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0b2tlblR5cGUgb2YgdGhpcy5fdG9rZW5UeXBlT3ZlcnJpZGVzKSB7XG4gICAgICAgICAgaWYgKHRva2VuVHlwZS5tYXRjaGVyKHNjb3BlczIpKSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IEVuY29kZWRUb2tlbk1ldGFkYXRhLnNldChcbiAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIHRvT3B0aW9uYWxUb2tlblR5cGUodG9rZW5UeXBlLnR5cGUpLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAtMSAvKiBOb3RTZXQgKi8sXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJhbGFuY2VkQnJhY2tldFNlbGVjdG9ycykge1xuICAgICAgICAgIGNvbnRhaW5zQmFsYW5jZWRCcmFja2V0cyA9IHRoaXMuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzLm1hdGNoKHNjb3BlczIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzKSB7XG4gICAgICAgIG1ldGFkYXRhID0gRW5jb2RlZFRva2VuTWV0YWRhdGEuc2V0KFxuICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgOCAvKiBOb3RTZXQgKi8sXG4gICAgICAgICAgY29udGFpbnNCYWxhbmNlZEJyYWNrZXRzLFxuICAgICAgICAgIC0xIC8qIE5vdFNldCAqLyxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9iaW5hcnlUb2tlbnMubGVuZ3RoID4gMCAmJiB0aGlzLl9iaW5hcnlUb2tlbnNbdGhpcy5fYmluYXJ5VG9rZW5zLmxlbmd0aCAtIDFdID09PSBtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLl9sYXN0VG9rZW5FbmRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9iaW5hcnlUb2tlbnMucHVzaCh0aGlzLl9sYXN0VG9rZW5FbmRJbmRleCk7XG4gICAgICB0aGlzLl9iaW5hcnlUb2tlbnMucHVzaChtZXRhZGF0YSk7XG4gICAgICB0aGlzLl9sYXN0VG9rZW5FbmRJbmRleCA9IGVuZEluZGV4O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzY29wZXMgPSBzY29wZXNMaXN0Py5nZXRTY29wZU5hbWVzKCkgPz8gW107XG4gICAgdGhpcy5fdG9rZW5zLnB1c2goe1xuICAgICAgc3RhcnRJbmRleDogdGhpcy5fbGFzdFRva2VuRW5kSW5kZXgsXG4gICAgICBlbmRJbmRleCxcbiAgICAgIC8vIHZhbHVlOiBsaW5lVGV4dC5zdWJzdHJpbmcobGFzdFRva2VuRW5kSW5kZXgsIGVuZEluZGV4KSxcbiAgICAgIHNjb3Blc1xuICAgIH0pO1xuICAgIHRoaXMuX2xhc3RUb2tlbkVuZEluZGV4ID0gZW5kSW5kZXg7XG4gIH1cbiAgZ2V0UmVzdWx0KHN0YWNrLCBsaW5lTGVuZ3RoKSB7XG4gICAgaWYgKHRoaXMuX3Rva2Vucy5sZW5ndGggPiAwICYmIHRoaXMuX3Rva2Vuc1t0aGlzLl90b2tlbnMubGVuZ3RoIC0gMV0uc3RhcnRJbmRleCA9PT0gbGluZUxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuX3Rva2Vucy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3Rva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX2xhc3RUb2tlbkVuZEluZGV4ID0gLTE7XG4gICAgICB0aGlzLnByb2R1Y2Uoc3RhY2ssIGxpbmVMZW5ndGgpO1xuICAgICAgdGhpcy5fdG9rZW5zW3RoaXMuX3Rva2Vucy5sZW5ndGggLSAxXS5zdGFydEluZGV4ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Rva2VucztcbiAgfVxuICBnZXRCaW5hcnlSZXN1bHQoc3RhY2ssIGxpbmVMZW5ndGgpIHtcbiAgICBpZiAodGhpcy5fYmluYXJ5VG9rZW5zLmxlbmd0aCA+IDAgJiYgdGhpcy5fYmluYXJ5VG9rZW5zW3RoaXMuX2JpbmFyeVRva2Vucy5sZW5ndGggLSAyXSA9PT0gbGluZUxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuX2JpbmFyeVRva2Vucy5wb3AoKTtcbiAgICAgIHRoaXMuX2JpbmFyeVRva2Vucy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2JpbmFyeVRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX2xhc3RUb2tlbkVuZEluZGV4ID0gLTE7XG4gICAgICB0aGlzLnByb2R1Y2Uoc3RhY2ssIGxpbmVMZW5ndGgpO1xuICAgICAgdGhpcy5fYmluYXJ5VG9rZW5zW3RoaXMuX2JpbmFyeVRva2Vucy5sZW5ndGggLSAyXSA9IDA7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50MzJBcnJheSh0aGlzLl9iaW5hcnlUb2tlbnMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5fYmluYXJ5VG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSB0aGlzLl9iaW5hcnlUb2tlbnNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbi8vIHNyYy9yZWdpc3RyeS50c1xudmFyIFN5bmNSZWdpc3RyeSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodGhlbWUsIF9vbmlnTGliKSB7XG4gICAgdGhpcy5fb25pZ0xpYiA9IF9vbmlnTGliO1xuICAgIHRoaXMuX3RoZW1lID0gdGhlbWU7XG4gIH1cbiAgX2dyYW1tYXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX3Jhd0dyYW1tYXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX2luamVjdGlvbkdyYW1tYXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX3RoZW1lO1xuICBkaXNwb3NlKCkge1xuICAgIGZvciAoY29uc3QgZ3JhbW1hciBvZiB0aGlzLl9ncmFtbWFycy52YWx1ZXMoKSkge1xuICAgICAgZ3JhbW1hci5kaXNwb3NlKCk7XG4gICAgfVxuICB9XG4gIHNldFRoZW1lKHRoZW1lKSB7XG4gICAgdGhpcy5fdGhlbWUgPSB0aGVtZTtcbiAgfVxuICBnZXRDb2xvck1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGhlbWUuZ2V0Q29sb3JNYXAoKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGBncmFtbWFyYCB0byByZWdpc3RyeSBhbmQgcmV0dXJuIGEgbGlzdCBvZiByZWZlcmVuY2VkIHNjb3BlIG5hbWVzXG4gICAqL1xuICBhZGRHcmFtbWFyKGdyYW1tYXIsIGluamVjdGlvblNjb3BlTmFtZXMpIHtcbiAgICB0aGlzLl9yYXdHcmFtbWFycy5zZXQoZ3JhbW1hci5zY29wZU5hbWUsIGdyYW1tYXIpO1xuICAgIGlmIChpbmplY3Rpb25TY29wZU5hbWVzKSB7XG4gICAgICB0aGlzLl9pbmplY3Rpb25HcmFtbWFycy5zZXQoZ3JhbW1hci5zY29wZU5hbWUsIGluamVjdGlvblNjb3BlTmFtZXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTG9va3VwIGEgcmF3IGdyYW1tYXIuXG4gICAqL1xuICBsb29rdXAoc2NvcGVOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jhd0dyYW1tYXJzLmdldChzY29wZU5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmplY3Rpb25zIGZvciB0aGUgZ2l2ZW4gZ3JhbW1hclxuICAgKi9cbiAgaW5qZWN0aW9ucyh0YXJnZXRTY29wZSkge1xuICAgIHJldHVybiB0aGlzLl9pbmplY3Rpb25HcmFtbWFycy5nZXQodGFyZ2V0U2NvcGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgdGhlbWUgc2V0dGluZ3NcbiAgICovXG4gIGdldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLl90aGVtZS5nZXREZWZhdWx0cygpO1xuICB9XG4gIC8qKlxuICAgKiBNYXRjaCBhIHNjb3BlIGluIHRoZSB0aGVtZS5cbiAgICovXG4gIHRoZW1lTWF0Y2goc2NvcGVQYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RoZW1lLm1hdGNoKHNjb3BlUGF0aCk7XG4gIH1cbiAgLyoqXG4gICAqIExvb2t1cCBhIGdyYW1tYXIuXG4gICAqL1xuICBncmFtbWFyRm9yU2NvcGVOYW1lKHNjb3BlTmFtZSwgaW5pdGlhbExhbmd1YWdlLCBlbWJlZGRlZExhbmd1YWdlcywgdG9rZW5UeXBlcywgYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzKSB7XG4gICAgaWYgKCF0aGlzLl9ncmFtbWFycy5oYXMoc2NvcGVOYW1lKSkge1xuICAgICAgbGV0IHJhd0dyYW1tYXIgPSB0aGlzLl9yYXdHcmFtbWFycy5nZXQoc2NvcGVOYW1lKTtcbiAgICAgIGlmICghcmF3R3JhbW1hcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2dyYW1tYXJzLnNldChzY29wZU5hbWUsIGNyZWF0ZUdyYW1tYXIoXG4gICAgICAgIHNjb3BlTmFtZSxcbiAgICAgICAgcmF3R3JhbW1hcixcbiAgICAgICAgaW5pdGlhbExhbmd1YWdlLFxuICAgICAgICBlbWJlZGRlZExhbmd1YWdlcyxcbiAgICAgICAgdG9rZW5UeXBlcyxcbiAgICAgICAgYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzLFxuICAgICAgICB0aGlzLFxuICAgICAgICB0aGlzLl9vbmlnTGliXG4gICAgICApKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dyYW1tYXJzLmdldChzY29wZU5hbWUpO1xuICB9XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBSZWdpc3RyeSA9IGNsYXNzIHtcbiAgX29wdGlvbnM7XG4gIF9zeW5jUmVnaXN0cnk7XG4gIF9lbnN1cmVHcmFtbWFyQ2FjaGU7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9zeW5jUmVnaXN0cnkgPSBuZXcgU3luY1JlZ2lzdHJ5KFxuICAgICAgVGhlbWUuY3JlYXRlRnJvbVJhd1RoZW1lKG9wdGlvbnMudGhlbWUsIG9wdGlvbnMuY29sb3JNYXApLFxuICAgICAgb3B0aW9ucy5vbmlnTGliXG4gICAgKTtcbiAgICB0aGlzLl9lbnN1cmVHcmFtbWFyQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fc3luY1JlZ2lzdHJ5LmRpc3Bvc2UoKTtcbiAgfVxuICAvKipcbiAgICogQ2hhbmdlIHRoZSB0aGVtZS4gT25jZSBjYWxsZWQsIG5vIHByZXZpb3VzIGBydWxlU3RhY2tgIHNob3VsZCBiZSB1c2VkIGFueW1vcmUuXG4gICAqL1xuICBzZXRUaGVtZSh0aGVtZSwgY29sb3JNYXApIHtcbiAgICB0aGlzLl9zeW5jUmVnaXN0cnkuc2V0VGhlbWUoVGhlbWUuY3JlYXRlRnJvbVJhd1RoZW1lKHRoZW1lLCBjb2xvck1hcCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9va3VwIGFycmF5IGZvciBjb2xvciBpZHMuXG4gICAqL1xuICBnZXRDb2xvck1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3luY1JlZ2lzdHJ5LmdldENvbG9yTWFwKCk7XG4gIH1cbiAgLyoqXG4gICAqIExvYWQgdGhlIGdyYW1tYXIgZm9yIGBzY29wZU5hbWVgIGFuZCBhbGwgcmVmZXJlbmNlZCBpbmNsdWRlZCBncmFtbWFycyBhc3luY2hyb25vdXNseS5cbiAgICogUGxlYXNlIGRvIG5vdCB1c2UgbGFuZ3VhZ2UgaWQgMC5cbiAgICovXG4gIGxvYWRHcmFtbWFyV2l0aEVtYmVkZGVkTGFuZ3VhZ2VzKGluaXRpYWxTY29wZU5hbWUsIGluaXRpYWxMYW5ndWFnZSwgZW1iZWRkZWRMYW5ndWFnZXMpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkR3JhbW1hcldpdGhDb25maWd1cmF0aW9uKGluaXRpYWxTY29wZU5hbWUsIGluaXRpYWxMYW5ndWFnZSwgeyBlbWJlZGRlZExhbmd1YWdlcyB9KTtcbiAgfVxuICAvKipcbiAgICogTG9hZCB0aGUgZ3JhbW1hciBmb3IgYHNjb3BlTmFtZWAgYW5kIGFsbCByZWZlcmVuY2VkIGluY2x1ZGVkIGdyYW1tYXJzIGFzeW5jaHJvbm91c2x5LlxuICAgKiBQbGVhc2UgZG8gbm90IHVzZSBsYW5ndWFnZSBpZCAwLlxuICAgKi9cbiAgbG9hZEdyYW1tYXJXaXRoQ29uZmlndXJhdGlvbihpbml0aWFsU2NvcGVOYW1lLCBpbml0aWFsTGFuZ3VhZ2UsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5fbG9hZEdyYW1tYXIoXG4gICAgICBpbml0aWFsU2NvcGVOYW1lLFxuICAgICAgaW5pdGlhbExhbmd1YWdlLFxuICAgICAgY29uZmlndXJhdGlvbi5lbWJlZGRlZExhbmd1YWdlcyxcbiAgICAgIGNvbmZpZ3VyYXRpb24udG9rZW5UeXBlcyxcbiAgICAgIG5ldyBCYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMoXG4gICAgICAgIGNvbmZpZ3VyYXRpb24uYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzIHx8IFtdLFxuICAgICAgICBjb25maWd1cmF0aW9uLnVuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzIHx8IFtdXG4gICAgICApXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogTG9hZCB0aGUgZ3JhbW1hciBmb3IgYHNjb3BlTmFtZWAgYW5kIGFsbCByZWZlcmVuY2VkIGluY2x1ZGVkIGdyYW1tYXJzIGFzeW5jaHJvbm91c2x5LlxuICAgKi9cbiAgbG9hZEdyYW1tYXIoaW5pdGlhbFNjb3BlTmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9sb2FkR3JhbW1hcihpbml0aWFsU2NvcGVOYW1lLCAwLCBudWxsLCBudWxsLCBudWxsKTtcbiAgfVxuICBfbG9hZEdyYW1tYXIoaW5pdGlhbFNjb3BlTmFtZSwgaW5pdGlhbExhbmd1YWdlLCBlbWJlZGRlZExhbmd1YWdlcywgdG9rZW5UeXBlcywgYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzKSB7XG4gICAgY29uc3QgZGVwZW5kZW5jeVByb2Nlc3NvciA9IG5ldyBTY29wZURlcGVuZGVuY3lQcm9jZXNzb3IodGhpcy5fc3luY1JlZ2lzdHJ5LCBpbml0aWFsU2NvcGVOYW1lKTtcbiAgICB3aGlsZSAoZGVwZW5kZW5jeVByb2Nlc3Nvci5RLmxlbmd0aCA+IDApIHtcbiAgICAgIGRlcGVuZGVuY3lQcm9jZXNzb3IuUS5tYXAoKHJlcXVlc3QpID0+IHRoaXMuX2xvYWRTaW5nbGVHcmFtbWFyKHJlcXVlc3Quc2NvcGVOYW1lKSk7XG4gICAgICBkZXBlbmRlbmN5UHJvY2Vzc29yLnByb2Nlc3NRdWV1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZ3JhbW1hckZvclNjb3BlTmFtZShcbiAgICAgIGluaXRpYWxTY29wZU5hbWUsXG4gICAgICBpbml0aWFsTGFuZ3VhZ2UsXG4gICAgICBlbWJlZGRlZExhbmd1YWdlcyxcbiAgICAgIHRva2VuVHlwZXMsXG4gICAgICBiYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnNcbiAgICApO1xuICB9XG4gIF9sb2FkU2luZ2xlR3JhbW1hcihzY29wZU5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2Vuc3VyZUdyYW1tYXJDYWNoZS5oYXMoc2NvcGVOYW1lKSkge1xuICAgICAgdGhpcy5fZG9Mb2FkU2luZ2xlR3JhbW1hcihzY29wZU5hbWUpO1xuICAgICAgdGhpcy5fZW5zdXJlR3JhbW1hckNhY2hlLnNldChzY29wZU5hbWUsIHRydWUpO1xuICAgIH1cbiAgfVxuICBfZG9Mb2FkU2luZ2xlR3JhbW1hcihzY29wZU5hbWUpIHtcbiAgICBjb25zdCBncmFtbWFyID0gdGhpcy5fb3B0aW9ucy5sb2FkR3JhbW1hcihzY29wZU5hbWUpO1xuICAgIGlmIChncmFtbWFyKSB7XG4gICAgICBjb25zdCBpbmplY3Rpb25zID0gdHlwZW9mIHRoaXMuX29wdGlvbnMuZ2V0SW5qZWN0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy5fb3B0aW9ucy5nZXRJbmplY3Rpb25zKHNjb3BlTmFtZSkgOiB2b2lkIDA7XG4gICAgICB0aGlzLl9zeW5jUmVnaXN0cnkuYWRkR3JhbW1hcihncmFtbWFyLCBpbmplY3Rpb25zKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSByYXdHcmFtbWFyLlxuICAgKi9cbiAgYWRkR3JhbW1hcihyYXdHcmFtbWFyLCBpbmplY3Rpb25zID0gW10sIGluaXRpYWxMYW5ndWFnZSA9IDAsIGVtYmVkZGVkTGFuZ3VhZ2VzID0gbnVsbCkge1xuICAgIHRoaXMuX3N5bmNSZWdpc3RyeS5hZGRHcmFtbWFyKHJhd0dyYW1tYXIsIGluamVjdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLl9ncmFtbWFyRm9yU2NvcGVOYW1lKHJhd0dyYW1tYXIuc2NvcGVOYW1lLCBpbml0aWFsTGFuZ3VhZ2UsIGVtYmVkZGVkTGFuZ3VhZ2VzKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBncmFtbWFyIGZvciBgc2NvcGVOYW1lYC4gVGhlIGdyYW1tYXIgbXVzdCBmaXJzdCBiZSBjcmVhdGVkIHZpYSBgbG9hZEdyYW1tYXJgIG9yIGBhZGRHcmFtbWFyYC5cbiAgICovXG4gIF9ncmFtbWFyRm9yU2NvcGVOYW1lKHNjb3BlTmFtZSwgaW5pdGlhbExhbmd1YWdlID0gMCwgZW1iZWRkZWRMYW5ndWFnZXMgPSBudWxsLCB0b2tlblR5cGVzID0gbnVsbCwgYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzID0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9zeW5jUmVnaXN0cnkuZ3JhbW1hckZvclNjb3BlTmFtZShcbiAgICAgIHNjb3BlTmFtZSxcbiAgICAgIGluaXRpYWxMYW5ndWFnZSxcbiAgICAgIGVtYmVkZGVkTGFuZ3VhZ2VzLFxuICAgICAgdG9rZW5UeXBlcyxcbiAgICAgIGJhbGFuY2VkQnJhY2tldFNlbGVjdG9yc1xuICAgICk7XG4gIH1cbn07XG52YXIgSU5JVElBTCA9IFN0YXRlU3RhY2tJbXBsLk5VTEw7XG5leHBvcnQge1xuICBFbmNvZGVkVG9rZW5NZXRhZGF0YSxcbiAgRmluZE9wdGlvbixcbiAgRm9udFN0eWxlLFxuICBJTklUSUFMLFxuICBSZWdpc3RyeSxcbiAgVGhlbWUsXG4gIGRpc3Bvc2VPbmlnU3RyaW5nXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@shikijs+vscode-textmate@10.0.2/node_modules/@shikijs/vscode-textmate/dist/index.js\n");

/***/ })

};
;