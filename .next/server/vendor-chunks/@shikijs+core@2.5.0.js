"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@shikijs+core@2.5.0";
exports.ids = ["vendor-chunks/@shikijs+core@2.5.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@shikijs+core@2.5.0/node_modules/@shikijs/core/dist/index.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@shikijs+core@2.5.0/node_modules/@shikijs/core/dist/index.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FontStyle: () => (/* reexport safe */ _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle),\n/* harmony export */   ShikiError: () => (/* reexport safe */ _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError),\n/* harmony export */   StackElementMetadata: () => (/* reexport safe */ _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.EncodedTokenMetadata),\n/* harmony export */   addClassToHast: () => (/* binding */ addClassToHast),\n/* harmony export */   applyColorReplacements: () => (/* binding */ applyColorReplacements),\n/* harmony export */   codeToHast: () => (/* binding */ codeToHast),\n/* harmony export */   codeToHtml: () => (/* binding */ codeToHtml),\n/* harmony export */   codeToTokens: () => (/* binding */ codeToTokens),\n/* harmony export */   codeToTokensBase: () => (/* binding */ codeToTokensBase),\n/* harmony export */   codeToTokensWithThemes: () => (/* binding */ codeToTokensWithThemes),\n/* harmony export */   createCssVariablesTheme: () => (/* binding */ createCssVariablesTheme),\n/* harmony export */   createHighlighterCore: () => (/* binding */ createHighlighterCore),\n/* harmony export */   createHighlighterCoreSync: () => (/* binding */ createHighlighterCoreSync),\n/* harmony export */   createJavaScriptRegexEngine: () => (/* binding */ createJavaScriptRegexEngine),\n/* harmony export */   createOnigurumaEngine: () => (/* binding */ createOnigurumaEngine),\n/* harmony export */   createPositionConverter: () => (/* binding */ createPositionConverter),\n/* harmony export */   createShikiInternal: () => (/* binding */ createShikiInternal),\n/* harmony export */   createShikiInternalSync: () => (/* binding */ createShikiInternalSync),\n/* harmony export */   createSingletonShorthands: () => (/* binding */ createSingletonShorthands),\n/* harmony export */   createWasmOnigEngine: () => (/* binding */ createWasmOnigEngine),\n/* harmony export */   createdBundledHighlighter: () => (/* binding */ createdBundledHighlighter),\n/* harmony export */   defaultJavaScriptRegexConstructor: () => (/* binding */ defaultJavaScriptRegexConstructor),\n/* harmony export */   enableDeprecationWarnings: () => (/* reexport safe */ _shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.e),\n/* harmony export */   flatTokenVariants: () => (/* binding */ flatTokenVariants),\n/* harmony export */   getHighlighterCore: () => (/* binding */ getHighlighterCore),\n/* harmony export */   getShikiInternal: () => (/* binding */ getShikiInternal),\n/* harmony export */   getSingletonHighlighterCore: () => (/* binding */ getSingletonHighlighterCore),\n/* harmony export */   getTokenStyleObject: () => (/* binding */ getTokenStyleObject),\n/* harmony export */   guessEmbeddedLanguages: () => (/* binding */ guessEmbeddedLanguages),\n/* harmony export */   hastToHtml: () => (/* reexport safe */ hast_util_to_html__WEBPACK_IMPORTED_MODULE_3__.toHtml),\n/* harmony export */   isNoneTheme: () => (/* binding */ isNoneTheme),\n/* harmony export */   isPlainLang: () => (/* binding */ isPlainLang),\n/* harmony export */   isSpecialLang: () => (/* binding */ isSpecialLang),\n/* harmony export */   isSpecialTheme: () => (/* binding */ isSpecialTheme),\n/* harmony export */   loadWasm: () => (/* binding */ loadWasm),\n/* harmony export */   makeSingletonHighlighter: () => (/* binding */ makeSingletonHighlighter),\n/* harmony export */   makeSingletonHighlighterCore: () => (/* binding */ makeSingletonHighlighterCore),\n/* harmony export */   normalizeGetter: () => (/* binding */ normalizeGetter),\n/* harmony export */   normalizeTheme: () => (/* binding */ normalizeTheme),\n/* harmony export */   resolveColorReplacements: () => (/* binding */ resolveColorReplacements),\n/* harmony export */   splitLines: () => (/* binding */ splitLines),\n/* harmony export */   splitToken: () => (/* binding */ splitToken),\n/* harmony export */   splitTokens: () => (/* binding */ splitTokens),\n/* harmony export */   stringifyTokenStyle: () => (/* binding */ stringifyTokenStyle),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   tokenizeAnsiWithTheme: () => (/* binding */ tokenizeAnsiWithTheme),\n/* harmony export */   tokenizeWithTheme: () => (/* binding */ tokenizeWithTheme),\n/* harmony export */   tokensToHast: () => (/* binding */ tokensToHast),\n/* harmony export */   transformerDecorations: () => (/* binding */ transformerDecorations),\n/* harmony export */   warnDeprecated: () => (/* reexport safe */ _shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)\n/* harmony export */ });\n/* harmony import */ var _shikijs_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @shikijs/types */ \"(rsc)/./node_modules/.pnpm/@shikijs+types@2.5.0/node_modules/@shikijs/types/dist/index.mjs\");\n/* harmony import */ var _shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @shikijs/engine-oniguruma */ \"(rsc)/./node_modules/.pnpm/@shikijs+engine-oniguruma@2.5.0/node_modules/@shikijs/engine-oniguruma/dist/index.mjs\");\n/* harmony import */ var _shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shared/core.5hv0Law9.mjs */ \"(rsc)/./node_modules/.pnpm/@shikijs+core@2.5.0/node_modules/@shikijs/core/dist/shared/core.5hv0Law9.mjs\");\n/* harmony import */ var _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @shikijs/vscode-textmate */ \"(rsc)/./node_modules/.pnpm/@shikijs+vscode-textmate@10.0.2/node_modules/@shikijs/vscode-textmate/dist/index.js\");\n/* harmony import */ var hast_util_to_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! hast-util-to-html */ \"(rsc)/./node_modules/.pnpm/hast-util-to-html@9.0.5/node_modules/hast-util-to-html/lib/index.js\");\n/* harmony import */ var _shikijs_engine_javascript__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @shikijs/engine-javascript */ \"(rsc)/./node_modules/.pnpm/@shikijs+engine-javascript@2.5.0/node_modules/@shikijs/engine-javascript/dist/engine-compile.mjs\");\n\n\n\n\n\n\n\n\n\n\n\nfunction createOnigurumaEngine(options) {\n  (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"import `createOnigurumaEngine` from `@shikijs/engine-oniguruma` or `shiki/engine/oniguruma` instead\");\n  return (0,_shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__.createOnigurumaEngine)(options);\n}\nfunction createWasmOnigEngine(options) {\n  (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"import `createOnigurumaEngine` from `@shikijs/engine-oniguruma` or `shiki/engine/oniguruma` instead\");\n  return (0,_shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__.createOnigurumaEngine)(options);\n}\nfunction loadWasm(options) {\n  (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"import `loadWasm` from `@shikijs/engine-oniguruma` or `shiki/engine/oniguruma` instead\");\n  return (0,_shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__.loadWasm)(options);\n}\n\nfunction resolveColorReplacements(theme, options) {\n  const replacements = typeof theme === \"string\" ? {} : { ...theme.colorReplacements };\n  const themeName = typeof theme === \"string\" ? theme : theme.name;\n  for (const [key, value] of Object.entries(options?.colorReplacements || {})) {\n    if (typeof value === \"string\")\n      replacements[key] = value;\n    else if (key === themeName)\n      Object.assign(replacements, value);\n  }\n  return replacements;\n}\nfunction applyColorReplacements(color, replacements) {\n  if (!color)\n    return color;\n  return replacements?.[color?.toLowerCase()] || color;\n}\n\nfunction toArray(x) {\n  return Array.isArray(x) ? x : [x];\n}\nasync function normalizeGetter(p) {\n  return Promise.resolve(typeof p === \"function\" ? p() : p).then((r) => r.default || r);\n}\nfunction isPlainLang(lang) {\n  return !lang || [\"plaintext\", \"txt\", \"text\", \"plain\"].includes(lang);\n}\nfunction isSpecialLang(lang) {\n  return lang === \"ansi\" || isPlainLang(lang);\n}\nfunction isNoneTheme(theme) {\n  return theme === \"none\";\n}\nfunction isSpecialTheme(theme) {\n  return isNoneTheme(theme);\n}\n\nfunction addClassToHast(node, className) {\n  if (!className)\n    return node;\n  node.properties ||= {};\n  node.properties.class ||= [];\n  if (typeof node.properties.class === \"string\")\n    node.properties.class = node.properties.class.split(/\\s+/g);\n  if (!Array.isArray(node.properties.class))\n    node.properties.class = [];\n  const targets = Array.isArray(className) ? className : className.split(/\\s+/g);\n  for (const c of targets) {\n    if (c && !node.properties.class.includes(c))\n      node.properties.class.push(c);\n  }\n  return node;\n}\n\nfunction splitLines(code, preserveEnding = false) {\n  const parts = code.split(/(\\r?\\n)/g);\n  let index = 0;\n  const lines = [];\n  for (let i = 0; i < parts.length; i += 2) {\n    const line = preserveEnding ? parts[i] + (parts[i + 1] || \"\") : parts[i];\n    lines.push([line, index]);\n    index += parts[i].length;\n    index += parts[i + 1]?.length || 0;\n  }\n  return lines;\n}\nfunction createPositionConverter(code) {\n  const lines = splitLines(code, true).map(([line]) => line);\n  function indexToPos(index) {\n    if (index === code.length) {\n      return {\n        line: lines.length - 1,\n        character: lines[lines.length - 1].length\n      };\n    }\n    let character = index;\n    let line = 0;\n    for (const lineText of lines) {\n      if (character < lineText.length)\n        break;\n      character -= lineText.length;\n      line++;\n    }\n    return { line, character };\n  }\n  function posToIndex(line, character) {\n    let index = 0;\n    for (let i = 0; i < line; i++)\n      index += lines[i].length;\n    index += character;\n    return index;\n  }\n  return {\n    lines,\n    indexToPos,\n    posToIndex\n  };\n}\nfunction guessEmbeddedLanguages(code, _lang, highlighter) {\n  const langs = /* @__PURE__ */ new Set();\n  for (const match of code.matchAll(/lang=[\"']([\\w-]+)[\"']/g)) {\n    langs.add(match[1]);\n  }\n  for (const match of code.matchAll(/(?:```|~~~)([\\w-]+)/g)) {\n    langs.add(match[1]);\n  }\n  for (const match of code.matchAll(/\\\\begin\\{([\\w-]+)\\}/g)) {\n    langs.add(match[1]);\n  }\n  if (!highlighter)\n    return Array.from(langs);\n  const bundle = highlighter.getBundledLanguages();\n  return Array.from(langs).filter((l) => l && bundle[l]);\n}\n\nfunction splitToken(token, offsets) {\n  let lastOffset = 0;\n  const tokens = [];\n  for (const offset of offsets) {\n    if (offset > lastOffset) {\n      tokens.push({\n        ...token,\n        content: token.content.slice(lastOffset, offset),\n        offset: token.offset + lastOffset\n      });\n    }\n    lastOffset = offset;\n  }\n  if (lastOffset < token.content.length) {\n    tokens.push({\n      ...token,\n      content: token.content.slice(lastOffset),\n      offset: token.offset + lastOffset\n    });\n  }\n  return tokens;\n}\nfunction splitTokens(tokens, breakpoints) {\n  const sorted = Array.from(breakpoints instanceof Set ? breakpoints : new Set(breakpoints)).sort((a, b) => a - b);\n  if (!sorted.length)\n    return tokens;\n  return tokens.map((line) => {\n    return line.flatMap((token) => {\n      const breakpointsInToken = sorted.filter((i) => token.offset < i && i < token.offset + token.content.length).map((i) => i - token.offset).sort((a, b) => a - b);\n      if (!breakpointsInToken.length)\n        return token;\n      return splitToken(token, breakpointsInToken);\n    });\n  });\n}\nfunction flatTokenVariants(merged, variantsOrder, cssVariablePrefix, defaultColor) {\n  const token = {\n    content: merged.content,\n    explanation: merged.explanation,\n    offset: merged.offset\n  };\n  const styles = variantsOrder.map((t) => getTokenStyleObject(merged.variants[t]));\n  const styleKeys = new Set(styles.flatMap((t) => Object.keys(t)));\n  const mergedStyles = {};\n  styles.forEach((cur, idx) => {\n    for (const key of styleKeys) {\n      const value = cur[key] || \"inherit\";\n      if (idx === 0 && defaultColor) {\n        mergedStyles[key] = value;\n      } else {\n        const keyName = key === \"color\" ? \"\" : key === \"background-color\" ? \"-bg\" : `-${key}`;\n        const varKey = cssVariablePrefix + variantsOrder[idx] + (key === \"color\" ? \"\" : keyName);\n        mergedStyles[varKey] = value;\n      }\n    }\n  });\n  token.htmlStyle = mergedStyles;\n  return token;\n}\nfunction getTokenStyleObject(token) {\n  const styles = {};\n  if (token.color)\n    styles.color = token.color;\n  if (token.bgColor)\n    styles[\"background-color\"] = token.bgColor;\n  if (token.fontStyle) {\n    if (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Italic)\n      styles[\"font-style\"] = \"italic\";\n    if (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Bold)\n      styles[\"font-weight\"] = \"bold\";\n    if (token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Underline)\n      styles[\"text-decoration\"] = \"underline\";\n  }\n  return styles;\n}\nfunction stringifyTokenStyle(token) {\n  if (typeof token === \"string\")\n    return token;\n  return Object.entries(token).map(([key, value]) => `${key}:${value}`).join(\";\");\n}\n\nconst _grammarStateMap = /* @__PURE__ */ new WeakMap();\nfunction setLastGrammarStateToMap(keys, state) {\n  _grammarStateMap.set(keys, state);\n}\nfunction getLastGrammarStateFromMap(keys) {\n  return _grammarStateMap.get(keys);\n}\nclass GrammarState {\n  /**\n   * Theme to Stack mapping\n   */\n  _stacks = {};\n  lang;\n  get themes() {\n    return Object.keys(this._stacks);\n  }\n  get theme() {\n    return this.themes[0];\n  }\n  get _stack() {\n    return this._stacks[this.theme];\n  }\n  /**\n   * Static method to create a initial grammar state.\n   */\n  static initial(lang, themes) {\n    return new GrammarState(\n      Object.fromEntries(toArray(themes).map((theme) => [theme, _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.INITIAL])),\n      lang\n    );\n  }\n  constructor(...args) {\n    if (args.length === 2) {\n      const [stacksMap, lang] = args;\n      this.lang = lang;\n      this._stacks = stacksMap;\n    } else {\n      const [stack, lang, theme] = args;\n      this.lang = lang;\n      this._stacks = { [theme]: stack };\n    }\n  }\n  /**\n   * Get the internal stack object.\n   * @internal\n   */\n  getInternalStack(theme = this.theme) {\n    return this._stacks[theme];\n  }\n  /**\n   * @deprecated use `getScopes` instead\n   */\n  get scopes() {\n    (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"GrammarState.scopes is deprecated, use GrammarState.getScopes() instead\");\n    return getScopes(this._stacks[this.theme]);\n  }\n  getScopes(theme = this.theme) {\n    return getScopes(this._stacks[theme]);\n  }\n  toJSON() {\n    return {\n      lang: this.lang,\n      theme: this.theme,\n      themes: this.themes,\n      scopes: this.getScopes()\n    };\n  }\n}\nfunction getScopes(stack) {\n  const scopes = [];\n  const visited = /* @__PURE__ */ new Set();\n  function pushScope(stack2) {\n    if (visited.has(stack2))\n      return;\n    visited.add(stack2);\n    const name = stack2?.nameScopesList?.scopeName;\n    if (name)\n      scopes.push(name);\n    if (stack2.parent)\n      pushScope(stack2.parent);\n  }\n  pushScope(stack);\n  return scopes;\n}\nfunction getGrammarStack(state, theme) {\n  if (!(state instanceof GrammarState))\n    throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"Invalid grammar state\");\n  return state.getInternalStack(theme);\n}\n\nfunction transformerDecorations() {\n  const map = /* @__PURE__ */ new WeakMap();\n  function getContext(shiki) {\n    if (!map.has(shiki.meta)) {\n      let normalizePosition = function(p) {\n        if (typeof p === \"number\") {\n          if (p < 0 || p > shiki.source.length)\n            throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Invalid decoration offset: ${p}. Code length: ${shiki.source.length}`);\n          return {\n            ...converter.indexToPos(p),\n            offset: p\n          };\n        } else {\n          const line = converter.lines[p.line];\n          if (line === void 0)\n            throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Invalid decoration position ${JSON.stringify(p)}. Lines length: ${converter.lines.length}`);\n          if (p.character < 0 || p.character > line.length)\n            throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Invalid decoration position ${JSON.stringify(p)}. Line ${p.line} length: ${line.length}`);\n          return {\n            ...p,\n            offset: converter.posToIndex(p.line, p.character)\n          };\n        }\n      };\n      const converter = createPositionConverter(shiki.source);\n      const decorations = (shiki.options.decorations || []).map((d) => ({\n        ...d,\n        start: normalizePosition(d.start),\n        end: normalizePosition(d.end)\n      }));\n      verifyIntersections(decorations);\n      map.set(shiki.meta, {\n        decorations,\n        converter,\n        source: shiki.source\n      });\n    }\n    return map.get(shiki.meta);\n  }\n  return {\n    name: \"shiki:decorations\",\n    tokens(tokens) {\n      if (!this.options.decorations?.length)\n        return;\n      const ctx = getContext(this);\n      const breakpoints = ctx.decorations.flatMap((d) => [d.start.offset, d.end.offset]);\n      const splitted = splitTokens(tokens, breakpoints);\n      return splitted;\n    },\n    code(codeEl) {\n      if (!this.options.decorations?.length)\n        return;\n      const ctx = getContext(this);\n      const lines = Array.from(codeEl.children).filter((i) => i.type === \"element\" && i.tagName === \"span\");\n      if (lines.length !== ctx.converter.lines.length)\n        throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Number of lines in code element (${lines.length}) does not match the number of lines in the source (${ctx.converter.lines.length}). Failed to apply decorations.`);\n      function applyLineSection(line, start, end, decoration) {\n        const lineEl = lines[line];\n        let text = \"\";\n        let startIndex = -1;\n        let endIndex = -1;\n        if (start === 0)\n          startIndex = 0;\n        if (end === 0)\n          endIndex = 0;\n        if (end === Number.POSITIVE_INFINITY)\n          endIndex = lineEl.children.length;\n        if (startIndex === -1 || endIndex === -1) {\n          for (let i = 0; i < lineEl.children.length; i++) {\n            text += stringify(lineEl.children[i]);\n            if (startIndex === -1 && text.length === start)\n              startIndex = i + 1;\n            if (endIndex === -1 && text.length === end)\n              endIndex = i + 1;\n          }\n        }\n        if (startIndex === -1)\n          throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Failed to find start index for decoration ${JSON.stringify(decoration.start)}`);\n        if (endIndex === -1)\n          throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Failed to find end index for decoration ${JSON.stringify(decoration.end)}`);\n        const children = lineEl.children.slice(startIndex, endIndex);\n        if (!decoration.alwaysWrap && children.length === lineEl.children.length) {\n          applyDecoration(lineEl, decoration, \"line\");\n        } else if (!decoration.alwaysWrap && children.length === 1 && children[0].type === \"element\") {\n          applyDecoration(children[0], decoration, \"token\");\n        } else {\n          const wrapper = {\n            type: \"element\",\n            tagName: \"span\",\n            properties: {},\n            children\n          };\n          applyDecoration(wrapper, decoration, \"wrapper\");\n          lineEl.children.splice(startIndex, children.length, wrapper);\n        }\n      }\n      function applyLine(line, decoration) {\n        lines[line] = applyDecoration(lines[line], decoration, \"line\");\n      }\n      function applyDecoration(el, decoration, type) {\n        const properties = decoration.properties || {};\n        const transform = decoration.transform || ((i) => i);\n        el.tagName = decoration.tagName || \"span\";\n        el.properties = {\n          ...el.properties,\n          ...properties,\n          class: el.properties.class\n        };\n        if (decoration.properties?.class)\n          addClassToHast(el, decoration.properties.class);\n        el = transform(el, type) || el;\n        return el;\n      }\n      const lineApplies = [];\n      const sorted = ctx.decorations.sort((a, b) => b.start.offset - a.start.offset || a.end.offset - b.end.offset);\n      for (const decoration of sorted) {\n        const { start, end } = decoration;\n        if (start.line === end.line) {\n          applyLineSection(start.line, start.character, end.character, decoration);\n        } else if (start.line < end.line) {\n          applyLineSection(start.line, start.character, Number.POSITIVE_INFINITY, decoration);\n          for (let i = start.line + 1; i < end.line; i++)\n            lineApplies.unshift(() => applyLine(i, decoration));\n          applyLineSection(end.line, 0, end.character, decoration);\n        }\n      }\n      lineApplies.forEach((i) => i());\n    }\n  };\n}\nfunction verifyIntersections(items) {\n  for (let i = 0; i < items.length; i++) {\n    const foo = items[i];\n    if (foo.start.offset > foo.end.offset)\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Invalid decoration range: ${JSON.stringify(foo.start)} - ${JSON.stringify(foo.end)}`);\n    for (let j = i + 1; j < items.length; j++) {\n      const bar = items[j];\n      const isFooHasBarStart = foo.start.offset <= bar.start.offset && bar.start.offset < foo.end.offset;\n      const isFooHasBarEnd = foo.start.offset < bar.end.offset && bar.end.offset <= foo.end.offset;\n      const isBarHasFooStart = bar.start.offset <= foo.start.offset && foo.start.offset < bar.end.offset;\n      const isBarHasFooEnd = bar.start.offset < foo.end.offset && foo.end.offset <= bar.end.offset;\n      if (isFooHasBarStart || isFooHasBarEnd || isBarHasFooStart || isBarHasFooEnd) {\n        if (isFooHasBarStart && isFooHasBarEnd)\n          continue;\n        if (isBarHasFooStart && isBarHasFooEnd)\n          continue;\n        throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Decorations ${JSON.stringify(foo.start)} and ${JSON.stringify(bar.start)} intersect.`);\n      }\n    }\n  }\n}\nfunction stringify(el) {\n  if (el.type === \"text\")\n    return el.value;\n  if (el.type === \"element\")\n    return el.children.map(stringify).join(\"\");\n  return \"\";\n}\n\nconst builtInTransformers = [\n  /* @__PURE__ */ transformerDecorations()\n];\nfunction getTransformers(options) {\n  return [\n    ...options.transformers || [],\n    ...builtInTransformers\n  ];\n}\n\n// src/colors.ts\nvar namedColors = [\n  \"black\",\n  \"red\",\n  \"green\",\n  \"yellow\",\n  \"blue\",\n  \"magenta\",\n  \"cyan\",\n  \"white\",\n  \"brightBlack\",\n  \"brightRed\",\n  \"brightGreen\",\n  \"brightYellow\",\n  \"brightBlue\",\n  \"brightMagenta\",\n  \"brightCyan\",\n  \"brightWhite\"\n];\n\n// src/decorations.ts\nvar decorations = {\n  1: \"bold\",\n  2: \"dim\",\n  3: \"italic\",\n  4: \"underline\",\n  7: \"reverse\",\n  8: \"hidden\",\n  9: \"strikethrough\"\n};\n\n// src/parser.ts\nfunction findSequence(value, position) {\n  const nextEscape = value.indexOf(\"\\x1B\", position);\n  if (nextEscape !== -1) {\n    if (value[nextEscape + 1] === \"[\") {\n      const nextClose = value.indexOf(\"m\", nextEscape);\n      if (nextClose !== -1) {\n        return {\n          sequence: value.substring(nextEscape + 2, nextClose).split(\";\"),\n          startPosition: nextEscape,\n          position: nextClose + 1\n        };\n      }\n    }\n  }\n  return {\n    position: value.length\n  };\n}\nfunction parseColor(sequence) {\n  const colorMode = sequence.shift();\n  if (colorMode === \"2\") {\n    const rgb = sequence.splice(0, 3).map((x) => Number.parseInt(x));\n    if (rgb.length !== 3 || rgb.some((x) => Number.isNaN(x)))\n      return;\n    return {\n      type: \"rgb\",\n      rgb\n    };\n  } else if (colorMode === \"5\") {\n    const index = sequence.shift();\n    if (index) {\n      return { type: \"table\", index: Number(index) };\n    }\n  }\n}\nfunction parseSequence(sequence) {\n  const commands = [];\n  while (sequence.length > 0) {\n    const code = sequence.shift();\n    if (!code)\n      continue;\n    const codeInt = Number.parseInt(code);\n    if (Number.isNaN(codeInt))\n      continue;\n    if (codeInt === 0) {\n      commands.push({ type: \"resetAll\" });\n    } else if (codeInt <= 9) {\n      const decoration = decorations[codeInt];\n      if (decoration) {\n        commands.push({\n          type: \"setDecoration\",\n          value: decorations[codeInt]\n        });\n      }\n    } else if (codeInt <= 29) {\n      const decoration = decorations[codeInt - 20];\n      if (decoration) {\n        commands.push({\n          type: \"resetDecoration\",\n          value: decoration\n        });\n        if (decoration === \"dim\") {\n          commands.push({\n            type: \"resetDecoration\",\n            value: \"bold\"\n          });\n        }\n      }\n    } else if (codeInt <= 37) {\n      commands.push({\n        type: \"setForegroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 30] }\n      });\n    } else if (codeInt === 38) {\n      const color = parseColor(sequence);\n      if (color) {\n        commands.push({\n          type: \"setForegroundColor\",\n          value: color\n        });\n      }\n    } else if (codeInt === 39) {\n      commands.push({\n        type: \"resetForegroundColor\"\n      });\n    } else if (codeInt <= 47) {\n      commands.push({\n        type: \"setBackgroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 40] }\n      });\n    } else if (codeInt === 48) {\n      const color = parseColor(sequence);\n      if (color) {\n        commands.push({\n          type: \"setBackgroundColor\",\n          value: color\n        });\n      }\n    } else if (codeInt === 49) {\n      commands.push({\n        type: \"resetBackgroundColor\"\n      });\n    } else if (codeInt === 53) {\n      commands.push({\n        type: \"setDecoration\",\n        value: \"overline\"\n      });\n    } else if (codeInt === 55) {\n      commands.push({\n        type: \"resetDecoration\",\n        value: \"overline\"\n      });\n    } else if (codeInt >= 90 && codeInt <= 97) {\n      commands.push({\n        type: \"setForegroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 90 + 8] }\n      });\n    } else if (codeInt >= 100 && codeInt <= 107) {\n      commands.push({\n        type: \"setBackgroundColor\",\n        value: { type: \"named\", name: namedColors[codeInt - 100 + 8] }\n      });\n    }\n  }\n  return commands;\n}\nfunction createAnsiSequenceParser() {\n  let foreground = null;\n  let background = null;\n  let decorations2 = /* @__PURE__ */ new Set();\n  return {\n    parse(value) {\n      const tokens = [];\n      let position = 0;\n      do {\n        const findResult = findSequence(value, position);\n        const text = findResult.sequence ? value.substring(position, findResult.startPosition) : value.substring(position);\n        if (text.length > 0) {\n          tokens.push({\n            value: text,\n            foreground,\n            background,\n            decorations: new Set(decorations2)\n          });\n        }\n        if (findResult.sequence) {\n          const commands = parseSequence(findResult.sequence);\n          for (const styleToken of commands) {\n            if (styleToken.type === \"resetAll\") {\n              foreground = null;\n              background = null;\n              decorations2.clear();\n            } else if (styleToken.type === \"resetForegroundColor\") {\n              foreground = null;\n            } else if (styleToken.type === \"resetBackgroundColor\") {\n              background = null;\n            } else if (styleToken.type === \"resetDecoration\") {\n              decorations2.delete(styleToken.value);\n            }\n          }\n          for (const styleToken of commands) {\n            if (styleToken.type === \"setForegroundColor\") {\n              foreground = styleToken.value;\n            } else if (styleToken.type === \"setBackgroundColor\") {\n              background = styleToken.value;\n            } else if (styleToken.type === \"setDecoration\") {\n              decorations2.add(styleToken.value);\n            }\n          }\n        }\n        position = findResult.position;\n      } while (position < value.length);\n      return tokens;\n    }\n  };\n}\n\n// src/palette.ts\nvar defaultNamedColorsMap = {\n  black: \"#000000\",\n  red: \"#bb0000\",\n  green: \"#00bb00\",\n  yellow: \"#bbbb00\",\n  blue: \"#0000bb\",\n  magenta: \"#ff00ff\",\n  cyan: \"#00bbbb\",\n  white: \"#eeeeee\",\n  brightBlack: \"#555555\",\n  brightRed: \"#ff5555\",\n  brightGreen: \"#00ff00\",\n  brightYellow: \"#ffff55\",\n  brightBlue: \"#5555ff\",\n  brightMagenta: \"#ff55ff\",\n  brightCyan: \"#55ffff\",\n  brightWhite: \"#ffffff\"\n};\nfunction createColorPalette(namedColorsMap = defaultNamedColorsMap) {\n  function namedColor(name) {\n    return namedColorsMap[name];\n  }\n  function rgbColor(rgb) {\n    return `#${rgb.map((x) => Math.max(0, Math.min(x, 255)).toString(16).padStart(2, \"0\")).join(\"\")}`;\n  }\n  let colorTable;\n  function getColorTable() {\n    if (colorTable) {\n      return colorTable;\n    }\n    colorTable = [];\n    for (let i = 0; i < namedColors.length; i++) {\n      colorTable.push(namedColor(namedColors[i]));\n    }\n    let levels = [0, 95, 135, 175, 215, 255];\n    for (let r = 0; r < 6; r++) {\n      for (let g = 0; g < 6; g++) {\n        for (let b = 0; b < 6; b++) {\n          colorTable.push(rgbColor([levels[r], levels[g], levels[b]]));\n        }\n      }\n    }\n    let level = 8;\n    for (let i = 0; i < 24; i++, level += 10) {\n      colorTable.push(rgbColor([level, level, level]));\n    }\n    return colorTable;\n  }\n  function tableColor(index) {\n    return getColorTable()[index];\n  }\n  function value(color) {\n    switch (color.type) {\n      case \"named\":\n        return namedColor(color.name);\n      case \"rgb\":\n        return rgbColor(color.rgb);\n      case \"table\":\n        return tableColor(color.index);\n    }\n  }\n  return {\n    value\n  };\n}\n\nfunction tokenizeAnsiWithTheme(theme, fileContents, options) {\n  const colorReplacements = resolveColorReplacements(theme, options);\n  const lines = splitLines(fileContents);\n  const colorPalette = createColorPalette(\n    Object.fromEntries(\n      namedColors.map((name) => [\n        name,\n        theme.colors?.[`terminal.ansi${name[0].toUpperCase()}${name.substring(1)}`]\n      ])\n    )\n  );\n  const parser = createAnsiSequenceParser();\n  return lines.map(\n    (line) => parser.parse(line[0]).map((token) => {\n      let color;\n      let bgColor;\n      if (token.decorations.has(\"reverse\")) {\n        color = token.background ? colorPalette.value(token.background) : theme.bg;\n        bgColor = token.foreground ? colorPalette.value(token.foreground) : theme.fg;\n      } else {\n        color = token.foreground ? colorPalette.value(token.foreground) : theme.fg;\n        bgColor = token.background ? colorPalette.value(token.background) : void 0;\n      }\n      color = applyColorReplacements(color, colorReplacements);\n      bgColor = applyColorReplacements(bgColor, colorReplacements);\n      if (token.decorations.has(\"dim\"))\n        color = dimColor(color);\n      let fontStyle = _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.None;\n      if (token.decorations.has(\"bold\"))\n        fontStyle |= _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Bold;\n      if (token.decorations.has(\"italic\"))\n        fontStyle |= _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Italic;\n      if (token.decorations.has(\"underline\"))\n        fontStyle |= _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Underline;\n      return {\n        content: token.value,\n        offset: line[1],\n        // TODO: more accurate offset? might need to fork ansi-sequence-parser\n        color,\n        bgColor,\n        fontStyle\n      };\n    })\n  );\n}\nfunction dimColor(color) {\n  const hexMatch = color.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);\n  if (hexMatch) {\n    if (hexMatch[3]) {\n      const alpha = Math.round(Number.parseInt(hexMatch[3], 16) / 2).toString(16).padStart(2, \"0\");\n      return `#${hexMatch[1]}${hexMatch[2]}${alpha}`;\n    } else if (hexMatch[2]) {\n      return `#${hexMatch[1]}${hexMatch[2]}80`;\n    } else {\n      return `#${Array.from(hexMatch[1]).map((x) => `${x}${x}`).join(\"\")}80`;\n    }\n  }\n  const cssVarMatch = color.match(/var\\((--[\\w-]+-ansi-[\\w-]+)\\)/);\n  if (cssVarMatch)\n    return `var(${cssVarMatch[1]}-dim)`;\n  return color;\n}\n\nfunction codeToTokensBase(internal, code, options = {}) {\n  const {\n    lang = \"text\",\n    theme: themeName = internal.getLoadedThemes()[0]\n  } = options;\n  if (isPlainLang(lang) || isNoneTheme(themeName))\n    return splitLines(code).map((line) => [{ content: line[0], offset: line[1] }]);\n  const { theme, colorMap } = internal.setTheme(themeName);\n  if (lang === \"ansi\")\n    return tokenizeAnsiWithTheme(theme, code, options);\n  const _grammar = internal.getLanguage(lang);\n  if (options.grammarState) {\n    if (options.grammarState.lang !== _grammar.name) {\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Grammar state language \"${options.grammarState.lang}\" does not match highlight language \"${_grammar.name}\"`);\n    }\n    if (!options.grammarState.themes.includes(theme.name)) {\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Grammar state themes \"${options.grammarState.themes}\" do not contain highlight theme \"${theme.name}\"`);\n    }\n  }\n  return tokenizeWithTheme(code, _grammar, theme, colorMap, options);\n}\nfunction getLastGrammarState(...args) {\n  if (args.length === 2) {\n    return getLastGrammarStateFromMap(args[1]);\n  }\n  const [internal, code, options = {}] = args;\n  const {\n    lang = \"text\",\n    theme: themeName = internal.getLoadedThemes()[0]\n  } = options;\n  if (isPlainLang(lang) || isNoneTheme(themeName))\n    throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"Plain language does not have grammar state\");\n  if (lang === \"ansi\")\n    throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"ANSI language does not have grammar state\");\n  const { theme, colorMap } = internal.setTheme(themeName);\n  const _grammar = internal.getLanguage(lang);\n  return new GrammarState(\n    _tokenizeWithTheme(code, _grammar, theme, colorMap, options).stateStack,\n    _grammar.name,\n    theme.name\n  );\n}\nfunction tokenizeWithTheme(code, grammar, theme, colorMap, options) {\n  const result = _tokenizeWithTheme(code, grammar, theme, colorMap, options);\n  const grammarState = new GrammarState(\n    _tokenizeWithTheme(code, grammar, theme, colorMap, options).stateStack,\n    grammar.name,\n    theme.name\n  );\n  setLastGrammarStateToMap(result.tokens, grammarState);\n  return result.tokens;\n}\nfunction _tokenizeWithTheme(code, grammar, theme, colorMap, options) {\n  const colorReplacements = resolveColorReplacements(theme, options);\n  const {\n    tokenizeMaxLineLength = 0,\n    tokenizeTimeLimit = 500\n  } = options;\n  const lines = splitLines(code);\n  let stateStack = options.grammarState ? getGrammarStack(options.grammarState, theme.name) ?? _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.INITIAL : options.grammarContextCode != null ? _tokenizeWithTheme(\n    options.grammarContextCode,\n    grammar,\n    theme,\n    colorMap,\n    {\n      ...options,\n      grammarState: void 0,\n      grammarContextCode: void 0\n    }\n  ).stateStack : _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.INITIAL;\n  let actual = [];\n  const final = [];\n  for (let i = 0, len = lines.length; i < len; i++) {\n    const [line, lineOffset] = lines[i];\n    if (line === \"\") {\n      actual = [];\n      final.push([]);\n      continue;\n    }\n    if (tokenizeMaxLineLength > 0 && line.length >= tokenizeMaxLineLength) {\n      actual = [];\n      final.push([{\n        content: line,\n        offset: lineOffset,\n        color: \"\",\n        fontStyle: 0\n      }]);\n      continue;\n    }\n    let resultWithScopes;\n    let tokensWithScopes;\n    let tokensWithScopesIndex;\n    if (options.includeExplanation) {\n      resultWithScopes = grammar.tokenizeLine(line, stateStack, tokenizeTimeLimit);\n      tokensWithScopes = resultWithScopes.tokens;\n      tokensWithScopesIndex = 0;\n    }\n    const result = grammar.tokenizeLine2(line, stateStack, tokenizeTimeLimit);\n    const tokensLength = result.tokens.length / 2;\n    for (let j = 0; j < tokensLength; j++) {\n      const startIndex = result.tokens[2 * j];\n      const nextStartIndex = j + 1 < tokensLength ? result.tokens[2 * j + 2] : line.length;\n      if (startIndex === nextStartIndex)\n        continue;\n      const metadata = result.tokens[2 * j + 1];\n      const color = applyColorReplacements(\n        colorMap[_shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.EncodedTokenMetadata.getForeground(metadata)],\n        colorReplacements\n      );\n      const fontStyle = _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.EncodedTokenMetadata.getFontStyle(metadata);\n      const token = {\n        content: line.substring(startIndex, nextStartIndex),\n        offset: lineOffset + startIndex,\n        color,\n        fontStyle\n      };\n      if (options.includeExplanation) {\n        const themeSettingsSelectors = [];\n        if (options.includeExplanation !== \"scopeName\") {\n          for (const setting of theme.settings) {\n            let selectors;\n            switch (typeof setting.scope) {\n              case \"string\":\n                selectors = setting.scope.split(/,/).map((scope) => scope.trim());\n                break;\n              case \"object\":\n                selectors = setting.scope;\n                break;\n              default:\n                continue;\n            }\n            themeSettingsSelectors.push({\n              settings: setting,\n              selectors: selectors.map((selector) => selector.split(/ /))\n            });\n          }\n        }\n        token.explanation = [];\n        let offset = 0;\n        while (startIndex + offset < nextStartIndex) {\n          const tokenWithScopes = tokensWithScopes[tokensWithScopesIndex];\n          const tokenWithScopesText = line.substring(\n            tokenWithScopes.startIndex,\n            tokenWithScopes.endIndex\n          );\n          offset += tokenWithScopesText.length;\n          token.explanation.push({\n            content: tokenWithScopesText,\n            scopes: options.includeExplanation === \"scopeName\" ? explainThemeScopesNameOnly(\n              tokenWithScopes.scopes\n            ) : explainThemeScopesFull(\n              themeSettingsSelectors,\n              tokenWithScopes.scopes\n            )\n          });\n          tokensWithScopesIndex += 1;\n        }\n      }\n      actual.push(token);\n    }\n    final.push(actual);\n    actual = [];\n    stateStack = result.ruleStack;\n  }\n  return {\n    tokens: final,\n    stateStack\n  };\n}\nfunction explainThemeScopesNameOnly(scopes) {\n  return scopes.map((scope) => ({ scopeName: scope }));\n}\nfunction explainThemeScopesFull(themeSelectors, scopes) {\n  const result = [];\n  for (let i = 0, len = scopes.length; i < len; i++) {\n    const scope = scopes[i];\n    result[i] = {\n      scopeName: scope,\n      themeMatches: explainThemeScope(themeSelectors, scope, scopes.slice(0, i))\n    };\n  }\n  return result;\n}\nfunction matchesOne(selector, scope) {\n  return selector === scope || scope.substring(0, selector.length) === selector && scope[selector.length] === \".\";\n}\nfunction matches(selectors, scope, parentScopes) {\n  if (!matchesOne(selectors[selectors.length - 1], scope))\n    return false;\n  let selectorParentIndex = selectors.length - 2;\n  let parentIndex = parentScopes.length - 1;\n  while (selectorParentIndex >= 0 && parentIndex >= 0) {\n    if (matchesOne(selectors[selectorParentIndex], parentScopes[parentIndex]))\n      selectorParentIndex -= 1;\n    parentIndex -= 1;\n  }\n  if (selectorParentIndex === -1)\n    return true;\n  return false;\n}\nfunction explainThemeScope(themeSettingsSelectors, scope, parentScopes) {\n  const result = [];\n  for (const { selectors, settings } of themeSettingsSelectors) {\n    for (const selectorPieces of selectors) {\n      if (matches(selectorPieces, scope, parentScopes)) {\n        result.push(settings);\n        break;\n      }\n    }\n  }\n  return result;\n}\n\nfunction codeToTokensWithThemes(internal, code, options) {\n  const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] }));\n  const themedTokens = themes.map((t) => {\n    const tokens2 = codeToTokensBase(internal, code, {\n      ...options,\n      theme: t.theme\n    });\n    const state = getLastGrammarStateFromMap(tokens2);\n    const theme = typeof t.theme === \"string\" ? t.theme : t.theme.name;\n    return {\n      tokens: tokens2,\n      state,\n      theme\n    };\n  });\n  const tokens = syncThemesTokenization(\n    ...themedTokens.map((i) => i.tokens)\n  );\n  const mergedTokens = tokens[0].map(\n    (line, lineIdx) => line.map((_token, tokenIdx) => {\n      const mergedToken = {\n        content: _token.content,\n        variants: {},\n        offset: _token.offset\n      };\n      if (\"includeExplanation\" in options && options.includeExplanation) {\n        mergedToken.explanation = _token.explanation;\n      }\n      tokens.forEach((t, themeIdx) => {\n        const {\n          content: _,\n          explanation: __,\n          offset: ___,\n          ...styles\n        } = t[lineIdx][tokenIdx];\n        mergedToken.variants[themes[themeIdx].color] = styles;\n      });\n      return mergedToken;\n    })\n  );\n  const mergedGrammarState = themedTokens[0].state ? new GrammarState(\n    Object.fromEntries(themedTokens.map((s) => [s.theme, s.state?.getInternalStack(s.theme)])),\n    themedTokens[0].state.lang\n  ) : void 0;\n  if (mergedGrammarState)\n    setLastGrammarStateToMap(mergedTokens, mergedGrammarState);\n  return mergedTokens;\n}\nfunction syncThemesTokenization(...themes) {\n  const outThemes = themes.map(() => []);\n  const count = themes.length;\n  for (let i = 0; i < themes[0].length; i++) {\n    const lines = themes.map((t) => t[i]);\n    const outLines = outThemes.map(() => []);\n    outThemes.forEach((t, i2) => t.push(outLines[i2]));\n    const indexes = lines.map(() => 0);\n    const current = lines.map((l) => l[0]);\n    while (current.every((t) => t)) {\n      const minLength = Math.min(...current.map((t) => t.content.length));\n      for (let n = 0; n < count; n++) {\n        const token = current[n];\n        if (token.content.length === minLength) {\n          outLines[n].push(token);\n          indexes[n] += 1;\n          current[n] = lines[n][indexes[n]];\n        } else {\n          outLines[n].push({\n            ...token,\n            content: token.content.slice(0, minLength)\n          });\n          current[n] = {\n            ...token,\n            content: token.content.slice(minLength),\n            offset: token.offset + minLength\n          };\n        }\n      }\n    }\n  }\n  return outThemes;\n}\n\nfunction codeToTokens(internal, code, options) {\n  let bg;\n  let fg;\n  let tokens;\n  let themeName;\n  let rootStyle;\n  let grammarState;\n  if (\"themes\" in options) {\n    const {\n      defaultColor = \"light\",\n      cssVariablePrefix = \"--shiki-\"\n    } = options;\n    const themes = Object.entries(options.themes).filter((i) => i[1]).map((i) => ({ color: i[0], theme: i[1] })).sort((a, b) => a.color === defaultColor ? -1 : b.color === defaultColor ? 1 : 0);\n    if (themes.length === 0)\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"`themes` option must not be empty\");\n    const themeTokens = codeToTokensWithThemes(\n      internal,\n      code,\n      options\n    );\n    grammarState = getLastGrammarStateFromMap(themeTokens);\n    if (defaultColor && !themes.find((t) => t.color === defaultColor))\n      throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`\\`themes\\` option must contain the defaultColor key \\`${defaultColor}\\``);\n    const themeRegs = themes.map((t) => internal.getTheme(t.theme));\n    const themesOrder = themes.map((t) => t.color);\n    tokens = themeTokens.map((line) => line.map((token) => flatTokenVariants(token, themesOrder, cssVariablePrefix, defaultColor)));\n    if (grammarState)\n      setLastGrammarStateToMap(tokens, grammarState);\n    const themeColorReplacements = themes.map((t) => resolveColorReplacements(t.theme, options));\n    fg = themes.map((t, idx) => (idx === 0 && defaultColor ? \"\" : `${cssVariablePrefix + t.color}:`) + (applyColorReplacements(themeRegs[idx].fg, themeColorReplacements[idx]) || \"inherit\")).join(\";\");\n    bg = themes.map((t, idx) => (idx === 0 && defaultColor ? \"\" : `${cssVariablePrefix + t.color}-bg:`) + (applyColorReplacements(themeRegs[idx].bg, themeColorReplacements[idx]) || \"inherit\")).join(\";\");\n    themeName = `shiki-themes ${themeRegs.map((t) => t.name).join(\" \")}`;\n    rootStyle = defaultColor ? void 0 : [fg, bg].join(\";\");\n  } else if (\"theme\" in options) {\n    const colorReplacements = resolveColorReplacements(options.theme, options);\n    tokens = codeToTokensBase(\n      internal,\n      code,\n      options\n    );\n    const _theme = internal.getTheme(options.theme);\n    bg = applyColorReplacements(_theme.bg, colorReplacements);\n    fg = applyColorReplacements(_theme.fg, colorReplacements);\n    themeName = _theme.name;\n    grammarState = getLastGrammarStateFromMap(tokens);\n  } else {\n    throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(\"Invalid options, either `theme` or `themes` must be provided\");\n  }\n  return {\n    tokens,\n    fg,\n    bg,\n    themeName,\n    rootStyle,\n    grammarState\n  };\n}\n\nfunction codeToHast(internal, code, options, transformerContext = {\n  meta: {},\n  options,\n  codeToHast: (_code, _options) => codeToHast(internal, _code, _options),\n  codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)\n}) {\n  let input = code;\n  for (const transformer of getTransformers(options))\n    input = transformer.preprocess?.call(transformerContext, input, options) || input;\n  let {\n    tokens,\n    fg,\n    bg,\n    themeName,\n    rootStyle,\n    grammarState\n  } = codeToTokens(internal, input, options);\n  const {\n    mergeWhitespaces = true\n  } = options;\n  if (mergeWhitespaces === true)\n    tokens = mergeWhitespaceTokens(tokens);\n  else if (mergeWhitespaces === \"never\")\n    tokens = splitWhitespaceTokens(tokens);\n  const contextSource = {\n    ...transformerContext,\n    get source() {\n      return input;\n    }\n  };\n  for (const transformer of getTransformers(options))\n    tokens = transformer.tokens?.call(contextSource, tokens) || tokens;\n  return tokensToHast(\n    tokens,\n    {\n      ...options,\n      fg,\n      bg,\n      themeName,\n      rootStyle\n    },\n    contextSource,\n    grammarState\n  );\n}\nfunction tokensToHast(tokens, options, transformerContext, grammarState = getLastGrammarStateFromMap(tokens)) {\n  const transformers = getTransformers(options);\n  const lines = [];\n  const root = {\n    type: \"root\",\n    children: []\n  };\n  const {\n    structure = \"classic\",\n    tabindex = \"0\"\n  } = options;\n  let preNode = {\n    type: \"element\",\n    tagName: \"pre\",\n    properties: {\n      class: `shiki ${options.themeName || \"\"}`,\n      style: options.rootStyle || `background-color:${options.bg};color:${options.fg}`,\n      ...tabindex !== false && tabindex != null ? {\n        tabindex: tabindex.toString()\n      } : {},\n      ...Object.fromEntries(\n        Array.from(\n          Object.entries(options.meta || {})\n        ).filter(([key]) => !key.startsWith(\"_\"))\n      )\n    },\n    children: []\n  };\n  let codeNode = {\n    type: \"element\",\n    tagName: \"code\",\n    properties: {},\n    children: lines\n  };\n  const lineNodes = [];\n  const context = {\n    ...transformerContext,\n    structure,\n    addClassToHast,\n    get source() {\n      return transformerContext.source;\n    },\n    get tokens() {\n      return tokens;\n    },\n    get options() {\n      return options;\n    },\n    get root() {\n      return root;\n    },\n    get pre() {\n      return preNode;\n    },\n    get code() {\n      return codeNode;\n    },\n    get lines() {\n      return lineNodes;\n    }\n  };\n  tokens.forEach((line, idx) => {\n    if (idx) {\n      if (structure === \"inline\")\n        root.children.push({ type: \"element\", tagName: \"br\", properties: {}, children: [] });\n      else if (structure === \"classic\")\n        lines.push({ type: \"text\", value: \"\\n\" });\n    }\n    let lineNode = {\n      type: \"element\",\n      tagName: \"span\",\n      properties: { class: \"line\" },\n      children: []\n    };\n    let col = 0;\n    for (const token of line) {\n      let tokenNode = {\n        type: \"element\",\n        tagName: \"span\",\n        properties: {\n          ...token.htmlAttrs\n        },\n        children: [{ type: \"text\", value: token.content }]\n      };\n      if (typeof token.htmlStyle === \"string\")\n        (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"`htmlStyle` as a string is deprecated. Use an object instead.\");\n      const style = stringifyTokenStyle(token.htmlStyle || getTokenStyleObject(token));\n      if (style)\n        tokenNode.properties.style = style;\n      for (const transformer of transformers)\n        tokenNode = transformer?.span?.call(context, tokenNode, idx + 1, col, lineNode, token) || tokenNode;\n      if (structure === \"inline\")\n        root.children.push(tokenNode);\n      else if (structure === \"classic\")\n        lineNode.children.push(tokenNode);\n      col += token.content.length;\n    }\n    if (structure === \"classic\") {\n      for (const transformer of transformers)\n        lineNode = transformer?.line?.call(context, lineNode, idx + 1) || lineNode;\n      lineNodes.push(lineNode);\n      lines.push(lineNode);\n    }\n  });\n  if (structure === \"classic\") {\n    for (const transformer of transformers)\n      codeNode = transformer?.code?.call(context, codeNode) || codeNode;\n    preNode.children.push(codeNode);\n    for (const transformer of transformers)\n      preNode = transformer?.pre?.call(context, preNode) || preNode;\n    root.children.push(preNode);\n  }\n  let result = root;\n  for (const transformer of transformers)\n    result = transformer?.root?.call(context, result) || result;\n  if (grammarState)\n    setLastGrammarStateToMap(result, grammarState);\n  return result;\n}\nfunction mergeWhitespaceTokens(tokens) {\n  return tokens.map((line) => {\n    const newLine = [];\n    let carryOnContent = \"\";\n    let firstOffset = 0;\n    line.forEach((token, idx) => {\n      const isUnderline = token.fontStyle && token.fontStyle & _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.FontStyle.Underline;\n      const couldMerge = !isUnderline;\n      if (couldMerge && token.content.match(/^\\s+$/) && line[idx + 1]) {\n        if (!firstOffset)\n          firstOffset = token.offset;\n        carryOnContent += token.content;\n      } else {\n        if (carryOnContent) {\n          if (couldMerge) {\n            newLine.push({\n              ...token,\n              offset: firstOffset,\n              content: carryOnContent + token.content\n            });\n          } else {\n            newLine.push(\n              {\n                content: carryOnContent,\n                offset: firstOffset\n              },\n              token\n            );\n          }\n          firstOffset = 0;\n          carryOnContent = \"\";\n        } else {\n          newLine.push(token);\n        }\n      }\n    });\n    return newLine;\n  });\n}\nfunction splitWhitespaceTokens(tokens) {\n  return tokens.map((line) => {\n    return line.flatMap((token) => {\n      if (token.content.match(/^\\s+$/))\n        return token;\n      const match = token.content.match(/^(\\s*)(.*?)(\\s*)$/);\n      if (!match)\n        return token;\n      const [, leading, content, trailing] = match;\n      if (!leading && !trailing)\n        return token;\n      const expanded = [{\n        ...token,\n        offset: token.offset + leading.length,\n        content\n      }];\n      if (leading) {\n        expanded.unshift({\n          content: leading,\n          offset: token.offset\n        });\n      }\n      if (trailing) {\n        expanded.push({\n          content: trailing,\n          offset: token.offset + leading.length + content.length\n        });\n      }\n      return expanded;\n    });\n  });\n}\n\nfunction codeToHtml(internal, code, options) {\n  const context = {\n    meta: {},\n    options,\n    codeToHast: (_code, _options) => codeToHast(internal, _code, _options),\n    codeToTokens: (_code, _options) => codeToTokens(internal, _code, _options)\n  };\n  let result = (0,hast_util_to_html__WEBPACK_IMPORTED_MODULE_3__.toHtml)(codeToHast(internal, code, options, context));\n  for (const transformer of getTransformers(options))\n    result = transformer.postprocess?.call(context, result, options) || result;\n  return result;\n}\n\nconst VSCODE_FALLBACK_EDITOR_FG = { light: \"#333333\", dark: \"#bbbbbb\" };\nconst VSCODE_FALLBACK_EDITOR_BG = { light: \"#fffffe\", dark: \"#1e1e1e\" };\nconst RESOLVED_KEY = \"__shiki_resolved\";\nfunction normalizeTheme(rawTheme) {\n  if (rawTheme?.[RESOLVED_KEY])\n    return rawTheme;\n  const theme = {\n    ...rawTheme\n  };\n  if (theme.tokenColors && !theme.settings) {\n    theme.settings = theme.tokenColors;\n    delete theme.tokenColors;\n  }\n  theme.type ||= \"dark\";\n  theme.colorReplacements = { ...theme.colorReplacements };\n  theme.settings ||= [];\n  let { bg, fg } = theme;\n  if (!bg || !fg) {\n    const globalSetting = theme.settings ? theme.settings.find((s) => !s.name && !s.scope) : void 0;\n    if (globalSetting?.settings?.foreground)\n      fg = globalSetting.settings.foreground;\n    if (globalSetting?.settings?.background)\n      bg = globalSetting.settings.background;\n    if (!fg && theme?.colors?.[\"editor.foreground\"])\n      fg = theme.colors[\"editor.foreground\"];\n    if (!bg && theme?.colors?.[\"editor.background\"])\n      bg = theme.colors[\"editor.background\"];\n    if (!fg)\n      fg = theme.type === \"light\" ? VSCODE_FALLBACK_EDITOR_FG.light : VSCODE_FALLBACK_EDITOR_FG.dark;\n    if (!bg)\n      bg = theme.type === \"light\" ? VSCODE_FALLBACK_EDITOR_BG.light : VSCODE_FALLBACK_EDITOR_BG.dark;\n    theme.fg = fg;\n    theme.bg = bg;\n  }\n  if (!(theme.settings[0] && theme.settings[0].settings && !theme.settings[0].scope)) {\n    theme.settings.unshift({\n      settings: {\n        foreground: theme.fg,\n        background: theme.bg\n      }\n    });\n  }\n  let replacementCount = 0;\n  const replacementMap = /* @__PURE__ */ new Map();\n  function getReplacementColor(value) {\n    if (replacementMap.has(value))\n      return replacementMap.get(value);\n    replacementCount += 1;\n    const hex = `#${replacementCount.toString(16).padStart(8, \"0\").toLowerCase()}`;\n    if (theme.colorReplacements?.[`#${hex}`])\n      return getReplacementColor(value);\n    replacementMap.set(value, hex);\n    return hex;\n  }\n  theme.settings = theme.settings.map((setting) => {\n    const replaceFg = setting.settings?.foreground && !setting.settings.foreground.startsWith(\"#\");\n    const replaceBg = setting.settings?.background && !setting.settings.background.startsWith(\"#\");\n    if (!replaceFg && !replaceBg)\n      return setting;\n    const clone = {\n      ...setting,\n      settings: {\n        ...setting.settings\n      }\n    };\n    if (replaceFg) {\n      const replacement = getReplacementColor(setting.settings.foreground);\n      theme.colorReplacements[replacement] = setting.settings.foreground;\n      clone.settings.foreground = replacement;\n    }\n    if (replaceBg) {\n      const replacement = getReplacementColor(setting.settings.background);\n      theme.colorReplacements[replacement] = setting.settings.background;\n      clone.settings.background = replacement;\n    }\n    return clone;\n  });\n  for (const key of Object.keys(theme.colors || {})) {\n    if (key === \"editor.foreground\" || key === \"editor.background\" || key.startsWith(\"terminal.ansi\")) {\n      if (!theme.colors[key]?.startsWith(\"#\")) {\n        const replacement = getReplacementColor(theme.colors[key]);\n        theme.colorReplacements[replacement] = theme.colors[key];\n        theme.colors[key] = replacement;\n      }\n    }\n  }\n  Object.defineProperty(theme, RESOLVED_KEY, {\n    enumerable: false,\n    writable: false,\n    value: true\n  });\n  return theme;\n}\n\nasync function resolveLangs(langs) {\n  return Array.from(new Set((await Promise.all(\n    langs.filter((l) => !isSpecialLang(l)).map(async (lang) => await normalizeGetter(lang).then((r) => Array.isArray(r) ? r : [r]))\n  )).flat()));\n}\nasync function resolveThemes(themes) {\n  const resolved = await Promise.all(\n    themes.map(\n      async (theme) => isSpecialTheme(theme) ? null : normalizeTheme(await normalizeGetter(theme))\n    )\n  );\n  return resolved.filter((i) => !!i);\n}\n\nclass ShikiError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ShikiError\";\n  }\n}\n\nclass Registry extends _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.Registry {\n  constructor(_resolver, _themes, _langs, _alias = {}) {\n    super(_resolver);\n    this._resolver = _resolver;\n    this._themes = _themes;\n    this._langs = _langs;\n    this._alias = _alias;\n    this._themes.map((t) => this.loadTheme(t));\n    this.loadLanguages(this._langs);\n  }\n  _resolvedThemes = /* @__PURE__ */ new Map();\n  _resolvedGrammars = /* @__PURE__ */ new Map();\n  _langMap = /* @__PURE__ */ new Map();\n  _langGraph = /* @__PURE__ */ new Map();\n  _textmateThemeCache = /* @__PURE__ */ new WeakMap();\n  _loadedThemesCache = null;\n  _loadedLanguagesCache = null;\n  getTheme(theme) {\n    if (typeof theme === \"string\")\n      return this._resolvedThemes.get(theme);\n    else\n      return this.loadTheme(theme);\n  }\n  loadTheme(theme) {\n    const _theme = normalizeTheme(theme);\n    if (_theme.name) {\n      this._resolvedThemes.set(_theme.name, _theme);\n      this._loadedThemesCache = null;\n    }\n    return _theme;\n  }\n  getLoadedThemes() {\n    if (!this._loadedThemesCache)\n      this._loadedThemesCache = [...this._resolvedThemes.keys()];\n    return this._loadedThemesCache;\n  }\n  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`\n  // is expensive. Themes can switch often especially for dual-theme support.\n  //\n  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,\n  // we omit here so it's easier to cache the themes.\n  setTheme(theme) {\n    let textmateTheme = this._textmateThemeCache.get(theme);\n    if (!textmateTheme) {\n      textmateTheme = _shikijs_vscode_textmate__WEBPACK_IMPORTED_MODULE_2__.Theme.createFromRawTheme(theme);\n      this._textmateThemeCache.set(theme, textmateTheme);\n    }\n    this._syncRegistry.setTheme(textmateTheme);\n  }\n  getGrammar(name) {\n    if (this._alias[name]) {\n      const resolved = /* @__PURE__ */ new Set([name]);\n      while (this._alias[name]) {\n        name = this._alias[name];\n        if (resolved.has(name))\n          throw new ShikiError(`Circular alias \\`${Array.from(resolved).join(\" -> \")} -> ${name}\\``);\n        resolved.add(name);\n      }\n    }\n    return this._resolvedGrammars.get(name);\n  }\n  loadLanguage(lang) {\n    if (this.getGrammar(lang.name))\n      return;\n    const embeddedLazilyBy = new Set(\n      [...this._langMap.values()].filter((i) => i.embeddedLangsLazy?.includes(lang.name))\n    );\n    this._resolver.addLanguage(lang);\n    const grammarConfig = {\n      balancedBracketSelectors: lang.balancedBracketSelectors || [\"*\"],\n      unbalancedBracketSelectors: lang.unbalancedBracketSelectors || []\n    };\n    this._syncRegistry._rawGrammars.set(lang.scopeName, lang);\n    const g = this.loadGrammarWithConfiguration(lang.scopeName, 1, grammarConfig);\n    g.name = lang.name;\n    this._resolvedGrammars.set(lang.name, g);\n    if (lang.aliases) {\n      lang.aliases.forEach((alias) => {\n        this._alias[alias] = lang.name;\n      });\n    }\n    this._loadedLanguagesCache = null;\n    if (embeddedLazilyBy.size) {\n      for (const e of embeddedLazilyBy) {\n        this._resolvedGrammars.delete(e.name);\n        this._loadedLanguagesCache = null;\n        this._syncRegistry?._injectionGrammars?.delete(e.scopeName);\n        this._syncRegistry?._grammars?.delete(e.scopeName);\n        this.loadLanguage(this._langMap.get(e.name));\n      }\n    }\n  }\n  dispose() {\n    super.dispose();\n    this._resolvedThemes.clear();\n    this._resolvedGrammars.clear();\n    this._langMap.clear();\n    this._langGraph.clear();\n    this._loadedThemesCache = null;\n  }\n  loadLanguages(langs) {\n    for (const lang of langs)\n      this.resolveEmbeddedLanguages(lang);\n    const langsGraphArray = Array.from(this._langGraph.entries());\n    const missingLangs = langsGraphArray.filter(([_, lang]) => !lang);\n    if (missingLangs.length) {\n      const dependents = langsGraphArray.filter(([_, lang]) => lang && lang.embeddedLangs?.some((l) => missingLangs.map(([name]) => name).includes(l))).filter((lang) => !missingLangs.includes(lang));\n      throw new ShikiError(`Missing languages ${missingLangs.map(([name]) => `\\`${name}\\``).join(\", \")}, required by ${dependents.map(([name]) => `\\`${name}\\``).join(\", \")}`);\n    }\n    for (const [_, lang] of langsGraphArray)\n      this._resolver.addLanguage(lang);\n    for (const [_, lang] of langsGraphArray)\n      this.loadLanguage(lang);\n  }\n  getLoadedLanguages() {\n    if (!this._loadedLanguagesCache) {\n      this._loadedLanguagesCache = [\n        .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])\n      ];\n    }\n    return this._loadedLanguagesCache;\n  }\n  resolveEmbeddedLanguages(lang) {\n    this._langMap.set(lang.name, lang);\n    this._langGraph.set(lang.name, lang);\n    if (lang.embeddedLangs) {\n      for (const embeddedLang of lang.embeddedLangs)\n        this._langGraph.set(embeddedLang, this._langMap.get(embeddedLang));\n    }\n  }\n}\n\nclass Resolver {\n  _langs = /* @__PURE__ */ new Map();\n  _scopeToLang = /* @__PURE__ */ new Map();\n  _injections = /* @__PURE__ */ new Map();\n  _onigLib;\n  constructor(engine, langs) {\n    this._onigLib = {\n      createOnigScanner: (patterns) => engine.createScanner(patterns),\n      createOnigString: (s) => engine.createString(s)\n    };\n    langs.forEach((i) => this.addLanguage(i));\n  }\n  get onigLib() {\n    return this._onigLib;\n  }\n  getLangRegistration(langIdOrAlias) {\n    return this._langs.get(langIdOrAlias);\n  }\n  loadGrammar(scopeName) {\n    return this._scopeToLang.get(scopeName);\n  }\n  addLanguage(l) {\n    this._langs.set(l.name, l);\n    if (l.aliases) {\n      l.aliases.forEach((a) => {\n        this._langs.set(a, l);\n      });\n    }\n    this._scopeToLang.set(l.scopeName, l);\n    if (l.injectTo) {\n      l.injectTo.forEach((i) => {\n        if (!this._injections.get(i))\n          this._injections.set(i, []);\n        this._injections.get(i).push(l.scopeName);\n      });\n    }\n  }\n  getInjections(scopeName) {\n    const scopeParts = scopeName.split(\".\");\n    let injections = [];\n    for (let i = 1; i <= scopeParts.length; i++) {\n      const subScopeName = scopeParts.slice(0, i).join(\".\");\n      injections = [...injections, ...this._injections.get(subScopeName) || []];\n    }\n    return injections;\n  }\n}\n\nlet instancesCount = 0;\nfunction createShikiInternalSync(options) {\n  instancesCount += 1;\n  if (options.warnings !== false && instancesCount >= 10 && instancesCount % 10 === 0)\n    console.warn(`[Shiki] ${instancesCount} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \\`highlighter.dispose()\\` to release unused instances.`);\n  let isDisposed = false;\n  if (!options.engine)\n    throw new ShikiError(\"`engine` option is required for synchronous mode\");\n  const langs = (options.langs || []).flat(1);\n  const themes = (options.themes || []).flat(1).map(normalizeTheme);\n  const resolver = new Resolver(options.engine, langs);\n  const _registry = new Registry(resolver, themes, langs, options.langAlias);\n  let _lastTheme;\n  function getLanguage(name) {\n    ensureNotDisposed();\n    const _lang = _registry.getGrammar(typeof name === \"string\" ? name : name.name);\n    if (!_lang)\n      throw new ShikiError(`Language \\`${name}\\` not found, you may need to load it first`);\n    return _lang;\n  }\n  function getTheme(name) {\n    if (name === \"none\")\n      return { bg: \"\", fg: \"\", name: \"none\", settings: [], type: \"dark\" };\n    ensureNotDisposed();\n    const _theme = _registry.getTheme(name);\n    if (!_theme)\n      throw new ShikiError(`Theme \\`${name}\\` not found, you may need to load it first`);\n    return _theme;\n  }\n  function setTheme(name) {\n    ensureNotDisposed();\n    const theme = getTheme(name);\n    if (_lastTheme !== name) {\n      _registry.setTheme(theme);\n      _lastTheme = name;\n    }\n    const colorMap = _registry.getColorMap();\n    return {\n      theme,\n      colorMap\n    };\n  }\n  function getLoadedThemes() {\n    ensureNotDisposed();\n    return _registry.getLoadedThemes();\n  }\n  function getLoadedLanguages() {\n    ensureNotDisposed();\n    return _registry.getLoadedLanguages();\n  }\n  function loadLanguageSync(...langs2) {\n    ensureNotDisposed();\n    _registry.loadLanguages(langs2.flat(1));\n  }\n  async function loadLanguage(...langs2) {\n    return loadLanguageSync(await resolveLangs(langs2));\n  }\n  function loadThemeSync(...themes2) {\n    ensureNotDisposed();\n    for (const theme of themes2.flat(1)) {\n      _registry.loadTheme(theme);\n    }\n  }\n  async function loadTheme(...themes2) {\n    ensureNotDisposed();\n    return loadThemeSync(await resolveThemes(themes2));\n  }\n  function ensureNotDisposed() {\n    if (isDisposed)\n      throw new ShikiError(\"Shiki instance has been disposed\");\n  }\n  function dispose() {\n    if (isDisposed)\n      return;\n    isDisposed = true;\n    _registry.dispose();\n    instancesCount -= 1;\n  }\n  return {\n    setTheme,\n    getTheme,\n    getLanguage,\n    getLoadedThemes,\n    getLoadedLanguages,\n    loadLanguage,\n    loadLanguageSync,\n    loadTheme,\n    loadThemeSync,\n    dispose,\n    [Symbol.dispose]: dispose\n  };\n}\n\nasync function createShikiInternal(options) {\n  if (options.loadWasm) {\n    (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"`loadWasm` option is deprecated. Use `engine: createOnigurumaEngine(loadWasm)` instead.\");\n  }\n  if (!options.engine) {\n    (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"`engine` option is required. Use `createOnigurumaEngine` or `createJavaScriptRegexEngine` to create an engine.\");\n  }\n  const [\n    themes,\n    langs,\n    engine\n  ] = await Promise.all([\n    resolveThemes(options.themes || []),\n    resolveLangs(options.langs || []),\n    options.engine || (0,_shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__.createOnigurumaEngine)(options.loadWasm || (0,_shikijs_engine_oniguruma__WEBPACK_IMPORTED_MODULE_4__.getDefaultWasmLoader)())\n  ]);\n  return createShikiInternalSync({\n    ...options,\n    themes,\n    langs,\n    engine\n  });\n}\nfunction getShikiInternal(options) {\n  (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"`getShikiInternal` is deprecated. Use `createShikiInternal` instead.\");\n  return createShikiInternal(options);\n}\n\nasync function createHighlighterCore(options) {\n  const internal = await createShikiInternal(options);\n  return {\n    getLastGrammarState: (...args) => getLastGrammarState(internal, ...args),\n    codeToTokensBase: (code, options2) => codeToTokensBase(internal, code, options2),\n    codeToTokensWithThemes: (code, options2) => codeToTokensWithThemes(internal, code, options2),\n    codeToTokens: (code, options2) => codeToTokens(internal, code, options2),\n    codeToHast: (code, options2) => codeToHast(internal, code, options2),\n    codeToHtml: (code, options2) => codeToHtml(internal, code, options2),\n    getBundledLanguages: () => ({}),\n    getBundledThemes: () => ({}),\n    ...internal,\n    getInternalContext: () => internal\n  };\n}\nfunction createHighlighterCoreSync(options) {\n  const internal = createShikiInternalSync(options);\n  return {\n    getLastGrammarState: (...args) => getLastGrammarState(internal, ...args),\n    codeToTokensBase: (code, options2) => codeToTokensBase(internal, code, options2),\n    codeToTokensWithThemes: (code, options2) => codeToTokensWithThemes(internal, code, options2),\n    codeToTokens: (code, options2) => codeToTokens(internal, code, options2),\n    codeToHast: (code, options2) => codeToHast(internal, code, options2),\n    codeToHtml: (code, options2) => codeToHtml(internal, code, options2),\n    getBundledLanguages: () => ({}),\n    getBundledThemes: () => ({}),\n    ...internal,\n    getInternalContext: () => internal\n  };\n}\nfunction makeSingletonHighlighterCore(createHighlighter) {\n  let _shiki;\n  async function getSingletonHighlighterCore2(options) {\n    if (!_shiki) {\n      _shiki = createHighlighter({\n        ...options,\n        themes: options.themes || [],\n        langs: options.langs || []\n      });\n      return _shiki;\n    } else {\n      const s = await _shiki;\n      await Promise.all([\n        s.loadTheme(...options.themes || []),\n        s.loadLanguage(...options.langs || [])\n      ]);\n      return s;\n    }\n  }\n  return getSingletonHighlighterCore2;\n}\nconst getSingletonHighlighterCore = /* @__PURE__ */ makeSingletonHighlighterCore(createHighlighterCore);\nfunction getHighlighterCore(options) {\n  (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"`getHighlighterCore` is deprecated. Use `createHighlighterCore` or `getSingletonHighlighterCore` instead.\");\n  return createHighlighterCore(options);\n}\n\nfunction createdBundledHighlighter(arg1, arg2, arg3) {\n  let bundledLanguages;\n  let bundledThemes;\n  let engine;\n  if (arg2) {\n    (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"`createdBundledHighlighter` signature with `bundledLanguages` and `bundledThemes` is deprecated. Use the options object signature instead.\");\n    bundledLanguages = arg1;\n    bundledThemes = arg2;\n    engine = () => createOnigurumaEngine(arg3);\n  } else {\n    const options = arg1;\n    bundledLanguages = options.langs;\n    bundledThemes = options.themes;\n    engine = options.engine;\n  }\n  async function createHighlighter(options) {\n    function resolveLang(lang) {\n      if (typeof lang === \"string\") {\n        if (isSpecialLang(lang))\n          return [];\n        const bundle = bundledLanguages[lang];\n        if (!bundle)\n          throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Language \\`${lang}\\` is not included in this bundle. You may want to load it from external source.`);\n        return bundle;\n      }\n      return lang;\n    }\n    function resolveTheme(theme) {\n      if (isSpecialTheme(theme))\n        return \"none\";\n      if (typeof theme === \"string\") {\n        const bundle = bundledThemes[theme];\n        if (!bundle)\n          throw new _shikijs_types__WEBPACK_IMPORTED_MODULE_0__.ShikiError(`Theme \\`${theme}\\` is not included in this bundle. You may want to load it from external source.`);\n        return bundle;\n      }\n      return theme;\n    }\n    const _themes = (options.themes ?? []).map((i) => resolveTheme(i));\n    const langs = (options.langs ?? []).map((i) => resolveLang(i));\n    const core = await createHighlighterCore({\n      engine: options.engine ?? engine(),\n      ...options,\n      themes: _themes,\n      langs\n    });\n    return {\n      ...core,\n      loadLanguage(...langs2) {\n        return core.loadLanguage(...langs2.map(resolveLang));\n      },\n      loadTheme(...themes) {\n        return core.loadTheme(...themes.map(resolveTheme));\n      },\n      getBundledLanguages() {\n        return bundledLanguages;\n      },\n      getBundledThemes() {\n        return bundledThemes;\n      }\n    };\n  }\n  return createHighlighter;\n}\nfunction makeSingletonHighlighter(createHighlighter) {\n  let _shiki;\n  async function getSingletonHighlighter(options = {}) {\n    if (!_shiki) {\n      _shiki = createHighlighter({\n        ...options,\n        themes: options.themes || [],\n        langs: options.langs || []\n      });\n      return _shiki;\n    } else {\n      const s = await _shiki;\n      await Promise.all([\n        s.loadTheme(...options.themes || []),\n        s.loadLanguage(...options.langs || [])\n      ]);\n      return s;\n    }\n  }\n  return getSingletonHighlighter;\n}\nfunction createSingletonShorthands(createHighlighter, config) {\n  const getSingletonHighlighter = makeSingletonHighlighter(createHighlighter);\n  async function get(code, options) {\n    const shiki = await getSingletonHighlighter({\n      langs: [options.lang],\n      themes: \"theme\" in options ? [options.theme] : Object.values(options.themes)\n    });\n    const langs = await config?.guessEmbeddedLanguages?.(code, options.lang, shiki);\n    if (langs) {\n      await shiki.loadLanguage(...langs);\n    }\n    return shiki;\n  }\n  return {\n    getSingletonHighlighter(options) {\n      return getSingletonHighlighter(options);\n    },\n    async codeToHtml(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToHtml(code, options);\n    },\n    async codeToHast(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToHast(code, options);\n    },\n    async codeToTokens(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToTokens(code, options);\n    },\n    async codeToTokensBase(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToTokensBase(code, options);\n    },\n    async codeToTokensWithThemes(code, options) {\n      const shiki = await get(code, options);\n      return shiki.codeToTokensWithThemes(code, options);\n    },\n    async getLastGrammarState(code, options) {\n      const shiki = await getSingletonHighlighter({\n        langs: [options.lang],\n        themes: [options.theme]\n      });\n      return shiki.getLastGrammarState(code, options);\n    }\n  };\n}\n\nfunction createJavaScriptRegexEngine(options) {\n  (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"import `createJavaScriptRegexEngine` from `@shikijs/engine-javascript` or `shiki/engine/javascript` instead\");\n  return (0,_shikijs_engine_javascript__WEBPACK_IMPORTED_MODULE_5__.createJavaScriptRegexEngine)(options);\n}\nfunction defaultJavaScriptRegexConstructor(pattern) {\n  (0,_shared_core_5hv0Law9_mjs__WEBPACK_IMPORTED_MODULE_1__.w)(\"import `defaultJavaScriptRegexConstructor` from `@shikijs/engine-javascript` or `shiki/engine/javascript` instead\");\n  return (0,_shikijs_engine_javascript__WEBPACK_IMPORTED_MODULE_5__.defaultJavaScriptRegexConstructor)(pattern);\n}\n\nfunction createCssVariablesTheme(options = {}) {\n  const {\n    name = \"css-variables\",\n    variablePrefix = \"--shiki-\",\n    fontStyle = true\n  } = options;\n  const variable = (name2) => {\n    if (options.variableDefaults?.[name2])\n      return `var(${variablePrefix}${name2}, ${options.variableDefaults[name2]})`;\n    return `var(${variablePrefix}${name2})`;\n  };\n  const theme = {\n    name,\n    type: \"dark\",\n    colors: {\n      \"editor.foreground\": variable(\"foreground\"),\n      \"editor.background\": variable(\"background\"),\n      \"terminal.ansiBlack\": variable(\"ansi-black\"),\n      \"terminal.ansiRed\": variable(\"ansi-red\"),\n      \"terminal.ansiGreen\": variable(\"ansi-green\"),\n      \"terminal.ansiYellow\": variable(\"ansi-yellow\"),\n      \"terminal.ansiBlue\": variable(\"ansi-blue\"),\n      \"terminal.ansiMagenta\": variable(\"ansi-magenta\"),\n      \"terminal.ansiCyan\": variable(\"ansi-cyan\"),\n      \"terminal.ansiWhite\": variable(\"ansi-white\"),\n      \"terminal.ansiBrightBlack\": variable(\"ansi-bright-black\"),\n      \"terminal.ansiBrightRed\": variable(\"ansi-bright-red\"),\n      \"terminal.ansiBrightGreen\": variable(\"ansi-bright-green\"),\n      \"terminal.ansiBrightYellow\": variable(\"ansi-bright-yellow\"),\n      \"terminal.ansiBrightBlue\": variable(\"ansi-bright-blue\"),\n      \"terminal.ansiBrightMagenta\": variable(\"ansi-bright-magenta\"),\n      \"terminal.ansiBrightCyan\": variable(\"ansi-bright-cyan\"),\n      \"terminal.ansiBrightWhite\": variable(\"ansi-bright-white\")\n    },\n    tokenColors: [\n      {\n        scope: [\n          \"keyword.operator.accessor\",\n          \"meta.group.braces.round.function.arguments\",\n          \"meta.template.expression\",\n          \"markup.fenced_code meta.embedded.block\"\n        ],\n        settings: {\n          foreground: variable(\"foreground\")\n        }\n      },\n      {\n        scope: \"emphasis\",\n        settings: {\n          fontStyle: \"italic\"\n        }\n      },\n      {\n        scope: [\"strong\", \"markup.heading.markdown\", \"markup.bold.markdown\"],\n        settings: {\n          fontStyle: \"bold\"\n        }\n      },\n      {\n        scope: [\"markup.italic.markdown\"],\n        settings: {\n          fontStyle: \"italic\"\n        }\n      },\n      {\n        scope: \"meta.link.inline.markdown\",\n        settings: {\n          fontStyle: \"underline\",\n          foreground: variable(\"token-link\")\n        }\n      },\n      {\n        scope: [\"string\", \"markup.fenced_code\", \"markup.inline\"],\n        settings: {\n          foreground: variable(\"token-string\")\n        }\n      },\n      {\n        scope: [\"comment\", \"string.quoted.docstring.multi\"],\n        settings: {\n          foreground: variable(\"token-comment\")\n        }\n      },\n      {\n        scope: [\n          \"constant.numeric\",\n          \"constant.language\",\n          \"constant.other.placeholder\",\n          \"constant.character.format.placeholder\",\n          \"variable.language.this\",\n          \"variable.other.object\",\n          \"variable.other.class\",\n          \"variable.other.constant\",\n          \"meta.property-name\",\n          \"meta.property-value\",\n          \"support\"\n        ],\n        settings: {\n          foreground: variable(\"token-constant\")\n        }\n      },\n      {\n        scope: [\n          \"keyword\",\n          \"storage.modifier\",\n          \"storage.type\",\n          \"storage.control.clojure\",\n          \"entity.name.function.clojure\",\n          \"entity.name.tag.yaml\",\n          \"support.function.node\",\n          \"support.type.property-name.json\",\n          \"punctuation.separator.key-value\",\n          \"punctuation.definition.template-expression\"\n        ],\n        settings: {\n          foreground: variable(\"token-keyword\")\n        }\n      },\n      {\n        scope: \"variable.parameter.function\",\n        settings: {\n          foreground: variable(\"token-parameter\")\n        }\n      },\n      {\n        scope: [\n          \"support.function\",\n          \"entity.name.type\",\n          \"entity.other.inherited-class\",\n          \"meta.function-call\",\n          \"meta.instance.constructor\",\n          \"entity.other.attribute-name\",\n          \"entity.name.function\",\n          \"constant.keyword.clojure\"\n        ],\n        settings: {\n          foreground: variable(\"token-function\")\n        }\n      },\n      {\n        scope: [\n          \"entity.name.tag\",\n          \"string.quoted\",\n          \"string.regexp\",\n          \"string.interpolated\",\n          \"string.template\",\n          \"string.unquoted.plain.out.yaml\",\n          \"keyword.other.template\"\n        ],\n        settings: {\n          foreground: variable(\"token-string-expression\")\n        }\n      },\n      {\n        scope: [\n          \"punctuation.definition.arguments\",\n          \"punctuation.definition.dict\",\n          \"punctuation.separator\",\n          \"meta.function-call.arguments\"\n        ],\n        settings: {\n          foreground: variable(\"token-punctuation\")\n        }\n      },\n      {\n        // [Custom] Markdown links\n        scope: [\n          \"markup.underline.link\",\n          \"punctuation.definition.metadata.markdown\"\n        ],\n        settings: {\n          foreground: variable(\"token-link\")\n        }\n      },\n      {\n        // [Custom] Markdown list\n        scope: [\"beginning.punctuation.definition.list.markdown\"],\n        settings: {\n          foreground: variable(\"token-string\")\n        }\n      },\n      {\n        // [Custom] Markdown punctuation definition brackets\n        scope: [\n          \"punctuation.definition.string.begin.markdown\",\n          \"punctuation.definition.string.end.markdown\",\n          \"string.other.link.title.markdown\",\n          \"string.other.link.description.markdown\"\n        ],\n        settings: {\n          foreground: variable(\"token-keyword\")\n        }\n      },\n      {\n        // [Custom] Diff\n        scope: [\n          \"markup.inserted\",\n          \"meta.diff.header.to-file\",\n          \"punctuation.definition.inserted\"\n        ],\n        settings: {\n          foreground: variable(\"token-inserted\")\n        }\n      },\n      {\n        scope: [\n          \"markup.deleted\",\n          \"meta.diff.header.from-file\",\n          \"punctuation.definition.deleted\"\n        ],\n        settings: {\n          foreground: variable(\"token-deleted\")\n        }\n      },\n      {\n        scope: [\n          \"markup.changed\",\n          \"punctuation.definition.changed\"\n        ],\n        settings: {\n          foreground: variable(\"token-changed\")\n        }\n      }\n    ]\n  };\n  if (!fontStyle) {\n    theme.tokenColors = theme.tokenColors?.map((tokenColor) => {\n      if (tokenColor.settings?.fontStyle)\n        delete tokenColor.settings.fontStyle;\n      return tokenColor;\n    });\n  }\n  return theme;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNoaWtpanMrY29yZUAyLjUuMC9ub2RlX21vZHVsZXMvQHNoaWtpanMvY29yZS9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0RDtBQUM3QjtBQUM0RztBQUMxRTtBQUNXO0FBQ3VDO0FBQ2hCO0FBQ3hEO0FBQ2M7QUFDMkg7O0FBRXBMO0FBQ0EsRUFBRSw0REFBYztBQUNoQixTQUFTLGdGQUF1QjtBQUNoQztBQUNBO0FBQ0EsRUFBRSw0REFBYztBQUNoQixTQUFTLGdGQUF1QjtBQUNoQztBQUNBO0FBQ0EsRUFBRSw0REFBYztBQUNoQixTQUFTLG1FQUFVO0FBQ25COztBQUVBO0FBQ0Esc0RBQXNELElBQUk7QUFDMUQ7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0ZBQXdGLElBQUk7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0RBQVM7QUFDbkM7QUFDQSwwQkFBMEIsK0RBQVM7QUFDbkM7QUFDQSwwQkFBMEIsK0RBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsSUFBSSxHQUFHLE1BQU0sVUFBVTtBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsNkRBQU87QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw0REFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzREFBWTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFZLCtCQUErQixFQUFFLGlCQUFpQixvQkFBb0I7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHNCQUFzQixzREFBWSxnQ0FBZ0Msa0JBQWtCLGtCQUFrQix1QkFBdUI7QUFDN0g7QUFDQSxzQkFBc0Isc0RBQVksZ0NBQWdDLGtCQUFrQixTQUFTLFFBQVEsVUFBVSxZQUFZO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFZLHFDQUFxQyxhQUFhLHNEQUFzRCwyQkFBMkI7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRCQUE0QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFZLDhDQUE4QyxpQ0FBaUM7QUFDL0c7QUFDQSxvQkFBb0Isc0RBQVksNENBQTRDLCtCQUErQjtBQUMzRztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFZLDhCQUE4QiwyQkFBMkIsSUFBSSx3QkFBd0I7QUFDakgsd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBWSxnQkFBZ0IsMkJBQTJCLE1BQU0sMkJBQTJCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFGQUFxRjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isc0JBQXNCLE9BQU87QUFDN0Isd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0IsRUFBRSxrQkFBa0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrREFBUztBQUMvQjtBQUNBLHFCQUFxQiwrREFBUztBQUM5QjtBQUNBLHFCQUFxQiwrREFBUztBQUM5QjtBQUNBLHFCQUFxQiwrREFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUU7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVksRUFBRSxZQUFZLEVBQUUsTUFBTTtBQUNuRCxNQUFNO0FBQ04saUJBQWlCLFlBQVksRUFBRSxZQUFZO0FBQzNDLE1BQU07QUFDTixpQkFBaUIsc0NBQXNDLEVBQUUsRUFBRSxFQUFFLFlBQVk7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw2Q0FBNkMsbUNBQW1DO0FBQ2hGLFVBQVUsa0JBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQVksNEJBQTRCLDBCQUEwQix1Q0FBdUMsY0FBYztBQUN2STtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFZLDBCQUEwQiw0QkFBNEIsb0NBQW9DLFdBQVc7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxjQUFjLHNEQUFZO0FBQzFCO0FBQ0EsY0FBYyxzREFBWTtBQUMxQixVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLCtGQUErRiw2REFBTztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkRBQU87QUFDeEI7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBFQUFvQjtBQUNyQztBQUNBO0FBQ0Esd0JBQXdCLDBFQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRkFBa0YsMEJBQTBCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixvRkFBb0YsMEJBQTBCO0FBQzlHO0FBQ0EsZ0JBQWdCLHNEQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFZLDBEQUEwRCxhQUFhO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSw0QkFBNEIsb0dBQW9HO0FBQ3JNLHFFQUFxRSw0QkFBNEIsdUdBQXVHO0FBQ3hNLGdDQUFnQyx1Q0FBdUM7QUFDdkUsd0RBQXdEO0FBQ3hELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGNBQWMsc0RBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QyxzREFBc0QsWUFBWSxRQUFRLFdBQVc7QUFDckY7QUFDQTtBQUNBLFFBQVEsSUFBSTtBQUNaO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOENBQThDLGdCQUFnQjtBQUMzRjtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUJBQXFCLG9DQUFvQztBQUN6RDtBQUNBO0FBQ0EsUUFBUSw0REFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCwrREFBUztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZEQUE2RDtBQUNqRixzQ0FBc0MsSUFBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLDhEQUFVO0FBQ2pDLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkRBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsbUNBQW1DLEtBQUssS0FBSztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxrQ0FBa0MsS0FBSyxnQkFBZ0IsZ0JBQWdCLGdDQUFnQyxLQUFLLGdCQUFnQjtBQUM1SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQiw2SUFBNkk7QUFDekw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEtBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSw0REFBYztBQUNsQjtBQUNBO0FBQ0EsSUFBSSw0REFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdGQUF1QixxQkFBcUIsK0VBQW9CO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRSw0REFBYztBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDREQUFjO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBWSxlQUFlLEtBQUs7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQVksWUFBWSxNQUFNO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSw0REFBYztBQUNoQixTQUFTLHVGQUE2QjtBQUN0QztBQUNBO0FBQ0EsRUFBRSw0REFBYztBQUNoQixTQUFTLDZGQUFtQztBQUM1Qzs7QUFFQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9CQUFvQixlQUFlLEVBQUUsTUFBTSxJQUFJLGdDQUFnQztBQUMvRSxrQkFBa0IsZUFBZSxFQUFFLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRW01QiIsInNvdXJjZXMiOlsiL2hvbWUvYnJvbnplL2NvZGluZy9mc2FrbS9ub2RlX21vZHVsZXMvLnBucG0vQHNoaWtpanMrY29yZUAyLjUuMC9ub2RlX21vZHVsZXMvQHNoaWtpanMvY29yZS9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTaGlraUVycm9yIGFzIFNoaWtpRXJyb3IkMSB9IGZyb20gJ0BzaGlraWpzL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJ0BzaGlraWpzL3R5cGVzJztcbmltcG9ydCB7IGNyZWF0ZU9uaWd1cnVtYUVuZ2luZSBhcyBjcmVhdGVPbmlndXJ1bWFFbmdpbmUkMSwgbG9hZFdhc20gYXMgbG9hZFdhc20kMSwgZ2V0RGVmYXVsdFdhc21Mb2FkZXIgfSBmcm9tICdAc2hpa2lqcy9lbmdpbmUtb25pZ3VydW1hJztcbmltcG9ydCB7IHcgYXMgd2FybkRlcHJlY2F0ZWQgfSBmcm9tICcuL3NoYXJlZC9jb3JlLjVodjBMYXc5Lm1qcyc7XG5leHBvcnQgeyBlIGFzIGVuYWJsZURlcHJlY2F0aW9uV2FybmluZ3MgfSBmcm9tICcuL3NoYXJlZC9jb3JlLjVodjBMYXc5Lm1qcyc7XG5pbXBvcnQgeyBGb250U3R5bGUsIElOSVRJQUwsIEVuY29kZWRUb2tlbk1ldGFkYXRhLCBSZWdpc3RyeSBhcyBSZWdpc3RyeSQxLCBUaGVtZSB9IGZyb20gJ0BzaGlraWpzL3ZzY29kZS10ZXh0bWF0ZSc7XG5leHBvcnQgeyBGb250U3R5bGUsIEVuY29kZWRUb2tlbk1ldGFkYXRhIGFzIFN0YWNrRWxlbWVudE1ldGFkYXRhIH0gZnJvbSAnQHNoaWtpanMvdnNjb2RlLXRleHRtYXRlJztcbmltcG9ydCB7IHRvSHRtbCB9IGZyb20gJ2hhc3QtdXRpbC10by1odG1sJztcbmV4cG9ydCB7IHRvSHRtbCBhcyBoYXN0VG9IdG1sIH0gZnJvbSAnaGFzdC11dGlsLXRvLWh0bWwnO1xuaW1wb3J0IHsgY3JlYXRlSmF2YVNjcmlwdFJlZ2V4RW5naW5lIGFzIGNyZWF0ZUphdmFTY3JpcHRSZWdleEVuZ2luZSQxLCBkZWZhdWx0SmF2YVNjcmlwdFJlZ2V4Q29uc3RydWN0b3IgYXMgZGVmYXVsdEphdmFTY3JpcHRSZWdleENvbnN0cnVjdG9yJDEgfSBmcm9tICdAc2hpa2lqcy9lbmdpbmUtamF2YXNjcmlwdCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZU9uaWd1cnVtYUVuZ2luZShvcHRpb25zKSB7XG4gIHdhcm5EZXByZWNhdGVkKFwiaW1wb3J0IGBjcmVhdGVPbmlndXJ1bWFFbmdpbmVgIGZyb20gYEBzaGlraWpzL2VuZ2luZS1vbmlndXJ1bWFgIG9yIGBzaGlraS9lbmdpbmUvb25pZ3VydW1hYCBpbnN0ZWFkXCIpO1xuICByZXR1cm4gY3JlYXRlT25pZ3VydW1hRW5naW5lJDEob3B0aW9ucyk7XG59XG5mdW5jdGlvbiBjcmVhdGVXYXNtT25pZ0VuZ2luZShvcHRpb25zKSB7XG4gIHdhcm5EZXByZWNhdGVkKFwiaW1wb3J0IGBjcmVhdGVPbmlndXJ1bWFFbmdpbmVgIGZyb20gYEBzaGlraWpzL2VuZ2luZS1vbmlndXJ1bWFgIG9yIGBzaGlraS9lbmdpbmUvb25pZ3VydW1hYCBpbnN0ZWFkXCIpO1xuICByZXR1cm4gY3JlYXRlT25pZ3VydW1hRW5naW5lJDEob3B0aW9ucyk7XG59XG5mdW5jdGlvbiBsb2FkV2FzbShvcHRpb25zKSB7XG4gIHdhcm5EZXByZWNhdGVkKFwiaW1wb3J0IGBsb2FkV2FzbWAgZnJvbSBgQHNoaWtpanMvZW5naW5lLW9uaWd1cnVtYWAgb3IgYHNoaWtpL2VuZ2luZS9vbmlndXJ1bWFgIGluc3RlYWRcIik7XG4gIHJldHVybiBsb2FkV2FzbSQxKG9wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29sb3JSZXBsYWNlbWVudHModGhlbWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgcmVwbGFjZW1lbnRzID0gdHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiID8ge30gOiB7IC4uLnRoZW1lLmNvbG9yUmVwbGFjZW1lbnRzIH07XG4gIGNvbnN0IHRoZW1lTmFtZSA9IHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIiA/IHRoZW1lIDogdGhlbWUubmFtZTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucz8uY29sb3JSZXBsYWNlbWVudHMgfHwge30pKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHJlcGxhY2VtZW50c1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBpZiAoa2V5ID09PSB0aGVtZU5hbWUpXG4gICAgICBPYmplY3QuYXNzaWduKHJlcGxhY2VtZW50cywgdmFsdWUpO1xuICB9XG4gIHJldHVybiByZXBsYWNlbWVudHM7XG59XG5mdW5jdGlvbiBhcHBseUNvbG9yUmVwbGFjZW1lbnRzKGNvbG9yLCByZXBsYWNlbWVudHMpIHtcbiAgaWYgKCFjb2xvcilcbiAgICByZXR1cm4gY29sb3I7XG4gIHJldHVybiByZXBsYWNlbWVudHM/Lltjb2xvcj8udG9Mb3dlckNhc2UoKV0gfHwgY29sb3I7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkoeCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh4KSA/IHggOiBbeF07XG59XG5hc3luYyBmdW5jdGlvbiBub3JtYWxpemVHZXR0ZXIocCkge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHR5cGVvZiBwID09PSBcImZ1bmN0aW9uXCIgPyBwKCkgOiBwKS50aGVuKChyKSA9PiByLmRlZmF1bHQgfHwgcik7XG59XG5mdW5jdGlvbiBpc1BsYWluTGFuZyhsYW5nKSB7XG4gIHJldHVybiAhbGFuZyB8fCBbXCJwbGFpbnRleHRcIiwgXCJ0eHRcIiwgXCJ0ZXh0XCIsIFwicGxhaW5cIl0uaW5jbHVkZXMobGFuZyk7XG59XG5mdW5jdGlvbiBpc1NwZWNpYWxMYW5nKGxhbmcpIHtcbiAgcmV0dXJuIGxhbmcgPT09IFwiYW5zaVwiIHx8IGlzUGxhaW5MYW5nKGxhbmcpO1xufVxuZnVuY3Rpb24gaXNOb25lVGhlbWUodGhlbWUpIHtcbiAgcmV0dXJuIHRoZW1lID09PSBcIm5vbmVcIjtcbn1cbmZ1bmN0aW9uIGlzU3BlY2lhbFRoZW1lKHRoZW1lKSB7XG4gIHJldHVybiBpc05vbmVUaGVtZSh0aGVtZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENsYXNzVG9IYXN0KG5vZGUsIGNsYXNzTmFtZSkge1xuICBpZiAoIWNsYXNzTmFtZSlcbiAgICByZXR1cm4gbm9kZTtcbiAgbm9kZS5wcm9wZXJ0aWVzIHx8PSB7fTtcbiAgbm9kZS5wcm9wZXJ0aWVzLmNsYXNzIHx8PSBbXTtcbiAgaWYgKHR5cGVvZiBub2RlLnByb3BlcnRpZXMuY2xhc3MgPT09IFwic3RyaW5nXCIpXG4gICAgbm9kZS5wcm9wZXJ0aWVzLmNsYXNzID0gbm9kZS5wcm9wZXJ0aWVzLmNsYXNzLnNwbGl0KC9cXHMrL2cpO1xuICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZS5wcm9wZXJ0aWVzLmNsYXNzKSlcbiAgICBub2RlLnByb3BlcnRpZXMuY2xhc3MgPSBbXTtcbiAgY29uc3QgdGFyZ2V0cyA9IEFycmF5LmlzQXJyYXkoY2xhc3NOYW1lKSA/IGNsYXNzTmFtZSA6IGNsYXNzTmFtZS5zcGxpdCgvXFxzKy9nKTtcbiAgZm9yIChjb25zdCBjIG9mIHRhcmdldHMpIHtcbiAgICBpZiAoYyAmJiAhbm9kZS5wcm9wZXJ0aWVzLmNsYXNzLmluY2x1ZGVzKGMpKVxuICAgICAgbm9kZS5wcm9wZXJ0aWVzLmNsYXNzLnB1c2goYyk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIHNwbGl0TGluZXMoY29kZSwgcHJlc2VydmVFbmRpbmcgPSBmYWxzZSkge1xuICBjb25zdCBwYXJ0cyA9IGNvZGUuc3BsaXQoLyhcXHI/XFxuKS9nKTtcbiAgbGV0IGluZGV4ID0gMDtcbiAgY29uc3QgbGluZXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGNvbnN0IGxpbmUgPSBwcmVzZXJ2ZUVuZGluZyA/IHBhcnRzW2ldICsgKHBhcnRzW2kgKyAxXSB8fCBcIlwiKSA6IHBhcnRzW2ldO1xuICAgIGxpbmVzLnB1c2goW2xpbmUsIGluZGV4XSk7XG4gICAgaW5kZXggKz0gcGFydHNbaV0ubGVuZ3RoO1xuICAgIGluZGV4ICs9IHBhcnRzW2kgKyAxXT8ubGVuZ3RoIHx8IDA7XG4gIH1cbiAgcmV0dXJuIGxpbmVzO1xufVxuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25Db252ZXJ0ZXIoY29kZSkge1xuICBjb25zdCBsaW5lcyA9IHNwbGl0TGluZXMoY29kZSwgdHJ1ZSkubWFwKChbbGluZV0pID0+IGxpbmUpO1xuICBmdW5jdGlvbiBpbmRleFRvUG9zKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSBjb2RlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZTogbGluZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgY2hhcmFjdGVyOiBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGhcbiAgICAgIH07XG4gICAgfVxuICAgIGxldCBjaGFyYWN0ZXIgPSBpbmRleDtcbiAgICBsZXQgbGluZSA9IDA7XG4gICAgZm9yIChjb25zdCBsaW5lVGV4dCBvZiBsaW5lcykge1xuICAgICAgaWYgKGNoYXJhY3RlciA8IGxpbmVUZXh0Lmxlbmd0aClcbiAgICAgICAgYnJlYWs7XG4gICAgICBjaGFyYWN0ZXIgLT0gbGluZVRleHQubGVuZ3RoO1xuICAgICAgbGluZSsrO1xuICAgIH1cbiAgICByZXR1cm4geyBsaW5lLCBjaGFyYWN0ZXIgfTtcbiAgfVxuICBmdW5jdGlvbiBwb3NUb0luZGV4KGxpbmUsIGNoYXJhY3Rlcikge1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspXG4gICAgICBpbmRleCArPSBsaW5lc1tpXS5sZW5ndGg7XG4gICAgaW5kZXggKz0gY2hhcmFjdGVyO1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGxpbmVzLFxuICAgIGluZGV4VG9Qb3MsXG4gICAgcG9zVG9JbmRleFxuICB9O1xufVxuZnVuY3Rpb24gZ3Vlc3NFbWJlZGRlZExhbmd1YWdlcyhjb2RlLCBfbGFuZywgaGlnaGxpZ2h0ZXIpIHtcbiAgY29uc3QgbGFuZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IG1hdGNoIG9mIGNvZGUubWF0Y2hBbGwoL2xhbmc9W1wiJ10oW1xcdy1dKylbXCInXS9nKSkge1xuICAgIGxhbmdzLmFkZChtYXRjaFsxXSk7XG4gIH1cbiAgZm9yIChjb25zdCBtYXRjaCBvZiBjb2RlLm1hdGNoQWxsKC8oPzpgYGB8fn5+KShbXFx3LV0rKS9nKSkge1xuICAgIGxhbmdzLmFkZChtYXRjaFsxXSk7XG4gIH1cbiAgZm9yIChjb25zdCBtYXRjaCBvZiBjb2RlLm1hdGNoQWxsKC9cXFxcYmVnaW5cXHsoW1xcdy1dKylcXH0vZykpIHtcbiAgICBsYW5ncy5hZGQobWF0Y2hbMV0pO1xuICB9XG4gIGlmICghaGlnaGxpZ2h0ZXIpXG4gICAgcmV0dXJuIEFycmF5LmZyb20obGFuZ3MpO1xuICBjb25zdCBidW5kbGUgPSBoaWdobGlnaHRlci5nZXRCdW5kbGVkTGFuZ3VhZ2VzKCk7XG4gIHJldHVybiBBcnJheS5mcm9tKGxhbmdzKS5maWx0ZXIoKGwpID0+IGwgJiYgYnVuZGxlW2xdKTtcbn1cblxuZnVuY3Rpb24gc3BsaXRUb2tlbih0b2tlbiwgb2Zmc2V0cykge1xuICBsZXQgbGFzdE9mZnNldCA9IDA7XG4gIGNvbnN0IHRva2VucyA9IFtdO1xuICBmb3IgKGNvbnN0IG9mZnNldCBvZiBvZmZzZXRzKSB7XG4gICAgaWYgKG9mZnNldCA+IGxhc3RPZmZzZXQpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgLi4udG9rZW4sXG4gICAgICAgIGNvbnRlbnQ6IHRva2VuLmNvbnRlbnQuc2xpY2UobGFzdE9mZnNldCwgb2Zmc2V0KSxcbiAgICAgICAgb2Zmc2V0OiB0b2tlbi5vZmZzZXQgKyBsYXN0T2Zmc2V0XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgfVxuICBpZiAobGFzdE9mZnNldCA8IHRva2VuLmNvbnRlbnQubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgLi4udG9rZW4sXG4gICAgICBjb250ZW50OiB0b2tlbi5jb250ZW50LnNsaWNlKGxhc3RPZmZzZXQpLFxuICAgICAgb2Zmc2V0OiB0b2tlbi5vZmZzZXQgKyBsYXN0T2Zmc2V0XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRva2Vucztcbn1cbmZ1bmN0aW9uIHNwbGl0VG9rZW5zKHRva2VucywgYnJlYWtwb2ludHMpIHtcbiAgY29uc3Qgc29ydGVkID0gQXJyYXkuZnJvbShicmVha3BvaW50cyBpbnN0YW5jZW9mIFNldCA/IGJyZWFrcG9pbnRzIDogbmV3IFNldChicmVha3BvaW50cykpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgaWYgKCFzb3J0ZWQubGVuZ3RoKVxuICAgIHJldHVybiB0b2tlbnM7XG4gIHJldHVybiB0b2tlbnMubWFwKChsaW5lKSA9PiB7XG4gICAgcmV0dXJuIGxpbmUuZmxhdE1hcCgodG9rZW4pID0+IHtcbiAgICAgIGNvbnN0IGJyZWFrcG9pbnRzSW5Ub2tlbiA9IHNvcnRlZC5maWx0ZXIoKGkpID0+IHRva2VuLm9mZnNldCA8IGkgJiYgaSA8IHRva2VuLm9mZnNldCArIHRva2VuLmNvbnRlbnQubGVuZ3RoKS5tYXAoKGkpID0+IGkgLSB0b2tlbi5vZmZzZXQpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgIGlmICghYnJlYWtwb2ludHNJblRva2VuLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgcmV0dXJuIHNwbGl0VG9rZW4odG9rZW4sIGJyZWFrcG9pbnRzSW5Ub2tlbik7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZmxhdFRva2VuVmFyaWFudHMobWVyZ2VkLCB2YXJpYW50c09yZGVyLCBjc3NWYXJpYWJsZVByZWZpeCwgZGVmYXVsdENvbG9yKSB7XG4gIGNvbnN0IHRva2VuID0ge1xuICAgIGNvbnRlbnQ6IG1lcmdlZC5jb250ZW50LFxuICAgIGV4cGxhbmF0aW9uOiBtZXJnZWQuZXhwbGFuYXRpb24sXG4gICAgb2Zmc2V0OiBtZXJnZWQub2Zmc2V0XG4gIH07XG4gIGNvbnN0IHN0eWxlcyA9IHZhcmlhbnRzT3JkZXIubWFwKCh0KSA9PiBnZXRUb2tlblN0eWxlT2JqZWN0KG1lcmdlZC52YXJpYW50c1t0XSkpO1xuICBjb25zdCBzdHlsZUtleXMgPSBuZXcgU2V0KHN0eWxlcy5mbGF0TWFwKCh0KSA9PiBPYmplY3Qua2V5cyh0KSkpO1xuICBjb25zdCBtZXJnZWRTdHlsZXMgPSB7fTtcbiAgc3R5bGVzLmZvckVhY2goKGN1ciwgaWR4KSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygc3R5bGVLZXlzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGN1cltrZXldIHx8IFwiaW5oZXJpdFwiO1xuICAgICAgaWYgKGlkeCA9PT0gMCAmJiBkZWZhdWx0Q29sb3IpIHtcbiAgICAgICAgbWVyZ2VkU3R5bGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGtleU5hbWUgPSBrZXkgPT09IFwiY29sb3JcIiA/IFwiXCIgOiBrZXkgPT09IFwiYmFja2dyb3VuZC1jb2xvclwiID8gXCItYmdcIiA6IGAtJHtrZXl9YDtcbiAgICAgICAgY29uc3QgdmFyS2V5ID0gY3NzVmFyaWFibGVQcmVmaXggKyB2YXJpYW50c09yZGVyW2lkeF0gKyAoa2V5ID09PSBcImNvbG9yXCIgPyBcIlwiIDoga2V5TmFtZSk7XG4gICAgICAgIG1lcmdlZFN0eWxlc1t2YXJLZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdG9rZW4uaHRtbFN0eWxlID0gbWVyZ2VkU3R5bGVzO1xuICByZXR1cm4gdG9rZW47XG59XG5mdW5jdGlvbiBnZXRUb2tlblN0eWxlT2JqZWN0KHRva2VuKSB7XG4gIGNvbnN0IHN0eWxlcyA9IHt9O1xuICBpZiAodG9rZW4uY29sb3IpXG4gICAgc3R5bGVzLmNvbG9yID0gdG9rZW4uY29sb3I7XG4gIGlmICh0b2tlbi5iZ0NvbG9yKVxuICAgIHN0eWxlc1tcImJhY2tncm91bmQtY29sb3JcIl0gPSB0b2tlbi5iZ0NvbG9yO1xuICBpZiAodG9rZW4uZm9udFN0eWxlKSB7XG4gICAgaWYgKHRva2VuLmZvbnRTdHlsZSAmIEZvbnRTdHlsZS5JdGFsaWMpXG4gICAgICBzdHlsZXNbXCJmb250LXN0eWxlXCJdID0gXCJpdGFsaWNcIjtcbiAgICBpZiAodG9rZW4uZm9udFN0eWxlICYgRm9udFN0eWxlLkJvbGQpXG4gICAgICBzdHlsZXNbXCJmb250LXdlaWdodFwiXSA9IFwiYm9sZFwiO1xuICAgIGlmICh0b2tlbi5mb250U3R5bGUgJiBGb250U3R5bGUuVW5kZXJsaW5lKVxuICAgICAgc3R5bGVzW1widGV4dC1kZWNvcmF0aW9uXCJdID0gXCJ1bmRlcmxpbmVcIjtcbiAgfVxuICByZXR1cm4gc3R5bGVzO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5VG9rZW5TdHlsZSh0b2tlbikge1xuICBpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiB0b2tlbjtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHRva2VuKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fToke3ZhbHVlfWApLmpvaW4oXCI7XCIpO1xufVxuXG5jb25zdCBfZ3JhbW1hclN0YXRlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBzZXRMYXN0R3JhbW1hclN0YXRlVG9NYXAoa2V5cywgc3RhdGUpIHtcbiAgX2dyYW1tYXJTdGF0ZU1hcC5zZXQoa2V5cywgc3RhdGUpO1xufVxuZnVuY3Rpb24gZ2V0TGFzdEdyYW1tYXJTdGF0ZUZyb21NYXAoa2V5cykge1xuICByZXR1cm4gX2dyYW1tYXJTdGF0ZU1hcC5nZXQoa2V5cyk7XG59XG5jbGFzcyBHcmFtbWFyU3RhdGUge1xuICAvKipcbiAgICogVGhlbWUgdG8gU3RhY2sgbWFwcGluZ1xuICAgKi9cbiAgX3N0YWNrcyA9IHt9O1xuICBsYW5nO1xuICBnZXQgdGhlbWVzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9zdGFja3MpO1xuICB9XG4gIGdldCB0aGVtZSgpIHtcbiAgICByZXR1cm4gdGhpcy50aGVtZXNbMF07XG4gIH1cbiAgZ2V0IF9zdGFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhY2tzW3RoaXMudGhlbWVdO1xuICB9XG4gIC8qKlxuICAgKiBTdGF0aWMgbWV0aG9kIHRvIGNyZWF0ZSBhIGluaXRpYWwgZ3JhbW1hciBzdGF0ZS5cbiAgICovXG4gIHN0YXRpYyBpbml0aWFsKGxhbmcsIHRoZW1lcykge1xuICAgIHJldHVybiBuZXcgR3JhbW1hclN0YXRlKFxuICAgICAgT2JqZWN0LmZyb21FbnRyaWVzKHRvQXJyYXkodGhlbWVzKS5tYXAoKHRoZW1lKSA9PiBbdGhlbWUsIElOSVRJQUxdKSksXG4gICAgICBsYW5nXG4gICAgKTtcbiAgfVxuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBbc3RhY2tzTWFwLCBsYW5nXSA9IGFyZ3M7XG4gICAgICB0aGlzLmxhbmcgPSBsYW5nO1xuICAgICAgdGhpcy5fc3RhY2tzID0gc3RhY2tzTWFwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbc3RhY2ssIGxhbmcsIHRoZW1lXSA9IGFyZ3M7XG4gICAgICB0aGlzLmxhbmcgPSBsYW5nO1xuICAgICAgdGhpcy5fc3RhY2tzID0geyBbdGhlbWVdOiBzdGFjayB9O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBpbnRlcm5hbCBzdGFjayBvYmplY3QuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0SW50ZXJuYWxTdGFjayh0aGVtZSA9IHRoaXMudGhlbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhY2tzW3RoZW1lXTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBnZXRTY29wZXNgIGluc3RlYWRcbiAgICovXG4gIGdldCBzY29wZXMoKSB7XG4gICAgd2FybkRlcHJlY2F0ZWQoXCJHcmFtbWFyU3RhdGUuc2NvcGVzIGlzIGRlcHJlY2F0ZWQsIHVzZSBHcmFtbWFyU3RhdGUuZ2V0U2NvcGVzKCkgaW5zdGVhZFwiKTtcbiAgICByZXR1cm4gZ2V0U2NvcGVzKHRoaXMuX3N0YWNrc1t0aGlzLnRoZW1lXSk7XG4gIH1cbiAgZ2V0U2NvcGVzKHRoZW1lID0gdGhpcy50aGVtZSkge1xuICAgIHJldHVybiBnZXRTY29wZXModGhpcy5fc3RhY2tzW3RoZW1lXSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsYW5nOiB0aGlzLmxhbmcsXG4gICAgICB0aGVtZTogdGhpcy50aGVtZSxcbiAgICAgIHRoZW1lczogdGhpcy50aGVtZXMsXG4gICAgICBzY29wZXM6IHRoaXMuZ2V0U2NvcGVzKClcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBnZXRTY29wZXMoc3RhY2spIHtcbiAgY29uc3Qgc2NvcGVzID0gW107XG4gIGNvbnN0IHZpc2l0ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmdW5jdGlvbiBwdXNoU2NvcGUoc3RhY2syKSB7XG4gICAgaWYgKHZpc2l0ZWQuaGFzKHN0YWNrMikpXG4gICAgICByZXR1cm47XG4gICAgdmlzaXRlZC5hZGQoc3RhY2syKTtcbiAgICBjb25zdCBuYW1lID0gc3RhY2syPy5uYW1lU2NvcGVzTGlzdD8uc2NvcGVOYW1lO1xuICAgIGlmIChuYW1lKVxuICAgICAgc2NvcGVzLnB1c2gobmFtZSk7XG4gICAgaWYgKHN0YWNrMi5wYXJlbnQpXG4gICAgICBwdXNoU2NvcGUoc3RhY2syLnBhcmVudCk7XG4gIH1cbiAgcHVzaFNjb3BlKHN0YWNrKTtcbiAgcmV0dXJuIHNjb3Blcztcbn1cbmZ1bmN0aW9uIGdldEdyYW1tYXJTdGFjayhzdGF0ZSwgdGhlbWUpIHtcbiAgaWYgKCEoc3RhdGUgaW5zdGFuY2VvZiBHcmFtbWFyU3RhdGUpKVxuICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoXCJJbnZhbGlkIGdyYW1tYXIgc3RhdGVcIik7XG4gIHJldHVybiBzdGF0ZS5nZXRJbnRlcm5hbFN0YWNrKHRoZW1lKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtZXJEZWNvcmF0aW9ucygpIHtcbiAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIGZ1bmN0aW9uIGdldENvbnRleHQoc2hpa2kpIHtcbiAgICBpZiAoIW1hcC5oYXMoc2hpa2kubWV0YSkpIHtcbiAgICAgIGxldCBub3JtYWxpemVQb3NpdGlvbiA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgaWYgKHAgPCAwIHx8IHAgPiBzaGlraS5zb3VyY2UubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgSW52YWxpZCBkZWNvcmF0aW9uIG9mZnNldDogJHtwfS4gQ29kZSBsZW5ndGg6ICR7c2hpa2kuc291cmNlLmxlbmd0aH1gKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29udmVydGVyLmluZGV4VG9Qb3MocCksXG4gICAgICAgICAgICBvZmZzZXQ6IHBcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGxpbmUgPSBjb252ZXJ0ZXIubGluZXNbcC5saW5lXTtcbiAgICAgICAgICBpZiAobGluZSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgSW52YWxpZCBkZWNvcmF0aW9uIHBvc2l0aW9uICR7SlNPTi5zdHJpbmdpZnkocCl9LiBMaW5lcyBsZW5ndGg6ICR7Y29udmVydGVyLmxpbmVzLmxlbmd0aH1gKTtcbiAgICAgICAgICBpZiAocC5jaGFyYWN0ZXIgPCAwIHx8IHAuY2hhcmFjdGVyID4gbGluZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKGBJbnZhbGlkIGRlY29yYXRpb24gcG9zaXRpb24gJHtKU09OLnN0cmluZ2lmeShwKX0uIExpbmUgJHtwLmxpbmV9IGxlbmd0aDogJHtsaW5lLmxlbmd0aH1gKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucCxcbiAgICAgICAgICAgIG9mZnNldDogY29udmVydGVyLnBvc1RvSW5kZXgocC5saW5lLCBwLmNoYXJhY3RlcilcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgY29udmVydGVyID0gY3JlYXRlUG9zaXRpb25Db252ZXJ0ZXIoc2hpa2kuc291cmNlKTtcbiAgICAgIGNvbnN0IGRlY29yYXRpb25zID0gKHNoaWtpLm9wdGlvbnMuZGVjb3JhdGlvbnMgfHwgW10pLm1hcCgoZCkgPT4gKHtcbiAgICAgICAgLi4uZCxcbiAgICAgICAgc3RhcnQ6IG5vcm1hbGl6ZVBvc2l0aW9uKGQuc3RhcnQpLFxuICAgICAgICBlbmQ6IG5vcm1hbGl6ZVBvc2l0aW9uKGQuZW5kKVxuICAgICAgfSkpO1xuICAgICAgdmVyaWZ5SW50ZXJzZWN0aW9ucyhkZWNvcmF0aW9ucyk7XG4gICAgICBtYXAuc2V0KHNoaWtpLm1ldGEsIHtcbiAgICAgICAgZGVjb3JhdGlvbnMsXG4gICAgICAgIGNvbnZlcnRlcixcbiAgICAgICAgc291cmNlOiBzaGlraS5zb3VyY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFwLmdldChzaGlraS5tZXRhKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6IFwic2hpa2k6ZGVjb3JhdGlvbnNcIixcbiAgICB0b2tlbnModG9rZW5zKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5kZWNvcmF0aW9ucz8ubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBjdHggPSBnZXRDb250ZXh0KHRoaXMpO1xuICAgICAgY29uc3QgYnJlYWtwb2ludHMgPSBjdHguZGVjb3JhdGlvbnMuZmxhdE1hcCgoZCkgPT4gW2Quc3RhcnQub2Zmc2V0LCBkLmVuZC5vZmZzZXRdKTtcbiAgICAgIGNvbnN0IHNwbGl0dGVkID0gc3BsaXRUb2tlbnModG9rZW5zLCBicmVha3BvaW50cyk7XG4gICAgICByZXR1cm4gc3BsaXR0ZWQ7XG4gICAgfSxcbiAgICBjb2RlKGNvZGVFbCkge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGVjb3JhdGlvbnM/Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgY3R4ID0gZ2V0Q29udGV4dCh0aGlzKTtcbiAgICAgIGNvbnN0IGxpbmVzID0gQXJyYXkuZnJvbShjb2RlRWwuY2hpbGRyZW4pLmZpbHRlcigoaSkgPT4gaS50eXBlID09PSBcImVsZW1lbnRcIiAmJiBpLnRhZ05hbWUgPT09IFwic3BhblwiKTtcbiAgICAgIGlmIChsaW5lcy5sZW5ndGggIT09IGN0eC5jb252ZXJ0ZXIubGluZXMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKGBOdW1iZXIgb2YgbGluZXMgaW4gY29kZSBlbGVtZW50ICgke2xpbmVzLmxlbmd0aH0pIGRvZXMgbm90IG1hdGNoIHRoZSBudW1iZXIgb2YgbGluZXMgaW4gdGhlIHNvdXJjZSAoJHtjdHguY29udmVydGVyLmxpbmVzLmxlbmd0aH0pLiBGYWlsZWQgdG8gYXBwbHkgZGVjb3JhdGlvbnMuYCk7XG4gICAgICBmdW5jdGlvbiBhcHBseUxpbmVTZWN0aW9uKGxpbmUsIHN0YXJ0LCBlbmQsIGRlY29yYXRpb24pIHtcbiAgICAgICAgY29uc3QgbGluZUVsID0gbGluZXNbbGluZV07XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSAtMTtcbiAgICAgICAgbGV0IGVuZEluZGV4ID0gLTE7XG4gICAgICAgIGlmIChzdGFydCA9PT0gMClcbiAgICAgICAgICBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgaWYgKGVuZCA9PT0gMClcbiAgICAgICAgICBlbmRJbmRleCA9IDA7XG4gICAgICAgIGlmIChlbmQgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbiAgICAgICAgICBlbmRJbmRleCA9IGxpbmVFbC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIGlmIChzdGFydEluZGV4ID09PSAtMSB8fCBlbmRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVFbC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGV4dCArPSBzdHJpbmdpZnkobGluZUVsLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4ID09PSAtMSAmJiB0ZXh0Lmxlbmd0aCA9PT0gc3RhcnQpXG4gICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIGlmIChlbmRJbmRleCA9PT0gLTEgJiYgdGV4dC5sZW5ndGggPT09IGVuZClcbiAgICAgICAgICAgICAgZW5kSW5kZXggPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IC0xKVxuICAgICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoYEZhaWxlZCB0byBmaW5kIHN0YXJ0IGluZGV4IGZvciBkZWNvcmF0aW9uICR7SlNPTi5zdHJpbmdpZnkoZGVjb3JhdGlvbi5zdGFydCl9YCk7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PT0gLTEpXG4gICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgRmFpbGVkIHRvIGZpbmQgZW5kIGluZGV4IGZvciBkZWNvcmF0aW9uICR7SlNPTi5zdHJpbmdpZnkoZGVjb3JhdGlvbi5lbmQpfWApO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGxpbmVFbC5jaGlsZHJlbi5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgICAgIGlmICghZGVjb3JhdGlvbi5hbHdheXNXcmFwICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gbGluZUVsLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIGFwcGx5RGVjb3JhdGlvbihsaW5lRWwsIGRlY29yYXRpb24sIFwibGluZVwiKTtcbiAgICAgICAgfSBlbHNlIGlmICghZGVjb3JhdGlvbi5hbHdheXNXcmFwICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZHJlblswXS50eXBlID09PSBcImVsZW1lbnRcIikge1xuICAgICAgICAgIGFwcGx5RGVjb3JhdGlvbihjaGlsZHJlblswXSwgZGVjb3JhdGlvbiwgXCJ0b2tlblwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB3cmFwcGVyID0ge1xuICAgICAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgICAgICB0YWdOYW1lOiBcInNwYW5cIixcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICB9O1xuICAgICAgICAgIGFwcGx5RGVjb3JhdGlvbih3cmFwcGVyLCBkZWNvcmF0aW9uLCBcIndyYXBwZXJcIik7XG4gICAgICAgICAgbGluZUVsLmNoaWxkcmVuLnNwbGljZShzdGFydEluZGV4LCBjaGlsZHJlbi5sZW5ndGgsIHdyYXBwZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcHBseUxpbmUobGluZSwgZGVjb3JhdGlvbikge1xuICAgICAgICBsaW5lc1tsaW5lXSA9IGFwcGx5RGVjb3JhdGlvbihsaW5lc1tsaW5lXSwgZGVjb3JhdGlvbiwgXCJsaW5lXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXBwbHlEZWNvcmF0aW9uKGVsLCBkZWNvcmF0aW9uLCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkZWNvcmF0aW9uLnByb3BlcnRpZXMgfHwge307XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGRlY29yYXRpb24udHJhbnNmb3JtIHx8ICgoaSkgPT4gaSk7XG4gICAgICAgIGVsLnRhZ05hbWUgPSBkZWNvcmF0aW9uLnRhZ05hbWUgfHwgXCJzcGFuXCI7XG4gICAgICAgIGVsLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgLi4uZWwucHJvcGVydGllcyxcbiAgICAgICAgICAuLi5wcm9wZXJ0aWVzLFxuICAgICAgICAgIGNsYXNzOiBlbC5wcm9wZXJ0aWVzLmNsYXNzXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWNvcmF0aW9uLnByb3BlcnRpZXM/LmNsYXNzKVxuICAgICAgICAgIGFkZENsYXNzVG9IYXN0KGVsLCBkZWNvcmF0aW9uLnByb3BlcnRpZXMuY2xhc3MpO1xuICAgICAgICBlbCA9IHRyYW5zZm9ybShlbCwgdHlwZSkgfHwgZWw7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbmVBcHBsaWVzID0gW107XG4gICAgICBjb25zdCBzb3J0ZWQgPSBjdHguZGVjb3JhdGlvbnMuc29ydCgoYSwgYikgPT4gYi5zdGFydC5vZmZzZXQgLSBhLnN0YXJ0Lm9mZnNldCB8fCBhLmVuZC5vZmZzZXQgLSBiLmVuZC5vZmZzZXQpO1xuICAgICAgZm9yIChjb25zdCBkZWNvcmF0aW9uIG9mIHNvcnRlZCkge1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IGRlY29yYXRpb247XG4gICAgICAgIGlmIChzdGFydC5saW5lID09PSBlbmQubGluZSkge1xuICAgICAgICAgIGFwcGx5TGluZVNlY3Rpb24oc3RhcnQubGluZSwgc3RhcnQuY2hhcmFjdGVyLCBlbmQuY2hhcmFjdGVyLCBkZWNvcmF0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydC5saW5lIDwgZW5kLmxpbmUpIHtcbiAgICAgICAgICBhcHBseUxpbmVTZWN0aW9uKHN0YXJ0LmxpbmUsIHN0YXJ0LmNoYXJhY3RlciwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBkZWNvcmF0aW9uKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQubGluZSArIDE7IGkgPCBlbmQubGluZTsgaSsrKVxuICAgICAgICAgICAgbGluZUFwcGxpZXMudW5zaGlmdCgoKSA9PiBhcHBseUxpbmUoaSwgZGVjb3JhdGlvbikpO1xuICAgICAgICAgIGFwcGx5TGluZVNlY3Rpb24oZW5kLmxpbmUsIDAsIGVuZC5jaGFyYWN0ZXIsIGRlY29yYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaW5lQXBwbGllcy5mb3JFYWNoKChpKSA9PiBpKCkpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHZlcmlmeUludGVyc2VjdGlvbnMoaXRlbXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGZvbyA9IGl0ZW1zW2ldO1xuICAgIGlmIChmb28uc3RhcnQub2Zmc2V0ID4gZm9vLmVuZC5vZmZzZXQpXG4gICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKGBJbnZhbGlkIGRlY29yYXRpb24gcmFuZ2U6ICR7SlNPTi5zdHJpbmdpZnkoZm9vLnN0YXJ0KX0gLSAke0pTT04uc3RyaW5naWZ5KGZvby5lbmQpfWApO1xuICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGl0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBiYXIgPSBpdGVtc1tqXTtcbiAgICAgIGNvbnN0IGlzRm9vSGFzQmFyU3RhcnQgPSBmb28uc3RhcnQub2Zmc2V0IDw9IGJhci5zdGFydC5vZmZzZXQgJiYgYmFyLnN0YXJ0Lm9mZnNldCA8IGZvby5lbmQub2Zmc2V0O1xuICAgICAgY29uc3QgaXNGb29IYXNCYXJFbmQgPSBmb28uc3RhcnQub2Zmc2V0IDwgYmFyLmVuZC5vZmZzZXQgJiYgYmFyLmVuZC5vZmZzZXQgPD0gZm9vLmVuZC5vZmZzZXQ7XG4gICAgICBjb25zdCBpc0Jhckhhc0Zvb1N0YXJ0ID0gYmFyLnN0YXJ0Lm9mZnNldCA8PSBmb28uc3RhcnQub2Zmc2V0ICYmIGZvby5zdGFydC5vZmZzZXQgPCBiYXIuZW5kLm9mZnNldDtcbiAgICAgIGNvbnN0IGlzQmFySGFzRm9vRW5kID0gYmFyLnN0YXJ0Lm9mZnNldCA8IGZvby5lbmQub2Zmc2V0ICYmIGZvby5lbmQub2Zmc2V0IDw9IGJhci5lbmQub2Zmc2V0O1xuICAgICAgaWYgKGlzRm9vSGFzQmFyU3RhcnQgfHwgaXNGb29IYXNCYXJFbmQgfHwgaXNCYXJIYXNGb29TdGFydCB8fCBpc0Jhckhhc0Zvb0VuZCkge1xuICAgICAgICBpZiAoaXNGb29IYXNCYXJTdGFydCAmJiBpc0Zvb0hhc0JhckVuZClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGlzQmFySGFzRm9vU3RhcnQgJiYgaXNCYXJIYXNGb29FbmQpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoYERlY29yYXRpb25zICR7SlNPTi5zdHJpbmdpZnkoZm9vLnN0YXJ0KX0gYW5kICR7SlNPTi5zdHJpbmdpZnkoYmFyLnN0YXJ0KX0gaW50ZXJzZWN0LmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3RyaW5naWZ5KGVsKSB7XG4gIGlmIChlbC50eXBlID09PSBcInRleHRcIilcbiAgICByZXR1cm4gZWwudmFsdWU7XG4gIGlmIChlbC50eXBlID09PSBcImVsZW1lbnRcIilcbiAgICByZXR1cm4gZWwuY2hpbGRyZW4ubWFwKHN0cmluZ2lmeSkuam9pbihcIlwiKTtcbiAgcmV0dXJuIFwiXCI7XG59XG5cbmNvbnN0IGJ1aWx0SW5UcmFuc2Zvcm1lcnMgPSBbXG4gIC8qIEBfX1BVUkVfXyAqLyB0cmFuc2Zvcm1lckRlY29yYXRpb25zKClcbl07XG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1lcnMob3B0aW9ucykge1xuICByZXR1cm4gW1xuICAgIC4uLm9wdGlvbnMudHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgIC4uLmJ1aWx0SW5UcmFuc2Zvcm1lcnNcbiAgXTtcbn1cblxuLy8gc3JjL2NvbG9ycy50c1xudmFyIG5hbWVkQ29sb3JzID0gW1xuICBcImJsYWNrXCIsXG4gIFwicmVkXCIsXG4gIFwiZ3JlZW5cIixcbiAgXCJ5ZWxsb3dcIixcbiAgXCJibHVlXCIsXG4gIFwibWFnZW50YVwiLFxuICBcImN5YW5cIixcbiAgXCJ3aGl0ZVwiLFxuICBcImJyaWdodEJsYWNrXCIsXG4gIFwiYnJpZ2h0UmVkXCIsXG4gIFwiYnJpZ2h0R3JlZW5cIixcbiAgXCJicmlnaHRZZWxsb3dcIixcbiAgXCJicmlnaHRCbHVlXCIsXG4gIFwiYnJpZ2h0TWFnZW50YVwiLFxuICBcImJyaWdodEN5YW5cIixcbiAgXCJicmlnaHRXaGl0ZVwiXG5dO1xuXG4vLyBzcmMvZGVjb3JhdGlvbnMudHNcbnZhciBkZWNvcmF0aW9ucyA9IHtcbiAgMTogXCJib2xkXCIsXG4gIDI6IFwiZGltXCIsXG4gIDM6IFwiaXRhbGljXCIsXG4gIDQ6IFwidW5kZXJsaW5lXCIsXG4gIDc6IFwicmV2ZXJzZVwiLFxuICA4OiBcImhpZGRlblwiLFxuICA5OiBcInN0cmlrZXRocm91Z2hcIlxufTtcblxuLy8gc3JjL3BhcnNlci50c1xuZnVuY3Rpb24gZmluZFNlcXVlbmNlKHZhbHVlLCBwb3NpdGlvbikge1xuICBjb25zdCBuZXh0RXNjYXBlID0gdmFsdWUuaW5kZXhPZihcIlxceDFCXCIsIHBvc2l0aW9uKTtcbiAgaWYgKG5leHRFc2NhcGUgIT09IC0xKSB7XG4gICAgaWYgKHZhbHVlW25leHRFc2NhcGUgKyAxXSA9PT0gXCJbXCIpIHtcbiAgICAgIGNvbnN0IG5leHRDbG9zZSA9IHZhbHVlLmluZGV4T2YoXCJtXCIsIG5leHRFc2NhcGUpO1xuICAgICAgaWYgKG5leHRDbG9zZSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzZXF1ZW5jZTogdmFsdWUuc3Vic3RyaW5nKG5leHRFc2NhcGUgKyAyLCBuZXh0Q2xvc2UpLnNwbGl0KFwiO1wiKSxcbiAgICAgICAgICBzdGFydFBvc2l0aW9uOiBuZXh0RXNjYXBlLFxuICAgICAgICAgIHBvc2l0aW9uOiBuZXh0Q2xvc2UgKyAxXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IHZhbHVlLmxlbmd0aFxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VDb2xvcihzZXF1ZW5jZSkge1xuICBjb25zdCBjb2xvck1vZGUgPSBzZXF1ZW5jZS5zaGlmdCgpO1xuICBpZiAoY29sb3JNb2RlID09PSBcIjJcIikge1xuICAgIGNvbnN0IHJnYiA9IHNlcXVlbmNlLnNwbGljZSgwLCAzKS5tYXAoKHgpID0+IE51bWJlci5wYXJzZUludCh4KSk7XG4gICAgaWYgKHJnYi5sZW5ndGggIT09IDMgfHwgcmdiLnNvbWUoKHgpID0+IE51bWJlci5pc05hTih4KSkpXG4gICAgICByZXR1cm47XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicmdiXCIsXG4gICAgICByZ2JcbiAgICB9O1xuICB9IGVsc2UgaWYgKGNvbG9yTW9kZSA9PT0gXCI1XCIpIHtcbiAgICBjb25zdCBpbmRleCA9IHNlcXVlbmNlLnNoaWZ0KCk7XG4gICAgaWYgKGluZGV4KSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRhYmxlXCIsIGluZGV4OiBOdW1iZXIoaW5kZXgpIH07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwYXJzZVNlcXVlbmNlKHNlcXVlbmNlKSB7XG4gIGNvbnN0IGNvbW1hbmRzID0gW107XG4gIHdoaWxlIChzZXF1ZW5jZS5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgY29kZSA9IHNlcXVlbmNlLnNoaWZ0KCk7XG4gICAgaWYgKCFjb2RlKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgY29kZUludCA9IE51bWJlci5wYXJzZUludChjb2RlKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGNvZGVJbnQpKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKGNvZGVJbnQgPT09IDApIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goeyB0eXBlOiBcInJlc2V0QWxsXCIgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlSW50IDw9IDkpIHtcbiAgICAgIGNvbnN0IGRlY29yYXRpb24gPSBkZWNvcmF0aW9uc1tjb2RlSW50XTtcbiAgICAgIGlmIChkZWNvcmF0aW9uKSB7XG4gICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwic2V0RGVjb3JhdGlvblwiLFxuICAgICAgICAgIHZhbHVlOiBkZWNvcmF0aW9uc1tjb2RlSW50XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvZGVJbnQgPD0gMjkpIHtcbiAgICAgIGNvbnN0IGRlY29yYXRpb24gPSBkZWNvcmF0aW9uc1tjb2RlSW50IC0gMjBdO1xuICAgICAgaWYgKGRlY29yYXRpb24pIHtcbiAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJyZXNldERlY29yYXRpb25cIixcbiAgICAgICAgICB2YWx1ZTogZGVjb3JhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRlY29yYXRpb24gPT09IFwiZGltXCIpIHtcbiAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwicmVzZXREZWNvcmF0aW9uXCIsXG4gICAgICAgICAgICB2YWx1ZTogXCJib2xkXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29kZUludCA8PSAzNykge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwic2V0Rm9yZWdyb3VuZENvbG9yXCIsXG4gICAgICAgIHZhbHVlOiB7IHR5cGU6IFwibmFtZWRcIiwgbmFtZTogbmFtZWRDb2xvcnNbY29kZUludCAtIDMwXSB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGVJbnQgPT09IDM4KSB7XG4gICAgICBjb25zdCBjb2xvciA9IHBhcnNlQ29sb3Ioc2VxdWVuY2UpO1xuICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwic2V0Rm9yZWdyb3VuZENvbG9yXCIsXG4gICAgICAgICAgdmFsdWU6IGNvbG9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29kZUludCA9PT0gMzkpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInJlc2V0Rm9yZWdyb3VuZENvbG9yXCJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZUludCA8PSA0Nykge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwic2V0QmFja2dyb3VuZENvbG9yXCIsXG4gICAgICAgIHZhbHVlOiB7IHR5cGU6IFwibmFtZWRcIiwgbmFtZTogbmFtZWRDb2xvcnNbY29kZUludCAtIDQwXSB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGVJbnQgPT09IDQ4KSB7XG4gICAgICBjb25zdCBjb2xvciA9IHBhcnNlQ29sb3Ioc2VxdWVuY2UpO1xuICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwic2V0QmFja2dyb3VuZENvbG9yXCIsXG4gICAgICAgICAgdmFsdWU6IGNvbG9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29kZUludCA9PT0gNDkpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInJlc2V0QmFja2dyb3VuZENvbG9yXCJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZUludCA9PT0gNTMpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInNldERlY29yYXRpb25cIixcbiAgICAgICAgdmFsdWU6IFwib3ZlcmxpbmVcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlSW50ID09PSA1NSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwicmVzZXREZWNvcmF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBcIm92ZXJsaW5lXCJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZUludCA+PSA5MCAmJiBjb2RlSW50IDw9IDk3KSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJzZXRGb3JlZ3JvdW5kQ29sb3JcIixcbiAgICAgICAgdmFsdWU6IHsgdHlwZTogXCJuYW1lZFwiLCBuYW1lOiBuYW1lZENvbG9yc1tjb2RlSW50IC0gOTAgKyA4XSB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGVJbnQgPj0gMTAwICYmIGNvZGVJbnQgPD0gMTA3KSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJzZXRCYWNrZ3JvdW5kQ29sb3JcIixcbiAgICAgICAgdmFsdWU6IHsgdHlwZTogXCJuYW1lZFwiLCBuYW1lOiBuYW1lZENvbG9yc1tjb2RlSW50IC0gMTAwICsgOF0gfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb21tYW5kcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFuc2lTZXF1ZW5jZVBhcnNlcigpIHtcbiAgbGV0IGZvcmVncm91bmQgPSBudWxsO1xuICBsZXQgYmFja2dyb3VuZCA9IG51bGw7XG4gIGxldCBkZWNvcmF0aW9uczIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICByZXR1cm4ge1xuICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICAgIGxldCBwb3NpdGlvbiA9IDA7XG4gICAgICBkbyB7XG4gICAgICAgIGNvbnN0IGZpbmRSZXN1bHQgPSBmaW5kU2VxdWVuY2UodmFsdWUsIHBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgdGV4dCA9IGZpbmRSZXN1bHQuc2VxdWVuY2UgPyB2YWx1ZS5zdWJzdHJpbmcocG9zaXRpb24sIGZpbmRSZXN1bHQuc3RhcnRQb3NpdGlvbikgOiB2YWx1ZS5zdWJzdHJpbmcocG9zaXRpb24pO1xuICAgICAgICBpZiAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdmFsdWU6IHRleHQsXG4gICAgICAgICAgICBmb3JlZ3JvdW5kLFxuICAgICAgICAgICAgYmFja2dyb3VuZCxcbiAgICAgICAgICAgIGRlY29yYXRpb25zOiBuZXcgU2V0KGRlY29yYXRpb25zMilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmluZFJlc3VsdC5zZXF1ZW5jZSkge1xuICAgICAgICAgIGNvbnN0IGNvbW1hbmRzID0gcGFyc2VTZXF1ZW5jZShmaW5kUmVzdWx0LnNlcXVlbmNlKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHN0eWxlVG9rZW4gb2YgY29tbWFuZHMpIHtcbiAgICAgICAgICAgIGlmIChzdHlsZVRva2VuLnR5cGUgPT09IFwicmVzZXRBbGxcIikge1xuICAgICAgICAgICAgICBmb3JlZ3JvdW5kID0gbnVsbDtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZCA9IG51bGw7XG4gICAgICAgICAgICAgIGRlY29yYXRpb25zMi5jbGVhcigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZVRva2VuLnR5cGUgPT09IFwicmVzZXRGb3JlZ3JvdW5kQ29sb3JcIikge1xuICAgICAgICAgICAgICBmb3JlZ3JvdW5kID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGVUb2tlbi50eXBlID09PSBcInJlc2V0QmFja2dyb3VuZENvbG9yXCIpIHtcbiAgICAgICAgICAgICAgYmFja2dyb3VuZCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlVG9rZW4udHlwZSA9PT0gXCJyZXNldERlY29yYXRpb25cIikge1xuICAgICAgICAgICAgICBkZWNvcmF0aW9uczIuZGVsZXRlKHN0eWxlVG9rZW4udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IHN0eWxlVG9rZW4gb2YgY29tbWFuZHMpIHtcbiAgICAgICAgICAgIGlmIChzdHlsZVRva2VuLnR5cGUgPT09IFwic2V0Rm9yZWdyb3VuZENvbG9yXCIpIHtcbiAgICAgICAgICAgICAgZm9yZWdyb3VuZCA9IHN0eWxlVG9rZW4udmFsdWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlVG9rZW4udHlwZSA9PT0gXCJzZXRCYWNrZ3JvdW5kQ29sb3JcIikge1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kID0gc3R5bGVUb2tlbi52YWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGVUb2tlbi50eXBlID09PSBcInNldERlY29yYXRpb25cIikge1xuICAgICAgICAgICAgICBkZWNvcmF0aW9uczIuYWRkKHN0eWxlVG9rZW4udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbiA9IGZpbmRSZXN1bHQucG9zaXRpb247XG4gICAgICB9IHdoaWxlIChwb3NpdGlvbiA8IHZhbHVlLmxlbmd0aCk7XG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3BhbGV0dGUudHNcbnZhciBkZWZhdWx0TmFtZWRDb2xvcnNNYXAgPSB7XG4gIGJsYWNrOiBcIiMwMDAwMDBcIixcbiAgcmVkOiBcIiNiYjAwMDBcIixcbiAgZ3JlZW46IFwiIzAwYmIwMFwiLFxuICB5ZWxsb3c6IFwiI2JiYmIwMFwiLFxuICBibHVlOiBcIiMwMDAwYmJcIixcbiAgbWFnZW50YTogXCIjZmYwMGZmXCIsXG4gIGN5YW46IFwiIzAwYmJiYlwiLFxuICB3aGl0ZTogXCIjZWVlZWVlXCIsXG4gIGJyaWdodEJsYWNrOiBcIiM1NTU1NTVcIixcbiAgYnJpZ2h0UmVkOiBcIiNmZjU1NTVcIixcbiAgYnJpZ2h0R3JlZW46IFwiIzAwZmYwMFwiLFxuICBicmlnaHRZZWxsb3c6IFwiI2ZmZmY1NVwiLFxuICBicmlnaHRCbHVlOiBcIiM1NTU1ZmZcIixcbiAgYnJpZ2h0TWFnZW50YTogXCIjZmY1NWZmXCIsXG4gIGJyaWdodEN5YW46IFwiIzU1ZmZmZlwiLFxuICBicmlnaHRXaGl0ZTogXCIjZmZmZmZmXCJcbn07XG5mdW5jdGlvbiBjcmVhdGVDb2xvclBhbGV0dGUobmFtZWRDb2xvcnNNYXAgPSBkZWZhdWx0TmFtZWRDb2xvcnNNYXApIHtcbiAgZnVuY3Rpb24gbmFtZWRDb2xvcihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWVkQ29sb3JzTWFwW25hbWVdO1xuICB9XG4gIGZ1bmN0aW9uIHJnYkNvbG9yKHJnYikge1xuICAgIHJldHVybiBgIyR7cmdiLm1hcCgoeCkgPT4gTWF0aC5tYXgoMCwgTWF0aC5taW4oeCwgMjU1KSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSkuam9pbihcIlwiKX1gO1xuICB9XG4gIGxldCBjb2xvclRhYmxlO1xuICBmdW5jdGlvbiBnZXRDb2xvclRhYmxlKCkge1xuICAgIGlmIChjb2xvclRhYmxlKSB7XG4gICAgICByZXR1cm4gY29sb3JUYWJsZTtcbiAgICB9XG4gICAgY29sb3JUYWJsZSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZWRDb2xvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbG9yVGFibGUucHVzaChuYW1lZENvbG9yKG5hbWVkQ29sb3JzW2ldKSk7XG4gICAgfVxuICAgIGxldCBsZXZlbHMgPSBbMCwgOTUsIDEzNSwgMTc1LCAyMTUsIDI1NV07XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCA2OyByKyspIHtcbiAgICAgIGZvciAobGV0IGcgPSAwOyBnIDwgNjsgZysrKSB7XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgNjsgYisrKSB7XG4gICAgICAgICAgY29sb3JUYWJsZS5wdXNoKHJnYkNvbG9yKFtsZXZlbHNbcl0sIGxldmVsc1tnXSwgbGV2ZWxzW2JdXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBsZXZlbCA9IDg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNDsgaSsrLCBsZXZlbCArPSAxMCkge1xuICAgICAgY29sb3JUYWJsZS5wdXNoKHJnYkNvbG9yKFtsZXZlbCwgbGV2ZWwsIGxldmVsXSkpO1xuICAgIH1cbiAgICByZXR1cm4gY29sb3JUYWJsZTtcbiAgfVxuICBmdW5jdGlvbiB0YWJsZUNvbG9yKGluZGV4KSB7XG4gICAgcmV0dXJuIGdldENvbG9yVGFibGUoKVtpbmRleF07XG4gIH1cbiAgZnVuY3Rpb24gdmFsdWUoY29sb3IpIHtcbiAgICBzd2l0Y2ggKGNvbG9yLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJuYW1lZFwiOlxuICAgICAgICByZXR1cm4gbmFtZWRDb2xvcihjb2xvci5uYW1lKTtcbiAgICAgIGNhc2UgXCJyZ2JcIjpcbiAgICAgICAgcmV0dXJuIHJnYkNvbG9yKGNvbG9yLnJnYik7XG4gICAgICBjYXNlIFwidGFibGVcIjpcbiAgICAgICAgcmV0dXJuIHRhYmxlQ29sb3IoY29sb3IuaW5kZXgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbHVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHRva2VuaXplQW5zaVdpdGhUaGVtZSh0aGVtZSwgZmlsZUNvbnRlbnRzLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvbG9yUmVwbGFjZW1lbnRzID0gcmVzb2x2ZUNvbG9yUmVwbGFjZW1lbnRzKHRoZW1lLCBvcHRpb25zKTtcbiAgY29uc3QgbGluZXMgPSBzcGxpdExpbmVzKGZpbGVDb250ZW50cyk7XG4gIGNvbnN0IGNvbG9yUGFsZXR0ZSA9IGNyZWF0ZUNvbG9yUGFsZXR0ZShcbiAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBuYW1lZENvbG9ycy5tYXAoKG5hbWUpID0+IFtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdGhlbWUuY29sb3JzPy5bYHRlcm1pbmFsLmFuc2kke25hbWVbMF0udG9VcHBlckNhc2UoKX0ke25hbWUuc3Vic3RyaW5nKDEpfWBdXG4gICAgICBdKVxuICAgIClcbiAgKTtcbiAgY29uc3QgcGFyc2VyID0gY3JlYXRlQW5zaVNlcXVlbmNlUGFyc2VyKCk7XG4gIHJldHVybiBsaW5lcy5tYXAoXG4gICAgKGxpbmUpID0+IHBhcnNlci5wYXJzZShsaW5lWzBdKS5tYXAoKHRva2VuKSA9PiB7XG4gICAgICBsZXQgY29sb3I7XG4gICAgICBsZXQgYmdDb2xvcjtcbiAgICAgIGlmICh0b2tlbi5kZWNvcmF0aW9ucy5oYXMoXCJyZXZlcnNlXCIpKSB7XG4gICAgICAgIGNvbG9yID0gdG9rZW4uYmFja2dyb3VuZCA/IGNvbG9yUGFsZXR0ZS52YWx1ZSh0b2tlbi5iYWNrZ3JvdW5kKSA6IHRoZW1lLmJnO1xuICAgICAgICBiZ0NvbG9yID0gdG9rZW4uZm9yZWdyb3VuZCA/IGNvbG9yUGFsZXR0ZS52YWx1ZSh0b2tlbi5mb3JlZ3JvdW5kKSA6IHRoZW1lLmZnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sb3IgPSB0b2tlbi5mb3JlZ3JvdW5kID8gY29sb3JQYWxldHRlLnZhbHVlKHRva2VuLmZvcmVncm91bmQpIDogdGhlbWUuZmc7XG4gICAgICAgIGJnQ29sb3IgPSB0b2tlbi5iYWNrZ3JvdW5kID8gY29sb3JQYWxldHRlLnZhbHVlKHRva2VuLmJhY2tncm91bmQpIDogdm9pZCAwO1xuICAgICAgfVxuICAgICAgY29sb3IgPSBhcHBseUNvbG9yUmVwbGFjZW1lbnRzKGNvbG9yLCBjb2xvclJlcGxhY2VtZW50cyk7XG4gICAgICBiZ0NvbG9yID0gYXBwbHlDb2xvclJlcGxhY2VtZW50cyhiZ0NvbG9yLCBjb2xvclJlcGxhY2VtZW50cyk7XG4gICAgICBpZiAodG9rZW4uZGVjb3JhdGlvbnMuaGFzKFwiZGltXCIpKVxuICAgICAgICBjb2xvciA9IGRpbUNvbG9yKGNvbG9yKTtcbiAgICAgIGxldCBmb250U3R5bGUgPSBGb250U3R5bGUuTm9uZTtcbiAgICAgIGlmICh0b2tlbi5kZWNvcmF0aW9ucy5oYXMoXCJib2xkXCIpKVxuICAgICAgICBmb250U3R5bGUgfD0gRm9udFN0eWxlLkJvbGQ7XG4gICAgICBpZiAodG9rZW4uZGVjb3JhdGlvbnMuaGFzKFwiaXRhbGljXCIpKVxuICAgICAgICBmb250U3R5bGUgfD0gRm9udFN0eWxlLkl0YWxpYztcbiAgICAgIGlmICh0b2tlbi5kZWNvcmF0aW9ucy5oYXMoXCJ1bmRlcmxpbmVcIikpXG4gICAgICAgIGZvbnRTdHlsZSB8PSBGb250U3R5bGUuVW5kZXJsaW5lO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudDogdG9rZW4udmFsdWUsXG4gICAgICAgIG9mZnNldDogbGluZVsxXSxcbiAgICAgICAgLy8gVE9ETzogbW9yZSBhY2N1cmF0ZSBvZmZzZXQ/IG1pZ2h0IG5lZWQgdG8gZm9yayBhbnNpLXNlcXVlbmNlLXBhcnNlclxuICAgICAgICBjb2xvcixcbiAgICAgICAgYmdDb2xvcixcbiAgICAgICAgZm9udFN0eWxlXG4gICAgICB9O1xuICAgIH0pXG4gICk7XG59XG5mdW5jdGlvbiBkaW1Db2xvcihjb2xvcikge1xuICBjb25zdCBoZXhNYXRjaCA9IGNvbG9yLm1hdGNoKC8jKFswLTlhLWZdezN9KShbMC05YS1mXXszfSk/KFswLTlhLWZdezJ9KT8vKTtcbiAgaWYgKGhleE1hdGNoKSB7XG4gICAgaWYgKGhleE1hdGNoWzNdKSB7XG4gICAgICBjb25zdCBhbHBoYSA9IE1hdGgucm91bmQoTnVtYmVyLnBhcnNlSW50KGhleE1hdGNoWzNdLCAxNikgLyAyKS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xuICAgICAgcmV0dXJuIGAjJHtoZXhNYXRjaFsxXX0ke2hleE1hdGNoWzJdfSR7YWxwaGF9YDtcbiAgICB9IGVsc2UgaWYgKGhleE1hdGNoWzJdKSB7XG4gICAgICByZXR1cm4gYCMke2hleE1hdGNoWzFdfSR7aGV4TWF0Y2hbMl19ODBgO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYCMke0FycmF5LmZyb20oaGV4TWF0Y2hbMV0pLm1hcCgoeCkgPT4gYCR7eH0ke3h9YCkuam9pbihcIlwiKX04MGA7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNzc1Zhck1hdGNoID0gY29sb3IubWF0Y2goL3ZhclxcKCgtLVtcXHctXSstYW5zaS1bXFx3LV0rKVxcKS8pO1xuICBpZiAoY3NzVmFyTWF0Y2gpXG4gICAgcmV0dXJuIGB2YXIoJHtjc3NWYXJNYXRjaFsxXX0tZGltKWA7XG4gIHJldHVybiBjb2xvcjtcbn1cblxuZnVuY3Rpb24gY29kZVRvVG9rZW5zQmFzZShpbnRlcm5hbCwgY29kZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBsYW5nID0gXCJ0ZXh0XCIsXG4gICAgdGhlbWU6IHRoZW1lTmFtZSA9IGludGVybmFsLmdldExvYWRlZFRoZW1lcygpWzBdXG4gIH0gPSBvcHRpb25zO1xuICBpZiAoaXNQbGFpbkxhbmcobGFuZykgfHwgaXNOb25lVGhlbWUodGhlbWVOYW1lKSlcbiAgICByZXR1cm4gc3BsaXRMaW5lcyhjb2RlKS5tYXAoKGxpbmUpID0+IFt7IGNvbnRlbnQ6IGxpbmVbMF0sIG9mZnNldDogbGluZVsxXSB9XSk7XG4gIGNvbnN0IHsgdGhlbWUsIGNvbG9yTWFwIH0gPSBpbnRlcm5hbC5zZXRUaGVtZSh0aGVtZU5hbWUpO1xuICBpZiAobGFuZyA9PT0gXCJhbnNpXCIpXG4gICAgcmV0dXJuIHRva2VuaXplQW5zaVdpdGhUaGVtZSh0aGVtZSwgY29kZSwgb3B0aW9ucyk7XG4gIGNvbnN0IF9ncmFtbWFyID0gaW50ZXJuYWwuZ2V0TGFuZ3VhZ2UobGFuZyk7XG4gIGlmIChvcHRpb25zLmdyYW1tYXJTdGF0ZSkge1xuICAgIGlmIChvcHRpb25zLmdyYW1tYXJTdGF0ZS5sYW5nICE9PSBfZ3JhbW1hci5uYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKGBHcmFtbWFyIHN0YXRlIGxhbmd1YWdlIFwiJHtvcHRpb25zLmdyYW1tYXJTdGF0ZS5sYW5nfVwiIGRvZXMgbm90IG1hdGNoIGhpZ2hsaWdodCBsYW5ndWFnZSBcIiR7X2dyYW1tYXIubmFtZX1cImApO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuZ3JhbW1hclN0YXRlLnRoZW1lcy5pbmNsdWRlcyh0aGVtZS5uYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShgR3JhbW1hciBzdGF0ZSB0aGVtZXMgXCIke29wdGlvbnMuZ3JhbW1hclN0YXRlLnRoZW1lc31cIiBkbyBub3QgY29udGFpbiBoaWdobGlnaHQgdGhlbWUgXCIke3RoZW1lLm5hbWV9XCJgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRva2VuaXplV2l0aFRoZW1lKGNvZGUsIF9ncmFtbWFyLCB0aGVtZSwgY29sb3JNYXAsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZ2V0TGFzdEdyYW1tYXJTdGF0ZSguLi5hcmdzKSB7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMikge1xuICAgIHJldHVybiBnZXRMYXN0R3JhbW1hclN0YXRlRnJvbU1hcChhcmdzWzFdKTtcbiAgfVxuICBjb25zdCBbaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMgPSB7fV0gPSBhcmdzO1xuICBjb25zdCB7XG4gICAgbGFuZyA9IFwidGV4dFwiLFxuICAgIHRoZW1lOiB0aGVtZU5hbWUgPSBpbnRlcm5hbC5nZXRMb2FkZWRUaGVtZXMoKVswXVxuICB9ID0gb3B0aW9ucztcbiAgaWYgKGlzUGxhaW5MYW5nKGxhbmcpIHx8IGlzTm9uZVRoZW1lKHRoZW1lTmFtZSkpXG4gICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShcIlBsYWluIGxhbmd1YWdlIGRvZXMgbm90IGhhdmUgZ3JhbW1hciBzdGF0ZVwiKTtcbiAgaWYgKGxhbmcgPT09IFwiYW5zaVwiKVxuICAgIHRocm93IG5ldyBTaGlraUVycm9yJDEoXCJBTlNJIGxhbmd1YWdlIGRvZXMgbm90IGhhdmUgZ3JhbW1hciBzdGF0ZVwiKTtcbiAgY29uc3QgeyB0aGVtZSwgY29sb3JNYXAgfSA9IGludGVybmFsLnNldFRoZW1lKHRoZW1lTmFtZSk7XG4gIGNvbnN0IF9ncmFtbWFyID0gaW50ZXJuYWwuZ2V0TGFuZ3VhZ2UobGFuZyk7XG4gIHJldHVybiBuZXcgR3JhbW1hclN0YXRlKFxuICAgIF90b2tlbml6ZVdpdGhUaGVtZShjb2RlLCBfZ3JhbW1hciwgdGhlbWUsIGNvbG9yTWFwLCBvcHRpb25zKS5zdGF0ZVN0YWNrLFxuICAgIF9ncmFtbWFyLm5hbWUsXG4gICAgdGhlbWUubmFtZVxuICApO1xufVxuZnVuY3Rpb24gdG9rZW5pemVXaXRoVGhlbWUoY29kZSwgZ3JhbW1hciwgdGhlbWUsIGNvbG9yTWFwLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IF90b2tlbml6ZVdpdGhUaGVtZShjb2RlLCBncmFtbWFyLCB0aGVtZSwgY29sb3JNYXAsIG9wdGlvbnMpO1xuICBjb25zdCBncmFtbWFyU3RhdGUgPSBuZXcgR3JhbW1hclN0YXRlKFxuICAgIF90b2tlbml6ZVdpdGhUaGVtZShjb2RlLCBncmFtbWFyLCB0aGVtZSwgY29sb3JNYXAsIG9wdGlvbnMpLnN0YXRlU3RhY2ssXG4gICAgZ3JhbW1hci5uYW1lLFxuICAgIHRoZW1lLm5hbWVcbiAgKTtcbiAgc2V0TGFzdEdyYW1tYXJTdGF0ZVRvTWFwKHJlc3VsdC50b2tlbnMsIGdyYW1tYXJTdGF0ZSk7XG4gIHJldHVybiByZXN1bHQudG9rZW5zO1xufVxuZnVuY3Rpb24gX3Rva2VuaXplV2l0aFRoZW1lKGNvZGUsIGdyYW1tYXIsIHRoZW1lLCBjb2xvck1hcCwgb3B0aW9ucykge1xuICBjb25zdCBjb2xvclJlcGxhY2VtZW50cyA9IHJlc29sdmVDb2xvclJlcGxhY2VtZW50cyh0aGVtZSwgb3B0aW9ucyk7XG4gIGNvbnN0IHtcbiAgICB0b2tlbml6ZU1heExpbmVMZW5ndGggPSAwLFxuICAgIHRva2VuaXplVGltZUxpbWl0ID0gNTAwXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBsaW5lcyA9IHNwbGl0TGluZXMoY29kZSk7XG4gIGxldCBzdGF0ZVN0YWNrID0gb3B0aW9ucy5ncmFtbWFyU3RhdGUgPyBnZXRHcmFtbWFyU3RhY2sob3B0aW9ucy5ncmFtbWFyU3RhdGUsIHRoZW1lLm5hbWUpID8/IElOSVRJQUwgOiBvcHRpb25zLmdyYW1tYXJDb250ZXh0Q29kZSAhPSBudWxsID8gX3Rva2VuaXplV2l0aFRoZW1lKFxuICAgIG9wdGlvbnMuZ3JhbW1hckNvbnRleHRDb2RlLFxuICAgIGdyYW1tYXIsXG4gICAgdGhlbWUsXG4gICAgY29sb3JNYXAsXG4gICAge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGdyYW1tYXJTdGF0ZTogdm9pZCAwLFxuICAgICAgZ3JhbW1hckNvbnRleHRDb2RlOiB2b2lkIDBcbiAgICB9XG4gICkuc3RhdGVTdGFjayA6IElOSVRJQUw7XG4gIGxldCBhY3R1YWwgPSBbXTtcbiAgY29uc3QgZmluYWwgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgW2xpbmUsIGxpbmVPZmZzZXRdID0gbGluZXNbaV07XG4gICAgaWYgKGxpbmUgPT09IFwiXCIpIHtcbiAgICAgIGFjdHVhbCA9IFtdO1xuICAgICAgZmluYWwucHVzaChbXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHRva2VuaXplTWF4TGluZUxlbmd0aCA+IDAgJiYgbGluZS5sZW5ndGggPj0gdG9rZW5pemVNYXhMaW5lTGVuZ3RoKSB7XG4gICAgICBhY3R1YWwgPSBbXTtcbiAgICAgIGZpbmFsLnB1c2goW3tcbiAgICAgICAgY29udGVudDogbGluZSxcbiAgICAgICAgb2Zmc2V0OiBsaW5lT2Zmc2V0LFxuICAgICAgICBjb2xvcjogXCJcIixcbiAgICAgICAgZm9udFN0eWxlOiAwXG4gICAgICB9XSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdFdpdGhTY29wZXM7XG4gICAgbGV0IHRva2Vuc1dpdGhTY29wZXM7XG4gICAgbGV0IHRva2Vuc1dpdGhTY29wZXNJbmRleDtcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlRXhwbGFuYXRpb24pIHtcbiAgICAgIHJlc3VsdFdpdGhTY29wZXMgPSBncmFtbWFyLnRva2VuaXplTGluZShsaW5lLCBzdGF0ZVN0YWNrLCB0b2tlbml6ZVRpbWVMaW1pdCk7XG4gICAgICB0b2tlbnNXaXRoU2NvcGVzID0gcmVzdWx0V2l0aFNjb3Blcy50b2tlbnM7XG4gICAgICB0b2tlbnNXaXRoU2NvcGVzSW5kZXggPSAwO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBncmFtbWFyLnRva2VuaXplTGluZTIobGluZSwgc3RhdGVTdGFjaywgdG9rZW5pemVUaW1lTGltaXQpO1xuICAgIGNvbnN0IHRva2Vuc0xlbmd0aCA9IHJlc3VsdC50b2tlbnMubGVuZ3RoIC8gMjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRva2Vuc0xlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBzdGFydEluZGV4ID0gcmVzdWx0LnRva2Vuc1syICogal07XG4gICAgICBjb25zdCBuZXh0U3RhcnRJbmRleCA9IGogKyAxIDwgdG9rZW5zTGVuZ3RoID8gcmVzdWx0LnRva2Vuc1syICogaiArIDJdIDogbGluZS5sZW5ndGg7XG4gICAgICBpZiAoc3RhcnRJbmRleCA9PT0gbmV4dFN0YXJ0SW5kZXgpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSByZXN1bHQudG9rZW5zWzIgKiBqICsgMV07XG4gICAgICBjb25zdCBjb2xvciA9IGFwcGx5Q29sb3JSZXBsYWNlbWVudHMoXG4gICAgICAgIGNvbG9yTWFwW0VuY29kZWRUb2tlbk1ldGFkYXRhLmdldEZvcmVncm91bmQobWV0YWRhdGEpXSxcbiAgICAgICAgY29sb3JSZXBsYWNlbWVudHNcbiAgICAgICk7XG4gICAgICBjb25zdCBmb250U3R5bGUgPSBFbmNvZGVkVG9rZW5NZXRhZGF0YS5nZXRGb250U3R5bGUobWV0YWRhdGEpO1xuICAgICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgIGNvbnRlbnQ6IGxpbmUuc3Vic3RyaW5nKHN0YXJ0SW5kZXgsIG5leHRTdGFydEluZGV4KSxcbiAgICAgICAgb2Zmc2V0OiBsaW5lT2Zmc2V0ICsgc3RhcnRJbmRleCxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIGZvbnRTdHlsZVxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVFeHBsYW5hdGlvbikge1xuICAgICAgICBjb25zdCB0aGVtZVNldHRpbmdzU2VsZWN0b3JzID0gW107XG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVFeHBsYW5hdGlvbiAhPT0gXCJzY29wZU5hbWVcIikge1xuICAgICAgICAgIGZvciAoY29uc3Qgc2V0dGluZyBvZiB0aGVtZS5zZXR0aW5ncykge1xuICAgICAgICAgICAgbGV0IHNlbGVjdG9ycztcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHNldHRpbmcuc2NvcGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHNlbGVjdG9ycyA9IHNldHRpbmcuc2NvcGUuc3BsaXQoLywvKS5tYXAoKHNjb3BlKSA9PiBzY29wZS50cmltKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzID0gc2V0dGluZy5zY29wZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoZW1lU2V0dGluZ3NTZWxlY3RvcnMucHVzaCh7XG4gICAgICAgICAgICAgIHNldHRpbmdzOiBzZXR0aW5nLFxuICAgICAgICAgICAgICBzZWxlY3RvcnM6IHNlbGVjdG9ycy5tYXAoKHNlbGVjdG9yKSA9PiBzZWxlY3Rvci5zcGxpdCgvIC8pKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRva2VuLmV4cGxhbmF0aW9uID0gW107XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICB3aGlsZSAoc3RhcnRJbmRleCArIG9mZnNldCA8IG5leHRTdGFydEluZGV4KSB7XG4gICAgICAgICAgY29uc3QgdG9rZW5XaXRoU2NvcGVzID0gdG9rZW5zV2l0aFNjb3Blc1t0b2tlbnNXaXRoU2NvcGVzSW5kZXhdO1xuICAgICAgICAgIGNvbnN0IHRva2VuV2l0aFNjb3Blc1RleHQgPSBsaW5lLnN1YnN0cmluZyhcbiAgICAgICAgICAgIHRva2VuV2l0aFNjb3Blcy5zdGFydEluZGV4LFxuICAgICAgICAgICAgdG9rZW5XaXRoU2NvcGVzLmVuZEluZGV4XG4gICAgICAgICAgKTtcbiAgICAgICAgICBvZmZzZXQgKz0gdG9rZW5XaXRoU2NvcGVzVGV4dC5sZW5ndGg7XG4gICAgICAgICAgdG9rZW4uZXhwbGFuYXRpb24ucHVzaCh7XG4gICAgICAgICAgICBjb250ZW50OiB0b2tlbldpdGhTY29wZXNUZXh0LFxuICAgICAgICAgICAgc2NvcGVzOiBvcHRpb25zLmluY2x1ZGVFeHBsYW5hdGlvbiA9PT0gXCJzY29wZU5hbWVcIiA/IGV4cGxhaW5UaGVtZVNjb3Blc05hbWVPbmx5KFxuICAgICAgICAgICAgICB0b2tlbldpdGhTY29wZXMuc2NvcGVzXG4gICAgICAgICAgICApIDogZXhwbGFpblRoZW1lU2NvcGVzRnVsbChcbiAgICAgICAgICAgICAgdGhlbWVTZXR0aW5nc1NlbGVjdG9ycyxcbiAgICAgICAgICAgICAgdG9rZW5XaXRoU2NvcGVzLnNjb3Blc1xuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRva2Vuc1dpdGhTY29wZXNJbmRleCArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhY3R1YWwucHVzaCh0b2tlbik7XG4gICAgfVxuICAgIGZpbmFsLnB1c2goYWN0dWFsKTtcbiAgICBhY3R1YWwgPSBbXTtcbiAgICBzdGF0ZVN0YWNrID0gcmVzdWx0LnJ1bGVTdGFjaztcbiAgfVxuICByZXR1cm4ge1xuICAgIHRva2VuczogZmluYWwsXG4gICAgc3RhdGVTdGFja1xuICB9O1xufVxuZnVuY3Rpb24gZXhwbGFpblRoZW1lU2NvcGVzTmFtZU9ubHkoc2NvcGVzKSB7XG4gIHJldHVybiBzY29wZXMubWFwKChzY29wZSkgPT4gKHsgc2NvcGVOYW1lOiBzY29wZSB9KSk7XG59XG5mdW5jdGlvbiBleHBsYWluVGhlbWVTY29wZXNGdWxsKHRoZW1lU2VsZWN0b3JzLCBzY29wZXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzY29wZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBzY29wZSA9IHNjb3Blc1tpXTtcbiAgICByZXN1bHRbaV0gPSB7XG4gICAgICBzY29wZU5hbWU6IHNjb3BlLFxuICAgICAgdGhlbWVNYXRjaGVzOiBleHBsYWluVGhlbWVTY29wZSh0aGVtZVNlbGVjdG9ycywgc2NvcGUsIHNjb3Blcy5zbGljZSgwLCBpKSlcbiAgICB9O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtYXRjaGVzT25lKHNlbGVjdG9yLCBzY29wZSkge1xuICByZXR1cm4gc2VsZWN0b3IgPT09IHNjb3BlIHx8IHNjb3BlLnN1YnN0cmluZygwLCBzZWxlY3Rvci5sZW5ndGgpID09PSBzZWxlY3RvciAmJiBzY29wZVtzZWxlY3Rvci5sZW5ndGhdID09PSBcIi5cIjtcbn1cbmZ1bmN0aW9uIG1hdGNoZXMoc2VsZWN0b3JzLCBzY29wZSwgcGFyZW50U2NvcGVzKSB7XG4gIGlmICghbWF0Y2hlc09uZShzZWxlY3RvcnNbc2VsZWN0b3JzLmxlbmd0aCAtIDFdLCBzY29wZSkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBsZXQgc2VsZWN0b3JQYXJlbnRJbmRleCA9IHNlbGVjdG9ycy5sZW5ndGggLSAyO1xuICBsZXQgcGFyZW50SW5kZXggPSBwYXJlbnRTY29wZXMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKHNlbGVjdG9yUGFyZW50SW5kZXggPj0gMCAmJiBwYXJlbnRJbmRleCA+PSAwKSB7XG4gICAgaWYgKG1hdGNoZXNPbmUoc2VsZWN0b3JzW3NlbGVjdG9yUGFyZW50SW5kZXhdLCBwYXJlbnRTY29wZXNbcGFyZW50SW5kZXhdKSlcbiAgICAgIHNlbGVjdG9yUGFyZW50SW5kZXggLT0gMTtcbiAgICBwYXJlbnRJbmRleCAtPSAxO1xuICB9XG4gIGlmIChzZWxlY3RvclBhcmVudEluZGV4ID09PSAtMSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZXhwbGFpblRoZW1lU2NvcGUodGhlbWVTZXR0aW5nc1NlbGVjdG9ycywgc2NvcGUsIHBhcmVudFNjb3Blcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChjb25zdCB7IHNlbGVjdG9ycywgc2V0dGluZ3MgfSBvZiB0aGVtZVNldHRpbmdzU2VsZWN0b3JzKSB7XG4gICAgZm9yIChjb25zdCBzZWxlY3RvclBpZWNlcyBvZiBzZWxlY3RvcnMpIHtcbiAgICAgIGlmIChtYXRjaGVzKHNlbGVjdG9yUGllY2VzLCBzY29wZSwgcGFyZW50U2NvcGVzKSkge1xuICAgICAgICByZXN1bHQucHVzaChzZXR0aW5ncyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjb2RlVG9Ub2tlbnNXaXRoVGhlbWVzKGludGVybmFsLCBjb2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHRoZW1lcyA9IE9iamVjdC5lbnRyaWVzKG9wdGlvbnMudGhlbWVzKS5maWx0ZXIoKGkpID0+IGlbMV0pLm1hcCgoaSkgPT4gKHsgY29sb3I6IGlbMF0sIHRoZW1lOiBpWzFdIH0pKTtcbiAgY29uc3QgdGhlbWVkVG9rZW5zID0gdGhlbWVzLm1hcCgodCkgPT4ge1xuICAgIGNvbnN0IHRva2VuczIgPSBjb2RlVG9Ub2tlbnNCYXNlKGludGVybmFsLCBjb2RlLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgdGhlbWU6IHQudGhlbWVcbiAgICB9KTtcbiAgICBjb25zdCBzdGF0ZSA9IGdldExhc3RHcmFtbWFyU3RhdGVGcm9tTWFwKHRva2VuczIpO1xuICAgIGNvbnN0IHRoZW1lID0gdHlwZW9mIHQudGhlbWUgPT09IFwic3RyaW5nXCIgPyB0LnRoZW1lIDogdC50aGVtZS5uYW1lO1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbnM6IHRva2VuczIsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRoZW1lXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IHRva2VucyA9IHN5bmNUaGVtZXNUb2tlbml6YXRpb24oXG4gICAgLi4udGhlbWVkVG9rZW5zLm1hcCgoaSkgPT4gaS50b2tlbnMpXG4gICk7XG4gIGNvbnN0IG1lcmdlZFRva2VucyA9IHRva2Vuc1swXS5tYXAoXG4gICAgKGxpbmUsIGxpbmVJZHgpID0+IGxpbmUubWFwKChfdG9rZW4sIHRva2VuSWR4KSA9PiB7XG4gICAgICBjb25zdCBtZXJnZWRUb2tlbiA9IHtcbiAgICAgICAgY29udGVudDogX3Rva2VuLmNvbnRlbnQsXG4gICAgICAgIHZhcmlhbnRzOiB7fSxcbiAgICAgICAgb2Zmc2V0OiBfdG9rZW4ub2Zmc2V0XG4gICAgICB9O1xuICAgICAgaWYgKFwiaW5jbHVkZUV4cGxhbmF0aW9uXCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmluY2x1ZGVFeHBsYW5hdGlvbikge1xuICAgICAgICBtZXJnZWRUb2tlbi5leHBsYW5hdGlvbiA9IF90b2tlbi5leHBsYW5hdGlvbjtcbiAgICAgIH1cbiAgICAgIHRva2Vucy5mb3JFYWNoKCh0LCB0aGVtZUlkeCkgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY29udGVudDogXyxcbiAgICAgICAgICBleHBsYW5hdGlvbjogX18sXG4gICAgICAgICAgb2Zmc2V0OiBfX18sXG4gICAgICAgICAgLi4uc3R5bGVzXG4gICAgICAgIH0gPSB0W2xpbmVJZHhdW3Rva2VuSWR4XTtcbiAgICAgICAgbWVyZ2VkVG9rZW4udmFyaWFudHNbdGhlbWVzW3RoZW1lSWR4XS5jb2xvcl0gPSBzdHlsZXM7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtZXJnZWRUb2tlbjtcbiAgICB9KVxuICApO1xuICBjb25zdCBtZXJnZWRHcmFtbWFyU3RhdGUgPSB0aGVtZWRUb2tlbnNbMF0uc3RhdGUgPyBuZXcgR3JhbW1hclN0YXRlKFxuICAgIE9iamVjdC5mcm9tRW50cmllcyh0aGVtZWRUb2tlbnMubWFwKChzKSA9PiBbcy50aGVtZSwgcy5zdGF0ZT8uZ2V0SW50ZXJuYWxTdGFjayhzLnRoZW1lKV0pKSxcbiAgICB0aGVtZWRUb2tlbnNbMF0uc3RhdGUubGFuZ1xuICApIDogdm9pZCAwO1xuICBpZiAobWVyZ2VkR3JhbW1hclN0YXRlKVxuICAgIHNldExhc3RHcmFtbWFyU3RhdGVUb01hcChtZXJnZWRUb2tlbnMsIG1lcmdlZEdyYW1tYXJTdGF0ZSk7XG4gIHJldHVybiBtZXJnZWRUb2tlbnM7XG59XG5mdW5jdGlvbiBzeW5jVGhlbWVzVG9rZW5pemF0aW9uKC4uLnRoZW1lcykge1xuICBjb25zdCBvdXRUaGVtZXMgPSB0aGVtZXMubWFwKCgpID0+IFtdKTtcbiAgY29uc3QgY291bnQgPSB0aGVtZXMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoZW1lc1swXS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpbmVzID0gdGhlbWVzLm1hcCgodCkgPT4gdFtpXSk7XG4gICAgY29uc3Qgb3V0TGluZXMgPSBvdXRUaGVtZXMubWFwKCgpID0+IFtdKTtcbiAgICBvdXRUaGVtZXMuZm9yRWFjaCgodCwgaTIpID0+IHQucHVzaChvdXRMaW5lc1tpMl0pKTtcbiAgICBjb25zdCBpbmRleGVzID0gbGluZXMubWFwKCgpID0+IDApO1xuICAgIGNvbnN0IGN1cnJlbnQgPSBsaW5lcy5tYXAoKGwpID0+IGxbMF0pO1xuICAgIHdoaWxlIChjdXJyZW50LmV2ZXJ5KCh0KSA9PiB0KSkge1xuICAgICAgY29uc3QgbWluTGVuZ3RoID0gTWF0aC5taW4oLi4uY3VycmVudC5tYXAoKHQpID0+IHQuY29udGVudC5sZW5ndGgpKTtcbiAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgY291bnQ7IG4rKykge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGN1cnJlbnRbbl07XG4gICAgICAgIGlmICh0b2tlbi5jb250ZW50Lmxlbmd0aCA9PT0gbWluTGVuZ3RoKSB7XG4gICAgICAgICAgb3V0TGluZXNbbl0ucHVzaCh0b2tlbik7XG4gICAgICAgICAgaW5kZXhlc1tuXSArPSAxO1xuICAgICAgICAgIGN1cnJlbnRbbl0gPSBsaW5lc1tuXVtpbmRleGVzW25dXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRMaW5lc1tuXS5wdXNoKHtcbiAgICAgICAgICAgIC4uLnRva2VuLFxuICAgICAgICAgICAgY29udGVudDogdG9rZW4uY29udGVudC5zbGljZSgwLCBtaW5MZW5ndGgpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY3VycmVudFtuXSA9IHtcbiAgICAgICAgICAgIC4uLnRva2VuLFxuICAgICAgICAgICAgY29udGVudDogdG9rZW4uY29udGVudC5zbGljZShtaW5MZW5ndGgpLFxuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlbi5vZmZzZXQgKyBtaW5MZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRUaGVtZXM7XG59XG5cbmZ1bmN0aW9uIGNvZGVUb1Rva2VucyhpbnRlcm5hbCwgY29kZSwgb3B0aW9ucykge1xuICBsZXQgYmc7XG4gIGxldCBmZztcbiAgbGV0IHRva2VucztcbiAgbGV0IHRoZW1lTmFtZTtcbiAgbGV0IHJvb3RTdHlsZTtcbiAgbGV0IGdyYW1tYXJTdGF0ZTtcbiAgaWYgKFwidGhlbWVzXCIgaW4gb3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRlZmF1bHRDb2xvciA9IFwibGlnaHRcIixcbiAgICAgIGNzc1ZhcmlhYmxlUHJlZml4ID0gXCItLXNoaWtpLVwiXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdGhlbWVzID0gT2JqZWN0LmVudHJpZXMob3B0aW9ucy50aGVtZXMpLmZpbHRlcigoaSkgPT4gaVsxXSkubWFwKChpKSA9PiAoeyBjb2xvcjogaVswXSwgdGhlbWU6IGlbMV0gfSkpLnNvcnQoKGEsIGIpID0+IGEuY29sb3IgPT09IGRlZmF1bHRDb2xvciA/IC0xIDogYi5jb2xvciA9PT0gZGVmYXVsdENvbG9yID8gMSA6IDApO1xuICAgIGlmICh0aGVtZXMubGVuZ3RoID09PSAwKVxuICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShcImB0aGVtZXNgIG9wdGlvbiBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcbiAgICBjb25zdCB0aGVtZVRva2VucyA9IGNvZGVUb1Rva2Vuc1dpdGhUaGVtZXMoXG4gICAgICBpbnRlcm5hbCxcbiAgICAgIGNvZGUsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBncmFtbWFyU3RhdGUgPSBnZXRMYXN0R3JhbW1hclN0YXRlRnJvbU1hcCh0aGVtZVRva2Vucyk7XG4gICAgaWYgKGRlZmF1bHRDb2xvciAmJiAhdGhlbWVzLmZpbmQoKHQpID0+IHQuY29sb3IgPT09IGRlZmF1bHRDb2xvcikpXG4gICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKGBcXGB0aGVtZXNcXGAgb3B0aW9uIG11c3QgY29udGFpbiB0aGUgZGVmYXVsdENvbG9yIGtleSBcXGAke2RlZmF1bHRDb2xvcn1cXGBgKTtcbiAgICBjb25zdCB0aGVtZVJlZ3MgPSB0aGVtZXMubWFwKCh0KSA9PiBpbnRlcm5hbC5nZXRUaGVtZSh0LnRoZW1lKSk7XG4gICAgY29uc3QgdGhlbWVzT3JkZXIgPSB0aGVtZXMubWFwKCh0KSA9PiB0LmNvbG9yKTtcbiAgICB0b2tlbnMgPSB0aGVtZVRva2Vucy5tYXAoKGxpbmUpID0+IGxpbmUubWFwKCh0b2tlbikgPT4gZmxhdFRva2VuVmFyaWFudHModG9rZW4sIHRoZW1lc09yZGVyLCBjc3NWYXJpYWJsZVByZWZpeCwgZGVmYXVsdENvbG9yKSkpO1xuICAgIGlmIChncmFtbWFyU3RhdGUpXG4gICAgICBzZXRMYXN0R3JhbW1hclN0YXRlVG9NYXAodG9rZW5zLCBncmFtbWFyU3RhdGUpO1xuICAgIGNvbnN0IHRoZW1lQ29sb3JSZXBsYWNlbWVudHMgPSB0aGVtZXMubWFwKCh0KSA9PiByZXNvbHZlQ29sb3JSZXBsYWNlbWVudHModC50aGVtZSwgb3B0aW9ucykpO1xuICAgIGZnID0gdGhlbWVzLm1hcCgodCwgaWR4KSA9PiAoaWR4ID09PSAwICYmIGRlZmF1bHRDb2xvciA/IFwiXCIgOiBgJHtjc3NWYXJpYWJsZVByZWZpeCArIHQuY29sb3J9OmApICsgKGFwcGx5Q29sb3JSZXBsYWNlbWVudHModGhlbWVSZWdzW2lkeF0uZmcsIHRoZW1lQ29sb3JSZXBsYWNlbWVudHNbaWR4XSkgfHwgXCJpbmhlcml0XCIpKS5qb2luKFwiO1wiKTtcbiAgICBiZyA9IHRoZW1lcy5tYXAoKHQsIGlkeCkgPT4gKGlkeCA9PT0gMCAmJiBkZWZhdWx0Q29sb3IgPyBcIlwiIDogYCR7Y3NzVmFyaWFibGVQcmVmaXggKyB0LmNvbG9yfS1iZzpgKSArIChhcHBseUNvbG9yUmVwbGFjZW1lbnRzKHRoZW1lUmVnc1tpZHhdLmJnLCB0aGVtZUNvbG9yUmVwbGFjZW1lbnRzW2lkeF0pIHx8IFwiaW5oZXJpdFwiKSkuam9pbihcIjtcIik7XG4gICAgdGhlbWVOYW1lID0gYHNoaWtpLXRoZW1lcyAke3RoZW1lUmVncy5tYXAoKHQpID0+IHQubmFtZSkuam9pbihcIiBcIil9YDtcbiAgICByb290U3R5bGUgPSBkZWZhdWx0Q29sb3IgPyB2b2lkIDAgOiBbZmcsIGJnXS5qb2luKFwiO1wiKTtcbiAgfSBlbHNlIGlmIChcInRoZW1lXCIgaW4gb3B0aW9ucykge1xuICAgIGNvbnN0IGNvbG9yUmVwbGFjZW1lbnRzID0gcmVzb2x2ZUNvbG9yUmVwbGFjZW1lbnRzKG9wdGlvbnMudGhlbWUsIG9wdGlvbnMpO1xuICAgIHRva2VucyA9IGNvZGVUb1Rva2Vuc0Jhc2UoXG4gICAgICBpbnRlcm5hbCxcbiAgICAgIGNvZGUsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBjb25zdCBfdGhlbWUgPSBpbnRlcm5hbC5nZXRUaGVtZShvcHRpb25zLnRoZW1lKTtcbiAgICBiZyA9IGFwcGx5Q29sb3JSZXBsYWNlbWVudHMoX3RoZW1lLmJnLCBjb2xvclJlcGxhY2VtZW50cyk7XG4gICAgZmcgPSBhcHBseUNvbG9yUmVwbGFjZW1lbnRzKF90aGVtZS5mZywgY29sb3JSZXBsYWNlbWVudHMpO1xuICAgIHRoZW1lTmFtZSA9IF90aGVtZS5uYW1lO1xuICAgIGdyYW1tYXJTdGF0ZSA9IGdldExhc3RHcmFtbWFyU3RhdGVGcm9tTWFwKHRva2Vucyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IkMShcIkludmFsaWQgb3B0aW9ucywgZWl0aGVyIGB0aGVtZWAgb3IgYHRoZW1lc2AgbXVzdCBiZSBwcm92aWRlZFwiKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRva2VucyxcbiAgICBmZyxcbiAgICBiZyxcbiAgICB0aGVtZU5hbWUsXG4gICAgcm9vdFN0eWxlLFxuICAgIGdyYW1tYXJTdGF0ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb2RlVG9IYXN0KGludGVybmFsLCBjb2RlLCBvcHRpb25zLCB0cmFuc2Zvcm1lckNvbnRleHQgPSB7XG4gIG1ldGE6IHt9LFxuICBvcHRpb25zLFxuICBjb2RlVG9IYXN0OiAoX2NvZGUsIF9vcHRpb25zKSA9PiBjb2RlVG9IYXN0KGludGVybmFsLCBfY29kZSwgX29wdGlvbnMpLFxuICBjb2RlVG9Ub2tlbnM6IChfY29kZSwgX29wdGlvbnMpID0+IGNvZGVUb1Rva2VucyhpbnRlcm5hbCwgX2NvZGUsIF9vcHRpb25zKVxufSkge1xuICBsZXQgaW5wdXQgPSBjb2RlO1xuICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIGdldFRyYW5zZm9ybWVycyhvcHRpb25zKSlcbiAgICBpbnB1dCA9IHRyYW5zZm9ybWVyLnByZXByb2Nlc3M/LmNhbGwodHJhbnNmb3JtZXJDb250ZXh0LCBpbnB1dCwgb3B0aW9ucykgfHwgaW5wdXQ7XG4gIGxldCB7XG4gICAgdG9rZW5zLFxuICAgIGZnLFxuICAgIGJnLFxuICAgIHRoZW1lTmFtZSxcbiAgICByb290U3R5bGUsXG4gICAgZ3JhbW1hclN0YXRlXG4gIH0gPSBjb2RlVG9Ub2tlbnMoaW50ZXJuYWwsIGlucHV0LCBvcHRpb25zKTtcbiAgY29uc3Qge1xuICAgIG1lcmdlV2hpdGVzcGFjZXMgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBpZiAobWVyZ2VXaGl0ZXNwYWNlcyA9PT0gdHJ1ZSlcbiAgICB0b2tlbnMgPSBtZXJnZVdoaXRlc3BhY2VUb2tlbnModG9rZW5zKTtcbiAgZWxzZSBpZiAobWVyZ2VXaGl0ZXNwYWNlcyA9PT0gXCJuZXZlclwiKVxuICAgIHRva2VucyA9IHNwbGl0V2hpdGVzcGFjZVRva2Vucyh0b2tlbnMpO1xuICBjb25zdCBjb250ZXh0U291cmNlID0ge1xuICAgIC4uLnRyYW5zZm9ybWVyQ29udGV4dCxcbiAgICBnZXQgc291cmNlKCkge1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgfTtcbiAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiBnZXRUcmFuc2Zvcm1lcnMob3B0aW9ucykpXG4gICAgdG9rZW5zID0gdHJhbnNmb3JtZXIudG9rZW5zPy5jYWxsKGNvbnRleHRTb3VyY2UsIHRva2VucykgfHwgdG9rZW5zO1xuICByZXR1cm4gdG9rZW5zVG9IYXN0KFxuICAgIHRva2VucyxcbiAgICB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgZmcsXG4gICAgICBiZyxcbiAgICAgIHRoZW1lTmFtZSxcbiAgICAgIHJvb3RTdHlsZVxuICAgIH0sXG4gICAgY29udGV4dFNvdXJjZSxcbiAgICBncmFtbWFyU3RhdGVcbiAgKTtcbn1cbmZ1bmN0aW9uIHRva2Vuc1RvSGFzdCh0b2tlbnMsIG9wdGlvbnMsIHRyYW5zZm9ybWVyQ29udGV4dCwgZ3JhbW1hclN0YXRlID0gZ2V0TGFzdEdyYW1tYXJTdGF0ZUZyb21NYXAodG9rZW5zKSkge1xuICBjb25zdCB0cmFuc2Zvcm1lcnMgPSBnZXRUcmFuc2Zvcm1lcnMob3B0aW9ucyk7XG4gIGNvbnN0IGxpbmVzID0gW107XG4gIGNvbnN0IHJvb3QgPSB7XG4gICAgdHlwZTogXCJyb290XCIsXG4gICAgY2hpbGRyZW46IFtdXG4gIH07XG4gIGNvbnN0IHtcbiAgICBzdHJ1Y3R1cmUgPSBcImNsYXNzaWNcIixcbiAgICB0YWJpbmRleCA9IFwiMFwiXG4gIH0gPSBvcHRpb25zO1xuICBsZXQgcHJlTm9kZSA9IHtcbiAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICB0YWdOYW1lOiBcInByZVwiLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGNsYXNzOiBgc2hpa2kgJHtvcHRpb25zLnRoZW1lTmFtZSB8fCBcIlwifWAsXG4gICAgICBzdHlsZTogb3B0aW9ucy5yb290U3R5bGUgfHwgYGJhY2tncm91bmQtY29sb3I6JHtvcHRpb25zLmJnfTtjb2xvcjoke29wdGlvbnMuZmd9YCxcbiAgICAgIC4uLnRhYmluZGV4ICE9PSBmYWxzZSAmJiB0YWJpbmRleCAhPSBudWxsID8ge1xuICAgICAgICB0YWJpbmRleDogdGFiaW5kZXgudG9TdHJpbmcoKVxuICAgICAgfSA6IHt9LFxuICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICBBcnJheS5mcm9tKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMubWV0YSB8fCB7fSlcbiAgICAgICAgKS5maWx0ZXIoKFtrZXldKSA9PiAha2V5LnN0YXJ0c1dpdGgoXCJfXCIpKVxuICAgICAgKVxuICAgIH0sXG4gICAgY2hpbGRyZW46IFtdXG4gIH07XG4gIGxldCBjb2RlTm9kZSA9IHtcbiAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICB0YWdOYW1lOiBcImNvZGVcIixcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICBjaGlsZHJlbjogbGluZXNcbiAgfTtcbiAgY29uc3QgbGluZU5vZGVzID0gW107XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgLi4udHJhbnNmb3JtZXJDb250ZXh0LFxuICAgIHN0cnVjdHVyZSxcbiAgICBhZGRDbGFzc1RvSGFzdCxcbiAgICBnZXQgc291cmNlKCkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyQ29udGV4dC5zb3VyY2U7XG4gICAgfSxcbiAgICBnZXQgdG9rZW5zKCkge1xuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9LFxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfSxcbiAgICBnZXQgcm9vdCgpIHtcbiAgICAgIHJldHVybiByb290O1xuICAgIH0sXG4gICAgZ2V0IHByZSgpIHtcbiAgICAgIHJldHVybiBwcmVOb2RlO1xuICAgIH0sXG4gICAgZ2V0IGNvZGUoKSB7XG4gICAgICByZXR1cm4gY29kZU5vZGU7XG4gICAgfSxcbiAgICBnZXQgbGluZXMoKSB7XG4gICAgICByZXR1cm4gbGluZU5vZGVzO1xuICAgIH1cbiAgfTtcbiAgdG9rZW5zLmZvckVhY2goKGxpbmUsIGlkeCkgPT4ge1xuICAgIGlmIChpZHgpIHtcbiAgICAgIGlmIChzdHJ1Y3R1cmUgPT09IFwiaW5saW5lXCIpXG4gICAgICAgIHJvb3QuY2hpbGRyZW4ucHVzaCh7IHR5cGU6IFwiZWxlbWVudFwiLCB0YWdOYW1lOiBcImJyXCIsIHByb3BlcnRpZXM6IHt9LCBjaGlsZHJlbjogW10gfSk7XG4gICAgICBlbHNlIGlmIChzdHJ1Y3R1cmUgPT09IFwiY2xhc3NpY1wiKVxuICAgICAgICBsaW5lcy5wdXNoKHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBcIlxcblwiIH0pO1xuICAgIH1cbiAgICBsZXQgbGluZU5vZGUgPSB7XG4gICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgIHRhZ05hbWU6IFwic3BhblwiLFxuICAgICAgcHJvcGVydGllczogeyBjbGFzczogXCJsaW5lXCIgfSxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH07XG4gICAgbGV0IGNvbCA9IDA7XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiBsaW5lKSB7XG4gICAgICBsZXQgdG9rZW5Ob2RlID0ge1xuICAgICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgICAgdGFnTmFtZTogXCJzcGFuXCIsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAuLi50b2tlbi5odG1sQXR0cnNcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IFt7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogdG9rZW4uY29udGVudCB9XVxuICAgICAgfTtcbiAgICAgIGlmICh0eXBlb2YgdG9rZW4uaHRtbFN0eWxlID09PSBcInN0cmluZ1wiKVxuICAgICAgICB3YXJuRGVwcmVjYXRlZChcImBodG1sU3R5bGVgIGFzIGEgc3RyaW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBhbiBvYmplY3QgaW5zdGVhZC5cIik7XG4gICAgICBjb25zdCBzdHlsZSA9IHN0cmluZ2lmeVRva2VuU3R5bGUodG9rZW4uaHRtbFN0eWxlIHx8IGdldFRva2VuU3R5bGVPYmplY3QodG9rZW4pKTtcbiAgICAgIGlmIChzdHlsZSlcbiAgICAgICAgdG9rZW5Ob2RlLnByb3BlcnRpZXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKVxuICAgICAgICB0b2tlbk5vZGUgPSB0cmFuc2Zvcm1lcj8uc3Bhbj8uY2FsbChjb250ZXh0LCB0b2tlbk5vZGUsIGlkeCArIDEsIGNvbCwgbGluZU5vZGUsIHRva2VuKSB8fCB0b2tlbk5vZGU7XG4gICAgICBpZiAoc3RydWN0dXJlID09PSBcImlubGluZVwiKVxuICAgICAgICByb290LmNoaWxkcmVuLnB1c2godG9rZW5Ob2RlKTtcbiAgICAgIGVsc2UgaWYgKHN0cnVjdHVyZSA9PT0gXCJjbGFzc2ljXCIpXG4gICAgICAgIGxpbmVOb2RlLmNoaWxkcmVuLnB1c2godG9rZW5Ob2RlKTtcbiAgICAgIGNvbCArPSB0b2tlbi5jb250ZW50Lmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHN0cnVjdHVyZSA9PT0gXCJjbGFzc2ljXCIpIHtcbiAgICAgIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKVxuICAgICAgICBsaW5lTm9kZSA9IHRyYW5zZm9ybWVyPy5saW5lPy5jYWxsKGNvbnRleHQsIGxpbmVOb2RlLCBpZHggKyAxKSB8fCBsaW5lTm9kZTtcbiAgICAgIGxpbmVOb2Rlcy5wdXNoKGxpbmVOb2RlKTtcbiAgICAgIGxpbmVzLnB1c2gobGluZU5vZGUpO1xuICAgIH1cbiAgfSk7XG4gIGlmIChzdHJ1Y3R1cmUgPT09IFwiY2xhc3NpY1wiKSB7XG4gICAgZm9yIChjb25zdCB0cmFuc2Zvcm1lciBvZiB0cmFuc2Zvcm1lcnMpXG4gICAgICBjb2RlTm9kZSA9IHRyYW5zZm9ybWVyPy5jb2RlPy5jYWxsKGNvbnRleHQsIGNvZGVOb2RlKSB8fCBjb2RlTm9kZTtcbiAgICBwcmVOb2RlLmNoaWxkcmVuLnB1c2goY29kZU5vZGUpO1xuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKVxuICAgICAgcHJlTm9kZSA9IHRyYW5zZm9ybWVyPy5wcmU/LmNhbGwoY29udGV4dCwgcHJlTm9kZSkgfHwgcHJlTm9kZTtcbiAgICByb290LmNoaWxkcmVuLnB1c2gocHJlTm9kZSk7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IHJvb3Q7XG4gIGZvciAoY29uc3QgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKVxuICAgIHJlc3VsdCA9IHRyYW5zZm9ybWVyPy5yb290Py5jYWxsKGNvbnRleHQsIHJlc3VsdCkgfHwgcmVzdWx0O1xuICBpZiAoZ3JhbW1hclN0YXRlKVxuICAgIHNldExhc3RHcmFtbWFyU3RhdGVUb01hcChyZXN1bHQsIGdyYW1tYXJTdGF0ZSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtZXJnZVdoaXRlc3BhY2VUb2tlbnModG9rZW5zKSB7XG4gIHJldHVybiB0b2tlbnMubWFwKChsaW5lKSA9PiB7XG4gICAgY29uc3QgbmV3TGluZSA9IFtdO1xuICAgIGxldCBjYXJyeU9uQ29udGVudCA9IFwiXCI7XG4gICAgbGV0IGZpcnN0T2Zmc2V0ID0gMDtcbiAgICBsaW5lLmZvckVhY2goKHRva2VuLCBpZHgpID0+IHtcbiAgICAgIGNvbnN0IGlzVW5kZXJsaW5lID0gdG9rZW4uZm9udFN0eWxlICYmIHRva2VuLmZvbnRTdHlsZSAmIEZvbnRTdHlsZS5VbmRlcmxpbmU7XG4gICAgICBjb25zdCBjb3VsZE1lcmdlID0gIWlzVW5kZXJsaW5lO1xuICAgICAgaWYgKGNvdWxkTWVyZ2UgJiYgdG9rZW4uY29udGVudC5tYXRjaCgvXlxccyskLykgJiYgbGluZVtpZHggKyAxXSkge1xuICAgICAgICBpZiAoIWZpcnN0T2Zmc2V0KVxuICAgICAgICAgIGZpcnN0T2Zmc2V0ID0gdG9rZW4ub2Zmc2V0O1xuICAgICAgICBjYXJyeU9uQ29udGVudCArPSB0b2tlbi5jb250ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNhcnJ5T25Db250ZW50KSB7XG4gICAgICAgICAgaWYgKGNvdWxkTWVyZ2UpIHtcbiAgICAgICAgICAgIG5ld0xpbmUucHVzaCh7XG4gICAgICAgICAgICAgIC4uLnRva2VuLFxuICAgICAgICAgICAgICBvZmZzZXQ6IGZpcnN0T2Zmc2V0LFxuICAgICAgICAgICAgICBjb250ZW50OiBjYXJyeU9uQ29udGVudCArIHRva2VuLmNvbnRlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMaW5lLnB1c2goXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBjYXJyeU9uQ29udGVudCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGZpcnN0T2Zmc2V0XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRva2VuXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaXJzdE9mZnNldCA9IDA7XG4gICAgICAgICAgY2FycnlPbkNvbnRlbnQgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0xpbmUucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3TGluZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzcGxpdFdoaXRlc3BhY2VUb2tlbnModG9rZW5zKSB7XG4gIHJldHVybiB0b2tlbnMubWFwKChsaW5lKSA9PiB7XG4gICAgcmV0dXJuIGxpbmUuZmxhdE1hcCgodG9rZW4pID0+IHtcbiAgICAgIGlmICh0b2tlbi5jb250ZW50Lm1hdGNoKC9eXFxzKyQvKSlcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgY29uc3QgbWF0Y2ggPSB0b2tlbi5jb250ZW50Lm1hdGNoKC9eKFxccyopKC4qPykoXFxzKikkLyk7XG4gICAgICBpZiAoIW1hdGNoKVxuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICBjb25zdCBbLCBsZWFkaW5nLCBjb250ZW50LCB0cmFpbGluZ10gPSBtYXRjaDtcbiAgICAgIGlmICghbGVhZGluZyAmJiAhdHJhaWxpbmcpXG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIGNvbnN0IGV4cGFuZGVkID0gW3tcbiAgICAgICAgLi4udG9rZW4sXG4gICAgICAgIG9mZnNldDogdG9rZW4ub2Zmc2V0ICsgbGVhZGluZy5sZW5ndGgsXG4gICAgICAgIGNvbnRlbnRcbiAgICAgIH1dO1xuICAgICAgaWYgKGxlYWRpbmcpIHtcbiAgICAgICAgZXhwYW5kZWQudW5zaGlmdCh7XG4gICAgICAgICAgY29udGVudDogbGVhZGluZyxcbiAgICAgICAgICBvZmZzZXQ6IHRva2VuLm9mZnNldFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFpbGluZykge1xuICAgICAgICBleHBhbmRlZC5wdXNoKHtcbiAgICAgICAgICBjb250ZW50OiB0cmFpbGluZyxcbiAgICAgICAgICBvZmZzZXQ6IHRva2VuLm9mZnNldCArIGxlYWRpbmcubGVuZ3RoICsgY29udGVudC5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwYW5kZWQ7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb2RlVG9IdG1sKGludGVybmFsLCBjb2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgbWV0YToge30sXG4gICAgb3B0aW9ucyxcbiAgICBjb2RlVG9IYXN0OiAoX2NvZGUsIF9vcHRpb25zKSA9PiBjb2RlVG9IYXN0KGludGVybmFsLCBfY29kZSwgX29wdGlvbnMpLFxuICAgIGNvZGVUb1Rva2VuczogKF9jb2RlLCBfb3B0aW9ucykgPT4gY29kZVRvVG9rZW5zKGludGVybmFsLCBfY29kZSwgX29wdGlvbnMpXG4gIH07XG4gIGxldCByZXN1bHQgPSB0b0h0bWwoY29kZVRvSGFzdChpbnRlcm5hbCwgY29kZSwgb3B0aW9ucywgY29udGV4dCkpO1xuICBmb3IgKGNvbnN0IHRyYW5zZm9ybWVyIG9mIGdldFRyYW5zZm9ybWVycyhvcHRpb25zKSlcbiAgICByZXN1bHQgPSB0cmFuc2Zvcm1lci5wb3N0cHJvY2Vzcz8uY2FsbChjb250ZXh0LCByZXN1bHQsIG9wdGlvbnMpIHx8IHJlc3VsdDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgVlNDT0RFX0ZBTExCQUNLX0VESVRPUl9GRyA9IHsgbGlnaHQ6IFwiIzMzMzMzM1wiLCBkYXJrOiBcIiNiYmJiYmJcIiB9O1xuY29uc3QgVlNDT0RFX0ZBTExCQUNLX0VESVRPUl9CRyA9IHsgbGlnaHQ6IFwiI2ZmZmZmZVwiLCBkYXJrOiBcIiMxZTFlMWVcIiB9O1xuY29uc3QgUkVTT0xWRURfS0VZID0gXCJfX3NoaWtpX3Jlc29sdmVkXCI7XG5mdW5jdGlvbiBub3JtYWxpemVUaGVtZShyYXdUaGVtZSkge1xuICBpZiAocmF3VGhlbWU/LltSRVNPTFZFRF9LRVldKVxuICAgIHJldHVybiByYXdUaGVtZTtcbiAgY29uc3QgdGhlbWUgPSB7XG4gICAgLi4ucmF3VGhlbWVcbiAgfTtcbiAgaWYgKHRoZW1lLnRva2VuQ29sb3JzICYmICF0aGVtZS5zZXR0aW5ncykge1xuICAgIHRoZW1lLnNldHRpbmdzID0gdGhlbWUudG9rZW5Db2xvcnM7XG4gICAgZGVsZXRlIHRoZW1lLnRva2VuQ29sb3JzO1xuICB9XG4gIHRoZW1lLnR5cGUgfHw9IFwiZGFya1wiO1xuICB0aGVtZS5jb2xvclJlcGxhY2VtZW50cyA9IHsgLi4udGhlbWUuY29sb3JSZXBsYWNlbWVudHMgfTtcbiAgdGhlbWUuc2V0dGluZ3MgfHw9IFtdO1xuICBsZXQgeyBiZywgZmcgfSA9IHRoZW1lO1xuICBpZiAoIWJnIHx8ICFmZykge1xuICAgIGNvbnN0IGdsb2JhbFNldHRpbmcgPSB0aGVtZS5zZXR0aW5ncyA/IHRoZW1lLnNldHRpbmdzLmZpbmQoKHMpID0+ICFzLm5hbWUgJiYgIXMuc2NvcGUpIDogdm9pZCAwO1xuICAgIGlmIChnbG9iYWxTZXR0aW5nPy5zZXR0aW5ncz8uZm9yZWdyb3VuZClcbiAgICAgIGZnID0gZ2xvYmFsU2V0dGluZy5zZXR0aW5ncy5mb3JlZ3JvdW5kO1xuICAgIGlmIChnbG9iYWxTZXR0aW5nPy5zZXR0aW5ncz8uYmFja2dyb3VuZClcbiAgICAgIGJnID0gZ2xvYmFsU2V0dGluZy5zZXR0aW5ncy5iYWNrZ3JvdW5kO1xuICAgIGlmICghZmcgJiYgdGhlbWU/LmNvbG9ycz8uW1wiZWRpdG9yLmZvcmVncm91bmRcIl0pXG4gICAgICBmZyA9IHRoZW1lLmNvbG9yc1tcImVkaXRvci5mb3JlZ3JvdW5kXCJdO1xuICAgIGlmICghYmcgJiYgdGhlbWU/LmNvbG9ycz8uW1wiZWRpdG9yLmJhY2tncm91bmRcIl0pXG4gICAgICBiZyA9IHRoZW1lLmNvbG9yc1tcImVkaXRvci5iYWNrZ3JvdW5kXCJdO1xuICAgIGlmICghZmcpXG4gICAgICBmZyA9IHRoZW1lLnR5cGUgPT09IFwibGlnaHRcIiA/IFZTQ09ERV9GQUxMQkFDS19FRElUT1JfRkcubGlnaHQgOiBWU0NPREVfRkFMTEJBQ0tfRURJVE9SX0ZHLmRhcms7XG4gICAgaWYgKCFiZylcbiAgICAgIGJnID0gdGhlbWUudHlwZSA9PT0gXCJsaWdodFwiID8gVlNDT0RFX0ZBTExCQUNLX0VESVRPUl9CRy5saWdodCA6IFZTQ09ERV9GQUxMQkFDS19FRElUT1JfQkcuZGFyaztcbiAgICB0aGVtZS5mZyA9IGZnO1xuICAgIHRoZW1lLmJnID0gYmc7XG4gIH1cbiAgaWYgKCEodGhlbWUuc2V0dGluZ3NbMF0gJiYgdGhlbWUuc2V0dGluZ3NbMF0uc2V0dGluZ3MgJiYgIXRoZW1lLnNldHRpbmdzWzBdLnNjb3BlKSkge1xuICAgIHRoZW1lLnNldHRpbmdzLnVuc2hpZnQoe1xuICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgZm9yZWdyb3VuZDogdGhlbWUuZmcsXG4gICAgICAgIGJhY2tncm91bmQ6IHRoZW1lLmJnXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbGV0IHJlcGxhY2VtZW50Q291bnQgPSAwO1xuICBjb25zdCByZXBsYWNlbWVudE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIGdldFJlcGxhY2VtZW50Q29sb3IodmFsdWUpIHtcbiAgICBpZiAocmVwbGFjZW1lbnRNYXAuaGFzKHZhbHVlKSlcbiAgICAgIHJldHVybiByZXBsYWNlbWVudE1hcC5nZXQodmFsdWUpO1xuICAgIHJlcGxhY2VtZW50Q291bnQgKz0gMTtcbiAgICBjb25zdCBoZXggPSBgIyR7cmVwbGFjZW1lbnRDb3VudC50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpLnRvTG93ZXJDYXNlKCl9YDtcbiAgICBpZiAodGhlbWUuY29sb3JSZXBsYWNlbWVudHM/LltgIyR7aGV4fWBdKVxuICAgICAgcmV0dXJuIGdldFJlcGxhY2VtZW50Q29sb3IodmFsdWUpO1xuICAgIHJlcGxhY2VtZW50TWFwLnNldCh2YWx1ZSwgaGV4KTtcbiAgICByZXR1cm4gaGV4O1xuICB9XG4gIHRoZW1lLnNldHRpbmdzID0gdGhlbWUuc2V0dGluZ3MubWFwKChzZXR0aW5nKSA9PiB7XG4gICAgY29uc3QgcmVwbGFjZUZnID0gc2V0dGluZy5zZXR0aW5ncz8uZm9yZWdyb3VuZCAmJiAhc2V0dGluZy5zZXR0aW5ncy5mb3JlZ3JvdW5kLnN0YXJ0c1dpdGgoXCIjXCIpO1xuICAgIGNvbnN0IHJlcGxhY2VCZyA9IHNldHRpbmcuc2V0dGluZ3M/LmJhY2tncm91bmQgJiYgIXNldHRpbmcuc2V0dGluZ3MuYmFja2dyb3VuZC5zdGFydHNXaXRoKFwiI1wiKTtcbiAgICBpZiAoIXJlcGxhY2VGZyAmJiAhcmVwbGFjZUJnKVxuICAgICAgcmV0dXJuIHNldHRpbmc7XG4gICAgY29uc3QgY2xvbmUgPSB7XG4gICAgICAuLi5zZXR0aW5nLFxuICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgLi4uc2V0dGluZy5zZXR0aW5nc1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHJlcGxhY2VGZykge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBnZXRSZXBsYWNlbWVudENvbG9yKHNldHRpbmcuc2V0dGluZ3MuZm9yZWdyb3VuZCk7XG4gICAgICB0aGVtZS5jb2xvclJlcGxhY2VtZW50c1tyZXBsYWNlbWVudF0gPSBzZXR0aW5nLnNldHRpbmdzLmZvcmVncm91bmQ7XG4gICAgICBjbG9uZS5zZXR0aW5ncy5mb3JlZ3JvdW5kID0gcmVwbGFjZW1lbnQ7XG4gICAgfVxuICAgIGlmIChyZXBsYWNlQmcpIHtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gZ2V0UmVwbGFjZW1lbnRDb2xvcihzZXR0aW5nLnNldHRpbmdzLmJhY2tncm91bmQpO1xuICAgICAgdGhlbWUuY29sb3JSZXBsYWNlbWVudHNbcmVwbGFjZW1lbnRdID0gc2V0dGluZy5zZXR0aW5ncy5iYWNrZ3JvdW5kO1xuICAgICAgY2xvbmUuc2V0dGluZ3MuYmFja2dyb3VuZCA9IHJlcGxhY2VtZW50O1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG4gIH0pO1xuICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGVtZS5jb2xvcnMgfHwge30pKSB7XG4gICAgaWYgKGtleSA9PT0gXCJlZGl0b3IuZm9yZWdyb3VuZFwiIHx8IGtleSA9PT0gXCJlZGl0b3IuYmFja2dyb3VuZFwiIHx8IGtleS5zdGFydHNXaXRoKFwidGVybWluYWwuYW5zaVwiKSkge1xuICAgICAgaWYgKCF0aGVtZS5jb2xvcnNba2V5XT8uc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBnZXRSZXBsYWNlbWVudENvbG9yKHRoZW1lLmNvbG9yc1trZXldKTtcbiAgICAgICAgdGhlbWUuY29sb3JSZXBsYWNlbWVudHNbcmVwbGFjZW1lbnRdID0gdGhlbWUuY29sb3JzW2tleV07XG4gICAgICAgIHRoZW1lLmNvbG9yc1trZXldID0gcmVwbGFjZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGVtZSwgUkVTT0xWRURfS0VZLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gdGhlbWU7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVMYW5ncyhsYW5ncykge1xuICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KChhd2FpdCBQcm9taXNlLmFsbChcbiAgICBsYW5ncy5maWx0ZXIoKGwpID0+ICFpc1NwZWNpYWxMYW5nKGwpKS5tYXAoYXN5bmMgKGxhbmcpID0+IGF3YWl0IG5vcm1hbGl6ZUdldHRlcihsYW5nKS50aGVuKChyKSA9PiBBcnJheS5pc0FycmF5KHIpID8gciA6IFtyXSkpXG4gICkpLmZsYXQoKSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVRoZW1lcyh0aGVtZXMpIHtcbiAgY29uc3QgcmVzb2x2ZWQgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICB0aGVtZXMubWFwKFxuICAgICAgYXN5bmMgKHRoZW1lKSA9PiBpc1NwZWNpYWxUaGVtZSh0aGVtZSkgPyBudWxsIDogbm9ybWFsaXplVGhlbWUoYXdhaXQgbm9ybWFsaXplR2V0dGVyKHRoZW1lKSlcbiAgICApXG4gICk7XG4gIHJldHVybiByZXNvbHZlZC5maWx0ZXIoKGkpID0+ICEhaSk7XG59XG5cbmNsYXNzIFNoaWtpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNoaWtpRXJyb3JcIjtcbiAgfVxufVxuXG5jbGFzcyBSZWdpc3RyeSBleHRlbmRzIFJlZ2lzdHJ5JDEge1xuICBjb25zdHJ1Y3RvcihfcmVzb2x2ZXIsIF90aGVtZXMsIF9sYW5ncywgX2FsaWFzID0ge30pIHtcbiAgICBzdXBlcihfcmVzb2x2ZXIpO1xuICAgIHRoaXMuX3Jlc29sdmVyID0gX3Jlc29sdmVyO1xuICAgIHRoaXMuX3RoZW1lcyA9IF90aGVtZXM7XG4gICAgdGhpcy5fbGFuZ3MgPSBfbGFuZ3M7XG4gICAgdGhpcy5fYWxpYXMgPSBfYWxpYXM7XG4gICAgdGhpcy5fdGhlbWVzLm1hcCgodCkgPT4gdGhpcy5sb2FkVGhlbWUodCkpO1xuICAgIHRoaXMubG9hZExhbmd1YWdlcyh0aGlzLl9sYW5ncyk7XG4gIH1cbiAgX3Jlc29sdmVkVGhlbWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgX3Jlc29sdmVkR3JhbW1hcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfbGFuZ01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIF9sYW5nR3JhcGggPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfdGV4dG1hdGVUaGVtZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gIF9sb2FkZWRUaGVtZXNDYWNoZSA9IG51bGw7XG4gIF9sb2FkZWRMYW5ndWFnZXNDYWNoZSA9IG51bGw7XG4gIGdldFRoZW1lKHRoZW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlZFRoZW1lcy5nZXQodGhlbWUpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLmxvYWRUaGVtZSh0aGVtZSk7XG4gIH1cbiAgbG9hZFRoZW1lKHRoZW1lKSB7XG4gICAgY29uc3QgX3RoZW1lID0gbm9ybWFsaXplVGhlbWUodGhlbWUpO1xuICAgIGlmIChfdGhlbWUubmFtZSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZWRUaGVtZXMuc2V0KF90aGVtZS5uYW1lLCBfdGhlbWUpO1xuICAgICAgdGhpcy5fbG9hZGVkVGhlbWVzQ2FjaGUgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gX3RoZW1lO1xuICB9XG4gIGdldExvYWRlZFRoZW1lcygpIHtcbiAgICBpZiAoIXRoaXMuX2xvYWRlZFRoZW1lc0NhY2hlKVxuICAgICAgdGhpcy5fbG9hZGVkVGhlbWVzQ2FjaGUgPSBbLi4udGhpcy5fcmVzb2x2ZWRUaGVtZXMua2V5cygpXTtcbiAgICByZXR1cm4gdGhpcy5fbG9hZGVkVGhlbWVzQ2FjaGU7XG4gIH1cbiAgLy8gT3ZlcnJpZGUgYW5kIHJlLWltcGxlbWVudCB0aGlzIG1ldGhvZCB0byBjYWNoZSB0aGUgdGV4dG1hdGUgdGhlbWVzIGFzIGBUZXh0TWF0ZVRoZW1lLmNyZWF0ZUZyb21SYXdUaGVtZWBcbiAgLy8gaXMgZXhwZW5zaXZlLiBUaGVtZXMgY2FuIHN3aXRjaCBvZnRlbiBlc3BlY2lhbGx5IGZvciBkdWFsLXRoZW1lIHN1cHBvcnQuXG4gIC8vXG4gIC8vIFRoZSBwYXJlbnQgY2xhc3MgYWxzbyBhY2NlcHRzIGBjb2xvck1hcGAgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIsIGJ1dCBzaW5jZSB3ZSBkb24ndCB1c2UgdGhhdCxcbiAgLy8gd2Ugb21pdCBoZXJlIHNvIGl0J3MgZWFzaWVyIHRvIGNhY2hlIHRoZSB0aGVtZXMuXG4gIHNldFRoZW1lKHRoZW1lKSB7XG4gICAgbGV0IHRleHRtYXRlVGhlbWUgPSB0aGlzLl90ZXh0bWF0ZVRoZW1lQ2FjaGUuZ2V0KHRoZW1lKTtcbiAgICBpZiAoIXRleHRtYXRlVGhlbWUpIHtcbiAgICAgIHRleHRtYXRlVGhlbWUgPSBUaGVtZS5jcmVhdGVGcm9tUmF3VGhlbWUodGhlbWUpO1xuICAgICAgdGhpcy5fdGV4dG1hdGVUaGVtZUNhY2hlLnNldCh0aGVtZSwgdGV4dG1hdGVUaGVtZSk7XG4gICAgfVxuICAgIHRoaXMuX3N5bmNSZWdpc3RyeS5zZXRUaGVtZSh0ZXh0bWF0ZVRoZW1lKTtcbiAgfVxuICBnZXRHcmFtbWFyKG5hbWUpIHtcbiAgICBpZiAodGhpcy5fYWxpYXNbbmFtZV0pIHtcbiAgICAgIGNvbnN0IHJlc29sdmVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW25hbWVdKTtcbiAgICAgIHdoaWxlICh0aGlzLl9hbGlhc1tuYW1lXSkge1xuICAgICAgICBuYW1lID0gdGhpcy5fYWxpYXNbbmFtZV07XG4gICAgICAgIGlmIChyZXNvbHZlZC5oYXMobmFtZSkpXG4gICAgICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IoYENpcmN1bGFyIGFsaWFzIFxcYCR7QXJyYXkuZnJvbShyZXNvbHZlZCkuam9pbihcIiAtPiBcIil9IC0+ICR7bmFtZX1cXGBgKTtcbiAgICAgICAgcmVzb2x2ZWQuYWRkKG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZWRHcmFtbWFycy5nZXQobmFtZSk7XG4gIH1cbiAgbG9hZExhbmd1YWdlKGxhbmcpIHtcbiAgICBpZiAodGhpcy5nZXRHcmFtbWFyKGxhbmcubmFtZSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZW1iZWRkZWRMYXppbHlCeSA9IG5ldyBTZXQoXG4gICAgICBbLi4udGhpcy5fbGFuZ01hcC52YWx1ZXMoKV0uZmlsdGVyKChpKSA9PiBpLmVtYmVkZGVkTGFuZ3NMYXp5Py5pbmNsdWRlcyhsYW5nLm5hbWUpKVxuICAgICk7XG4gICAgdGhpcy5fcmVzb2x2ZXIuYWRkTGFuZ3VhZ2UobGFuZyk7XG4gICAgY29uc3QgZ3JhbW1hckNvbmZpZyA9IHtcbiAgICAgIGJhbGFuY2VkQnJhY2tldFNlbGVjdG9yczogbGFuZy5iYWxhbmNlZEJyYWNrZXRTZWxlY3RvcnMgfHwgW1wiKlwiXSxcbiAgICAgIHVuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzOiBsYW5nLnVuYmFsYW5jZWRCcmFja2V0U2VsZWN0b3JzIHx8IFtdXG4gICAgfTtcbiAgICB0aGlzLl9zeW5jUmVnaXN0cnkuX3Jhd0dyYW1tYXJzLnNldChsYW5nLnNjb3BlTmFtZSwgbGFuZyk7XG4gICAgY29uc3QgZyA9IHRoaXMubG9hZEdyYW1tYXJXaXRoQ29uZmlndXJhdGlvbihsYW5nLnNjb3BlTmFtZSwgMSwgZ3JhbW1hckNvbmZpZyk7XG4gICAgZy5uYW1lID0gbGFuZy5uYW1lO1xuICAgIHRoaXMuX3Jlc29sdmVkR3JhbW1hcnMuc2V0KGxhbmcubmFtZSwgZyk7XG4gICAgaWYgKGxhbmcuYWxpYXNlcykge1xuICAgICAgbGFuZy5hbGlhc2VzLmZvckVhY2goKGFsaWFzKSA9PiB7XG4gICAgICAgIHRoaXMuX2FsaWFzW2FsaWFzXSA9IGxhbmcubmFtZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWRMYW5ndWFnZXNDYWNoZSA9IG51bGw7XG4gICAgaWYgKGVtYmVkZGVkTGF6aWx5Qnkuc2l6ZSkge1xuICAgICAgZm9yIChjb25zdCBlIG9mIGVtYmVkZGVkTGF6aWx5QnkpIHtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZWRHcmFtbWFycy5kZWxldGUoZS5uYW1lKTtcbiAgICAgICAgdGhpcy5fbG9hZGVkTGFuZ3VhZ2VzQ2FjaGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9zeW5jUmVnaXN0cnk/Ll9pbmplY3Rpb25HcmFtbWFycz8uZGVsZXRlKGUuc2NvcGVOYW1lKTtcbiAgICAgICAgdGhpcy5fc3luY1JlZ2lzdHJ5Py5fZ3JhbW1hcnM/LmRlbGV0ZShlLnNjb3BlTmFtZSk7XG4gICAgICAgIHRoaXMubG9hZExhbmd1YWdlKHRoaXMuX2xhbmdNYXAuZ2V0KGUubmFtZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9yZXNvbHZlZFRoZW1lcy5jbGVhcigpO1xuICAgIHRoaXMuX3Jlc29sdmVkR3JhbW1hcnMuY2xlYXIoKTtcbiAgICB0aGlzLl9sYW5nTWFwLmNsZWFyKCk7XG4gICAgdGhpcy5fbGFuZ0dyYXBoLmNsZWFyKCk7XG4gICAgdGhpcy5fbG9hZGVkVGhlbWVzQ2FjaGUgPSBudWxsO1xuICB9XG4gIGxvYWRMYW5ndWFnZXMobGFuZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGxhbmcgb2YgbGFuZ3MpXG4gICAgICB0aGlzLnJlc29sdmVFbWJlZGRlZExhbmd1YWdlcyhsYW5nKTtcbiAgICBjb25zdCBsYW5nc0dyYXBoQXJyYXkgPSBBcnJheS5mcm9tKHRoaXMuX2xhbmdHcmFwaC5lbnRyaWVzKCkpO1xuICAgIGNvbnN0IG1pc3NpbmdMYW5ncyA9IGxhbmdzR3JhcGhBcnJheS5maWx0ZXIoKFtfLCBsYW5nXSkgPT4gIWxhbmcpO1xuICAgIGlmIChtaXNzaW5nTGFuZ3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBkZXBlbmRlbnRzID0gbGFuZ3NHcmFwaEFycmF5LmZpbHRlcigoW18sIGxhbmddKSA9PiBsYW5nICYmIGxhbmcuZW1iZWRkZWRMYW5ncz8uc29tZSgobCkgPT4gbWlzc2luZ0xhbmdzLm1hcCgoW25hbWVdKSA9PiBuYW1lKS5pbmNsdWRlcyhsKSkpLmZpbHRlcigobGFuZykgPT4gIW1pc3NpbmdMYW5ncy5pbmNsdWRlcyhsYW5nKSk7XG4gICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvcihgTWlzc2luZyBsYW5ndWFnZXMgJHttaXNzaW5nTGFuZ3MubWFwKChbbmFtZV0pID0+IGBcXGAke25hbWV9XFxgYCkuam9pbihcIiwgXCIpfSwgcmVxdWlyZWQgYnkgJHtkZXBlbmRlbnRzLm1hcCgoW25hbWVdKSA9PiBgXFxgJHtuYW1lfVxcYGApLmpvaW4oXCIsIFwiKX1gKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbXywgbGFuZ10gb2YgbGFuZ3NHcmFwaEFycmF5KVxuICAgICAgdGhpcy5fcmVzb2x2ZXIuYWRkTGFuZ3VhZ2UobGFuZyk7XG4gICAgZm9yIChjb25zdCBbXywgbGFuZ10gb2YgbGFuZ3NHcmFwaEFycmF5KVxuICAgICAgdGhpcy5sb2FkTGFuZ3VhZ2UobGFuZyk7XG4gIH1cbiAgZ2V0TG9hZGVkTGFuZ3VhZ2VzKCkge1xuICAgIGlmICghdGhpcy5fbG9hZGVkTGFuZ3VhZ2VzQ2FjaGUpIHtcbiAgICAgIHRoaXMuX2xvYWRlZExhbmd1YWdlc0NhY2hlID0gW1xuICAgICAgICAuLi4vKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4udGhpcy5fcmVzb2x2ZWRHcmFtbWFycy5rZXlzKCksIC4uLk9iamVjdC5rZXlzKHRoaXMuX2FsaWFzKV0pXG4gICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbG9hZGVkTGFuZ3VhZ2VzQ2FjaGU7XG4gIH1cbiAgcmVzb2x2ZUVtYmVkZGVkTGFuZ3VhZ2VzKGxhbmcpIHtcbiAgICB0aGlzLl9sYW5nTWFwLnNldChsYW5nLm5hbWUsIGxhbmcpO1xuICAgIHRoaXMuX2xhbmdHcmFwaC5zZXQobGFuZy5uYW1lLCBsYW5nKTtcbiAgICBpZiAobGFuZy5lbWJlZGRlZExhbmdzKSB7XG4gICAgICBmb3IgKGNvbnN0IGVtYmVkZGVkTGFuZyBvZiBsYW5nLmVtYmVkZGVkTGFuZ3MpXG4gICAgICAgIHRoaXMuX2xhbmdHcmFwaC5zZXQoZW1iZWRkZWRMYW5nLCB0aGlzLl9sYW5nTWFwLmdldChlbWJlZGRlZExhbmcpKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgUmVzb2x2ZXIge1xuICBfbGFuZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfc2NvcGVUb0xhbmcgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfaW5qZWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIF9vbmlnTGliO1xuICBjb25zdHJ1Y3RvcihlbmdpbmUsIGxhbmdzKSB7XG4gICAgdGhpcy5fb25pZ0xpYiA9IHtcbiAgICAgIGNyZWF0ZU9uaWdTY2FubmVyOiAocGF0dGVybnMpID0+IGVuZ2luZS5jcmVhdGVTY2FubmVyKHBhdHRlcm5zKSxcbiAgICAgIGNyZWF0ZU9uaWdTdHJpbmc6IChzKSA9PiBlbmdpbmUuY3JlYXRlU3RyaW5nKHMpXG4gICAgfTtcbiAgICBsYW5ncy5mb3JFYWNoKChpKSA9PiB0aGlzLmFkZExhbmd1YWdlKGkpKTtcbiAgfVxuICBnZXQgb25pZ0xpYigpIHtcbiAgICByZXR1cm4gdGhpcy5fb25pZ0xpYjtcbiAgfVxuICBnZXRMYW5nUmVnaXN0cmF0aW9uKGxhbmdJZE9yQWxpYXMpIHtcbiAgICByZXR1cm4gdGhpcy5fbGFuZ3MuZ2V0KGxhbmdJZE9yQWxpYXMpO1xuICB9XG4gIGxvYWRHcmFtbWFyKHNjb3BlTmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9zY29wZVRvTGFuZy5nZXQoc2NvcGVOYW1lKTtcbiAgfVxuICBhZGRMYW5ndWFnZShsKSB7XG4gICAgdGhpcy5fbGFuZ3Muc2V0KGwubmFtZSwgbCk7XG4gICAgaWYgKGwuYWxpYXNlcykge1xuICAgICAgbC5hbGlhc2VzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgdGhpcy5fbGFuZ3Muc2V0KGEsIGwpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3Njb3BlVG9MYW5nLnNldChsLnNjb3BlTmFtZSwgbCk7XG4gICAgaWYgKGwuaW5qZWN0VG8pIHtcbiAgICAgIGwuaW5qZWN0VG8uZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuX2luamVjdGlvbnMuZ2V0KGkpKVxuICAgICAgICAgIHRoaXMuX2luamVjdGlvbnMuc2V0KGksIFtdKTtcbiAgICAgICAgdGhpcy5faW5qZWN0aW9ucy5nZXQoaSkucHVzaChsLnNjb3BlTmFtZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0SW5qZWN0aW9ucyhzY29wZU5hbWUpIHtcbiAgICBjb25zdCBzY29wZVBhcnRzID0gc2NvcGVOYW1lLnNwbGl0KFwiLlwiKTtcbiAgICBsZXQgaW5qZWN0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHNjb3BlUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN1YlNjb3BlTmFtZSA9IHNjb3BlUGFydHMuc2xpY2UoMCwgaSkuam9pbihcIi5cIik7XG4gICAgICBpbmplY3Rpb25zID0gWy4uLmluamVjdGlvbnMsIC4uLnRoaXMuX2luamVjdGlvbnMuZ2V0KHN1YlNjb3BlTmFtZSkgfHwgW11dO1xuICAgIH1cbiAgICByZXR1cm4gaW5qZWN0aW9ucztcbiAgfVxufVxuXG5sZXQgaW5zdGFuY2VzQ291bnQgPSAwO1xuZnVuY3Rpb24gY3JlYXRlU2hpa2lJbnRlcm5hbFN5bmMob3B0aW9ucykge1xuICBpbnN0YW5jZXNDb3VudCArPSAxO1xuICBpZiAob3B0aW9ucy53YXJuaW5ncyAhPT0gZmFsc2UgJiYgaW5zdGFuY2VzQ291bnQgPj0gMTAgJiYgaW5zdGFuY2VzQ291bnQgJSAxMCA9PT0gMClcbiAgICBjb25zb2xlLndhcm4oYFtTaGlraV0gJHtpbnN0YW5jZXNDb3VudH0gaW5zdGFuY2VzIGhhdmUgYmVlbiBjcmVhdGVkLiBTaGlraSBpcyBzdXBwb3NlZCB0byBiZSB1c2VkIGFzIGEgc2luZ2xldG9uLCBjb25zaWRlciByZWZhY3RvcmluZyB5b3VyIGNvZGUgdG8gY2FjaGUgeW91ciBoaWdobGlnaHRlciBpbnN0YW5jZTsgT3IgY2FsbCBcXGBoaWdobGlnaHRlci5kaXNwb3NlKClcXGAgdG8gcmVsZWFzZSB1bnVzZWQgaW5zdGFuY2VzLmApO1xuICBsZXQgaXNEaXNwb3NlZCA9IGZhbHNlO1xuICBpZiAoIW9wdGlvbnMuZW5naW5lKVxuICAgIHRocm93IG5ldyBTaGlraUVycm9yKFwiYGVuZ2luZWAgb3B0aW9uIGlzIHJlcXVpcmVkIGZvciBzeW5jaHJvbm91cyBtb2RlXCIpO1xuICBjb25zdCBsYW5ncyA9IChvcHRpb25zLmxhbmdzIHx8IFtdKS5mbGF0KDEpO1xuICBjb25zdCB0aGVtZXMgPSAob3B0aW9ucy50aGVtZXMgfHwgW10pLmZsYXQoMSkubWFwKG5vcm1hbGl6ZVRoZW1lKTtcbiAgY29uc3QgcmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXIob3B0aW9ucy5lbmdpbmUsIGxhbmdzKTtcbiAgY29uc3QgX3JlZ2lzdHJ5ID0gbmV3IFJlZ2lzdHJ5KHJlc29sdmVyLCB0aGVtZXMsIGxhbmdzLCBvcHRpb25zLmxhbmdBbGlhcyk7XG4gIGxldCBfbGFzdFRoZW1lO1xuICBmdW5jdGlvbiBnZXRMYW5ndWFnZShuYW1lKSB7XG4gICAgZW5zdXJlTm90RGlzcG9zZWQoKTtcbiAgICBjb25zdCBfbGFuZyA9IF9yZWdpc3RyeS5nZXRHcmFtbWFyKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiID8gbmFtZSA6IG5hbWUubmFtZSk7XG4gICAgaWYgKCFfbGFuZylcbiAgICAgIHRocm93IG5ldyBTaGlraUVycm9yKGBMYW5ndWFnZSBcXGAke25hbWV9XFxgIG5vdCBmb3VuZCwgeW91IG1heSBuZWVkIHRvIGxvYWQgaXQgZmlyc3RgKTtcbiAgICByZXR1cm4gX2xhbmc7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VGhlbWUobmFtZSkge1xuICAgIGlmIChuYW1lID09PSBcIm5vbmVcIilcbiAgICAgIHJldHVybiB7IGJnOiBcIlwiLCBmZzogXCJcIiwgbmFtZTogXCJub25lXCIsIHNldHRpbmdzOiBbXSwgdHlwZTogXCJkYXJrXCIgfTtcbiAgICBlbnN1cmVOb3REaXNwb3NlZCgpO1xuICAgIGNvbnN0IF90aGVtZSA9IF9yZWdpc3RyeS5nZXRUaGVtZShuYW1lKTtcbiAgICBpZiAoIV90aGVtZSlcbiAgICAgIHRocm93IG5ldyBTaGlraUVycm9yKGBUaGVtZSBcXGAke25hbWV9XFxgIG5vdCBmb3VuZCwgeW91IG1heSBuZWVkIHRvIGxvYWQgaXQgZmlyc3RgKTtcbiAgICByZXR1cm4gX3RoZW1lO1xuICB9XG4gIGZ1bmN0aW9uIHNldFRoZW1lKG5hbWUpIHtcbiAgICBlbnN1cmVOb3REaXNwb3NlZCgpO1xuICAgIGNvbnN0IHRoZW1lID0gZ2V0VGhlbWUobmFtZSk7XG4gICAgaWYgKF9sYXN0VGhlbWUgIT09IG5hbWUpIHtcbiAgICAgIF9yZWdpc3RyeS5zZXRUaGVtZSh0aGVtZSk7XG4gICAgICBfbGFzdFRoZW1lID0gbmFtZTtcbiAgICB9XG4gICAgY29uc3QgY29sb3JNYXAgPSBfcmVnaXN0cnkuZ2V0Q29sb3JNYXAoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdGhlbWUsXG4gICAgICBjb2xvck1hcFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0TG9hZGVkVGhlbWVzKCkge1xuICAgIGVuc3VyZU5vdERpc3Bvc2VkKCk7XG4gICAgcmV0dXJuIF9yZWdpc3RyeS5nZXRMb2FkZWRUaGVtZXMoKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRMb2FkZWRMYW5ndWFnZXMoKSB7XG4gICAgZW5zdXJlTm90RGlzcG9zZWQoKTtcbiAgICByZXR1cm4gX3JlZ2lzdHJ5LmdldExvYWRlZExhbmd1YWdlcygpO1xuICB9XG4gIGZ1bmN0aW9uIGxvYWRMYW5ndWFnZVN5bmMoLi4ubGFuZ3MyKSB7XG4gICAgZW5zdXJlTm90RGlzcG9zZWQoKTtcbiAgICBfcmVnaXN0cnkubG9hZExhbmd1YWdlcyhsYW5nczIuZmxhdCgxKSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbG9hZExhbmd1YWdlKC4uLmxhbmdzMikge1xuICAgIHJldHVybiBsb2FkTGFuZ3VhZ2VTeW5jKGF3YWl0IHJlc29sdmVMYW5ncyhsYW5nczIpKTtcbiAgfVxuICBmdW5jdGlvbiBsb2FkVGhlbWVTeW5jKC4uLnRoZW1lczIpIHtcbiAgICBlbnN1cmVOb3REaXNwb3NlZCgpO1xuICAgIGZvciAoY29uc3QgdGhlbWUgb2YgdGhlbWVzMi5mbGF0KDEpKSB7XG4gICAgICBfcmVnaXN0cnkubG9hZFRoZW1lKHRoZW1lKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbG9hZFRoZW1lKC4uLnRoZW1lczIpIHtcbiAgICBlbnN1cmVOb3REaXNwb3NlZCgpO1xuICAgIHJldHVybiBsb2FkVGhlbWVTeW5jKGF3YWl0IHJlc29sdmVUaGVtZXModGhlbWVzMikpO1xuICB9XG4gIGZ1bmN0aW9uIGVuc3VyZU5vdERpc3Bvc2VkKCkge1xuICAgIGlmIChpc0Rpc3Bvc2VkKVxuICAgICAgdGhyb3cgbmV3IFNoaWtpRXJyb3IoXCJTaGlraSBpbnN0YW5jZSBoYXMgYmVlbiBkaXNwb3NlZFwiKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGlmIChpc0Rpc3Bvc2VkKVxuICAgICAgcmV0dXJuO1xuICAgIGlzRGlzcG9zZWQgPSB0cnVlO1xuICAgIF9yZWdpc3RyeS5kaXNwb3NlKCk7XG4gICAgaW5zdGFuY2VzQ291bnQgLT0gMTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNldFRoZW1lLFxuICAgIGdldFRoZW1lLFxuICAgIGdldExhbmd1YWdlLFxuICAgIGdldExvYWRlZFRoZW1lcyxcbiAgICBnZXRMb2FkZWRMYW5ndWFnZXMsXG4gICAgbG9hZExhbmd1YWdlLFxuICAgIGxvYWRMYW5ndWFnZVN5bmMsXG4gICAgbG9hZFRoZW1lLFxuICAgIGxvYWRUaGVtZVN5bmMsXG4gICAgZGlzcG9zZSxcbiAgICBbU3ltYm9sLmRpc3Bvc2VdOiBkaXNwb3NlXG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVNoaWtpSW50ZXJuYWwob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5sb2FkV2FzbSkge1xuICAgIHdhcm5EZXByZWNhdGVkKFwiYGxvYWRXYXNtYCBvcHRpb24gaXMgZGVwcmVjYXRlZC4gVXNlIGBlbmdpbmU6IGNyZWF0ZU9uaWd1cnVtYUVuZ2luZShsb2FkV2FzbSlgIGluc3RlYWQuXCIpO1xuICB9XG4gIGlmICghb3B0aW9ucy5lbmdpbmUpIHtcbiAgICB3YXJuRGVwcmVjYXRlZChcImBlbmdpbmVgIG9wdGlvbiBpcyByZXF1aXJlZC4gVXNlIGBjcmVhdGVPbmlndXJ1bWFFbmdpbmVgIG9yIGBjcmVhdGVKYXZhU2NyaXB0UmVnZXhFbmdpbmVgIHRvIGNyZWF0ZSBhbiBlbmdpbmUuXCIpO1xuICB9XG4gIGNvbnN0IFtcbiAgICB0aGVtZXMsXG4gICAgbGFuZ3MsXG4gICAgZW5naW5lXG4gIF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgcmVzb2x2ZVRoZW1lcyhvcHRpb25zLnRoZW1lcyB8fCBbXSksXG4gICAgcmVzb2x2ZUxhbmdzKG9wdGlvbnMubGFuZ3MgfHwgW10pLFxuICAgIG9wdGlvbnMuZW5naW5lIHx8IGNyZWF0ZU9uaWd1cnVtYUVuZ2luZSQxKG9wdGlvbnMubG9hZFdhc20gfHwgZ2V0RGVmYXVsdFdhc21Mb2FkZXIoKSlcbiAgXSk7XG4gIHJldHVybiBjcmVhdGVTaGlraUludGVybmFsU3luYyh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICB0aGVtZXMsXG4gICAgbGFuZ3MsXG4gICAgZW5naW5lXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2hpa2lJbnRlcm5hbChvcHRpb25zKSB7XG4gIHdhcm5EZXByZWNhdGVkKFwiYGdldFNoaWtpSW50ZXJuYWxgIGlzIGRlcHJlY2F0ZWQuIFVzZSBgY3JlYXRlU2hpa2lJbnRlcm5hbGAgaW5zdGVhZC5cIik7XG4gIHJldHVybiBjcmVhdGVTaGlraUludGVybmFsKG9wdGlvbnMpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVIaWdobGlnaHRlckNvcmUob3B0aW9ucykge1xuICBjb25zdCBpbnRlcm5hbCA9IGF3YWl0IGNyZWF0ZVNoaWtpSW50ZXJuYWwob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgZ2V0TGFzdEdyYW1tYXJTdGF0ZTogKC4uLmFyZ3MpID0+IGdldExhc3RHcmFtbWFyU3RhdGUoaW50ZXJuYWwsIC4uLmFyZ3MpLFxuICAgIGNvZGVUb1Rva2Vuc0Jhc2U6IChjb2RlLCBvcHRpb25zMikgPT4gY29kZVRvVG9rZW5zQmFzZShpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIGNvZGVUb1Rva2Vuc1dpdGhUaGVtZXM6IChjb2RlLCBvcHRpb25zMikgPT4gY29kZVRvVG9rZW5zV2l0aFRoZW1lcyhpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIGNvZGVUb1Rva2VuczogKGNvZGUsIG9wdGlvbnMyKSA9PiBjb2RlVG9Ub2tlbnMoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICBjb2RlVG9IYXN0OiAoY29kZSwgb3B0aW9uczIpID0+IGNvZGVUb0hhc3QoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICBjb2RlVG9IdG1sOiAoY29kZSwgb3B0aW9uczIpID0+IGNvZGVUb0h0bWwoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICBnZXRCdW5kbGVkTGFuZ3VhZ2VzOiAoKSA9PiAoe30pLFxuICAgIGdldEJ1bmRsZWRUaGVtZXM6ICgpID0+ICh7fSksXG4gICAgLi4uaW50ZXJuYWwsXG4gICAgZ2V0SW50ZXJuYWxDb250ZXh0OiAoKSA9PiBpbnRlcm5hbFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSGlnaGxpZ2h0ZXJDb3JlU3luYyhvcHRpb25zKSB7XG4gIGNvbnN0IGludGVybmFsID0gY3JlYXRlU2hpa2lJbnRlcm5hbFN5bmMob3B0aW9ucyk7XG4gIHJldHVybiB7XG4gICAgZ2V0TGFzdEdyYW1tYXJTdGF0ZTogKC4uLmFyZ3MpID0+IGdldExhc3RHcmFtbWFyU3RhdGUoaW50ZXJuYWwsIC4uLmFyZ3MpLFxuICAgIGNvZGVUb1Rva2Vuc0Jhc2U6IChjb2RlLCBvcHRpb25zMikgPT4gY29kZVRvVG9rZW5zQmFzZShpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIGNvZGVUb1Rva2Vuc1dpdGhUaGVtZXM6IChjb2RlLCBvcHRpb25zMikgPT4gY29kZVRvVG9rZW5zV2l0aFRoZW1lcyhpbnRlcm5hbCwgY29kZSwgb3B0aW9uczIpLFxuICAgIGNvZGVUb1Rva2VuczogKGNvZGUsIG9wdGlvbnMyKSA9PiBjb2RlVG9Ub2tlbnMoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICBjb2RlVG9IYXN0OiAoY29kZSwgb3B0aW9uczIpID0+IGNvZGVUb0hhc3QoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICBjb2RlVG9IdG1sOiAoY29kZSwgb3B0aW9uczIpID0+IGNvZGVUb0h0bWwoaW50ZXJuYWwsIGNvZGUsIG9wdGlvbnMyKSxcbiAgICBnZXRCdW5kbGVkTGFuZ3VhZ2VzOiAoKSA9PiAoe30pLFxuICAgIGdldEJ1bmRsZWRUaGVtZXM6ICgpID0+ICh7fSksXG4gICAgLi4uaW50ZXJuYWwsXG4gICAgZ2V0SW50ZXJuYWxDb250ZXh0OiAoKSA9PiBpbnRlcm5hbFxuICB9O1xufVxuZnVuY3Rpb24gbWFrZVNpbmdsZXRvbkhpZ2hsaWdodGVyQ29yZShjcmVhdGVIaWdobGlnaHRlcikge1xuICBsZXQgX3NoaWtpO1xuICBhc3luYyBmdW5jdGlvbiBnZXRTaW5nbGV0b25IaWdobGlnaHRlckNvcmUyKG9wdGlvbnMpIHtcbiAgICBpZiAoIV9zaGlraSkge1xuICAgICAgX3NoaWtpID0gY3JlYXRlSGlnaGxpZ2h0ZXIoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB0aGVtZXM6IG9wdGlvbnMudGhlbWVzIHx8IFtdLFxuICAgICAgICBsYW5nczogb3B0aW9ucy5sYW5ncyB8fCBbXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gX3NoaWtpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzID0gYXdhaXQgX3NoaWtpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBzLmxvYWRUaGVtZSguLi5vcHRpb25zLnRoZW1lcyB8fCBbXSksXG4gICAgICAgIHMubG9hZExhbmd1YWdlKC4uLm9wdGlvbnMubGFuZ3MgfHwgW10pXG4gICAgICBdKTtcbiAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXJDb3JlMjtcbn1cbmNvbnN0IGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyQ29yZSA9IC8qIEBfX1BVUkVfXyAqLyBtYWtlU2luZ2xldG9uSGlnaGxpZ2h0ZXJDb3JlKGNyZWF0ZUhpZ2hsaWdodGVyQ29yZSk7XG5mdW5jdGlvbiBnZXRIaWdobGlnaHRlckNvcmUob3B0aW9ucykge1xuICB3YXJuRGVwcmVjYXRlZChcImBnZXRIaWdobGlnaHRlckNvcmVgIGlzIGRlcHJlY2F0ZWQuIFVzZSBgY3JlYXRlSGlnaGxpZ2h0ZXJDb3JlYCBvciBgZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXJDb3JlYCBpbnN0ZWFkLlwiKTtcbiAgcmV0dXJuIGNyZWF0ZUhpZ2hsaWdodGVyQ29yZShvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlZEJ1bmRsZWRIaWdobGlnaHRlcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGxldCBidW5kbGVkTGFuZ3VhZ2VzO1xuICBsZXQgYnVuZGxlZFRoZW1lcztcbiAgbGV0IGVuZ2luZTtcbiAgaWYgKGFyZzIpIHtcbiAgICB3YXJuRGVwcmVjYXRlZChcImBjcmVhdGVkQnVuZGxlZEhpZ2hsaWdodGVyYCBzaWduYXR1cmUgd2l0aCBgYnVuZGxlZExhbmd1YWdlc2AgYW5kIGBidW5kbGVkVGhlbWVzYCBpcyBkZXByZWNhdGVkLiBVc2UgdGhlIG9wdGlvbnMgb2JqZWN0IHNpZ25hdHVyZSBpbnN0ZWFkLlwiKTtcbiAgICBidW5kbGVkTGFuZ3VhZ2VzID0gYXJnMTtcbiAgICBidW5kbGVkVGhlbWVzID0gYXJnMjtcbiAgICBlbmdpbmUgPSAoKSA9PiBjcmVhdGVPbmlndXJ1bWFFbmdpbmUoYXJnMyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGFyZzE7XG4gICAgYnVuZGxlZExhbmd1YWdlcyA9IG9wdGlvbnMubGFuZ3M7XG4gICAgYnVuZGxlZFRoZW1lcyA9IG9wdGlvbnMudGhlbWVzO1xuICAgIGVuZ2luZSA9IG9wdGlvbnMuZW5naW5lO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUhpZ2hsaWdodGVyKG9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiByZXNvbHZlTGFuZyhsYW5nKSB7XG4gICAgICBpZiAodHlwZW9mIGxhbmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGlzU3BlY2lhbExhbmcobGFuZykpXG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBjb25zdCBidW5kbGUgPSBidW5kbGVkTGFuZ3VhZ2VzW2xhbmddO1xuICAgICAgICBpZiAoIWJ1bmRsZSlcbiAgICAgICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKGBMYW5ndWFnZSBcXGAke2xhbmd9XFxgIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGJ1bmRsZS4gWW91IG1heSB3YW50IHRvIGxvYWQgaXQgZnJvbSBleHRlcm5hbCBzb3VyY2UuYCk7XG4gICAgICAgIHJldHVybiBidW5kbGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFuZztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZVRoZW1lKHRoZW1lKSB7XG4gICAgICBpZiAoaXNTcGVjaWFsVGhlbWUodGhlbWUpKVxuICAgICAgICByZXR1cm4gXCJub25lXCI7XG4gICAgICBpZiAodHlwZW9mIHRoZW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGJ1bmRsZSA9IGJ1bmRsZWRUaGVtZXNbdGhlbWVdO1xuICAgICAgICBpZiAoIWJ1bmRsZSlcbiAgICAgICAgICB0aHJvdyBuZXcgU2hpa2lFcnJvciQxKGBUaGVtZSBcXGAke3RoZW1lfVxcYCBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBidW5kbGUuIFlvdSBtYXkgd2FudCB0byBsb2FkIGl0IGZyb20gZXh0ZXJuYWwgc291cmNlLmApO1xuICAgICAgICByZXR1cm4gYnVuZGxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoZW1lO1xuICAgIH1cbiAgICBjb25zdCBfdGhlbWVzID0gKG9wdGlvbnMudGhlbWVzID8/IFtdKS5tYXAoKGkpID0+IHJlc29sdmVUaGVtZShpKSk7XG4gICAgY29uc3QgbGFuZ3MgPSAob3B0aW9ucy5sYW5ncyA/PyBbXSkubWFwKChpKSA9PiByZXNvbHZlTGFuZyhpKSk7XG4gICAgY29uc3QgY29yZSA9IGF3YWl0IGNyZWF0ZUhpZ2hsaWdodGVyQ29yZSh7XG4gICAgICBlbmdpbmU6IG9wdGlvbnMuZW5naW5lID8/IGVuZ2luZSgpLFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHRoZW1lczogX3RoZW1lcyxcbiAgICAgIGxhbmdzXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvcmUsXG4gICAgICBsb2FkTGFuZ3VhZ2UoLi4ubGFuZ3MyKSB7XG4gICAgICAgIHJldHVybiBjb3JlLmxvYWRMYW5ndWFnZSguLi5sYW5nczIubWFwKHJlc29sdmVMYW5nKSk7XG4gICAgICB9LFxuICAgICAgbG9hZFRoZW1lKC4uLnRoZW1lcykge1xuICAgICAgICByZXR1cm4gY29yZS5sb2FkVGhlbWUoLi4udGhlbWVzLm1hcChyZXNvbHZlVGhlbWUpKTtcbiAgICAgIH0sXG4gICAgICBnZXRCdW5kbGVkTGFuZ3VhZ2VzKCkge1xuICAgICAgICByZXR1cm4gYnVuZGxlZExhbmd1YWdlcztcbiAgICAgIH0sXG4gICAgICBnZXRCdW5kbGVkVGhlbWVzKCkge1xuICAgICAgICByZXR1cm4gYnVuZGxlZFRoZW1lcztcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBjcmVhdGVIaWdobGlnaHRlcjtcbn1cbmZ1bmN0aW9uIG1ha2VTaW5nbGV0b25IaWdobGlnaHRlcihjcmVhdGVIaWdobGlnaHRlcikge1xuICBsZXQgX3NoaWtpO1xuICBhc3luYyBmdW5jdGlvbiBnZXRTaW5nbGV0b25IaWdobGlnaHRlcihvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIV9zaGlraSkge1xuICAgICAgX3NoaWtpID0gY3JlYXRlSGlnaGxpZ2h0ZXIoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB0aGVtZXM6IG9wdGlvbnMudGhlbWVzIHx8IFtdLFxuICAgICAgICBsYW5nczogb3B0aW9ucy5sYW5ncyB8fCBbXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gX3NoaWtpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzID0gYXdhaXQgX3NoaWtpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBzLmxvYWRUaGVtZSguLi5vcHRpb25zLnRoZW1lcyB8fCBbXSksXG4gICAgICAgIHMubG9hZExhbmd1YWdlKC4uLm9wdGlvbnMubGFuZ3MgfHwgW10pXG4gICAgICBdKTtcbiAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVTaW5nbGV0b25TaG9ydGhhbmRzKGNyZWF0ZUhpZ2hsaWdodGVyLCBjb25maWcpIHtcbiAgY29uc3QgZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXIgPSBtYWtlU2luZ2xldG9uSGlnaGxpZ2h0ZXIoY3JlYXRlSGlnaGxpZ2h0ZXIpO1xuICBhc3luYyBmdW5jdGlvbiBnZXQoY29kZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHNoaWtpID0gYXdhaXQgZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXIoe1xuICAgICAgbGFuZ3M6IFtvcHRpb25zLmxhbmddLFxuICAgICAgdGhlbWVzOiBcInRoZW1lXCIgaW4gb3B0aW9ucyA/IFtvcHRpb25zLnRoZW1lXSA6IE9iamVjdC52YWx1ZXMob3B0aW9ucy50aGVtZXMpXG4gICAgfSk7XG4gICAgY29uc3QgbGFuZ3MgPSBhd2FpdCBjb25maWc/Lmd1ZXNzRW1iZWRkZWRMYW5ndWFnZXM/Lihjb2RlLCBvcHRpb25zLmxhbmcsIHNoaWtpKTtcbiAgICBpZiAobGFuZ3MpIHtcbiAgICAgIGF3YWl0IHNoaWtpLmxvYWRMYW5ndWFnZSguLi5sYW5ncyk7XG4gICAgfVxuICAgIHJldHVybiBzaGlraTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBnZXRTaW5nbGV0b25IaWdobGlnaHRlcihvcHRpb25zKTtcbiAgICB9LFxuICAgIGFzeW5jIGNvZGVUb0h0bWwoY29kZSwgb3B0aW9ucykge1xuICAgICAgY29uc3Qgc2hpa2kgPSBhd2FpdCBnZXQoY29kZSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gc2hpa2kuY29kZVRvSHRtbChjb2RlLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGFzeW5jIGNvZGVUb0hhc3QoY29kZSwgb3B0aW9ucykge1xuICAgICAgY29uc3Qgc2hpa2kgPSBhd2FpdCBnZXQoY29kZSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gc2hpa2kuY29kZVRvSGFzdChjb2RlLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGFzeW5jIGNvZGVUb1Rva2Vucyhjb2RlLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCBzaGlraSA9IGF3YWl0IGdldChjb2RlLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBzaGlraS5jb2RlVG9Ub2tlbnMoY29kZSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBhc3luYyBjb2RlVG9Ub2tlbnNCYXNlKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHNoaWtpID0gYXdhaXQgZ2V0KGNvZGUsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHNoaWtpLmNvZGVUb1Rva2Vuc0Jhc2UoY29kZSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBhc3luYyBjb2RlVG9Ub2tlbnNXaXRoVGhlbWVzKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHNoaWtpID0gYXdhaXQgZ2V0KGNvZGUsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHNoaWtpLmNvZGVUb1Rva2Vuc1dpdGhUaGVtZXMoY29kZSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBhc3luYyBnZXRMYXN0R3JhbW1hclN0YXRlKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHNoaWtpID0gYXdhaXQgZ2V0U2luZ2xldG9uSGlnaGxpZ2h0ZXIoe1xuICAgICAgICBsYW5nczogW29wdGlvbnMubGFuZ10sXG4gICAgICAgIHRoZW1lczogW29wdGlvbnMudGhlbWVdXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzaGlraS5nZXRMYXN0R3JhbW1hclN0YXRlKGNvZGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSmF2YVNjcmlwdFJlZ2V4RW5naW5lKG9wdGlvbnMpIHtcbiAgd2FybkRlcHJlY2F0ZWQoXCJpbXBvcnQgYGNyZWF0ZUphdmFTY3JpcHRSZWdleEVuZ2luZWAgZnJvbSBgQHNoaWtpanMvZW5naW5lLWphdmFzY3JpcHRgIG9yIGBzaGlraS9lbmdpbmUvamF2YXNjcmlwdGAgaW5zdGVhZFwiKTtcbiAgcmV0dXJuIGNyZWF0ZUphdmFTY3JpcHRSZWdleEVuZ2luZSQxKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZGVmYXVsdEphdmFTY3JpcHRSZWdleENvbnN0cnVjdG9yKHBhdHRlcm4pIHtcbiAgd2FybkRlcHJlY2F0ZWQoXCJpbXBvcnQgYGRlZmF1bHRKYXZhU2NyaXB0UmVnZXhDb25zdHJ1Y3RvcmAgZnJvbSBgQHNoaWtpanMvZW5naW5lLWphdmFzY3JpcHRgIG9yIGBzaGlraS9lbmdpbmUvamF2YXNjcmlwdGAgaW5zdGVhZFwiKTtcbiAgcmV0dXJuIGRlZmF1bHRKYXZhU2NyaXB0UmVnZXhDb25zdHJ1Y3RvciQxKHBhdHRlcm4pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDc3NWYXJpYWJsZXNUaGVtZShvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIG5hbWUgPSBcImNzcy12YXJpYWJsZXNcIixcbiAgICB2YXJpYWJsZVByZWZpeCA9IFwiLS1zaGlraS1cIixcbiAgICBmb250U3R5bGUgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCB2YXJpYWJsZSA9IChuYW1lMikgPT4ge1xuICAgIGlmIChvcHRpb25zLnZhcmlhYmxlRGVmYXVsdHM/LltuYW1lMl0pXG4gICAgICByZXR1cm4gYHZhcigke3ZhcmlhYmxlUHJlZml4fSR7bmFtZTJ9LCAke29wdGlvbnMudmFyaWFibGVEZWZhdWx0c1tuYW1lMl19KWA7XG4gICAgcmV0dXJuIGB2YXIoJHt2YXJpYWJsZVByZWZpeH0ke25hbWUyfSlgO1xuICB9O1xuICBjb25zdCB0aGVtZSA9IHtcbiAgICBuYW1lLFxuICAgIHR5cGU6IFwiZGFya1wiLFxuICAgIGNvbG9yczoge1xuICAgICAgXCJlZGl0b3IuZm9yZWdyb3VuZFwiOiB2YXJpYWJsZShcImZvcmVncm91bmRcIiksXG4gICAgICBcImVkaXRvci5iYWNrZ3JvdW5kXCI6IHZhcmlhYmxlKFwiYmFja2dyb3VuZFwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJsYWNrXCI6IHZhcmlhYmxlKFwiYW5zaS1ibGFja1wiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaVJlZFwiOiB2YXJpYWJsZShcImFuc2ktcmVkXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpR3JlZW5cIjogdmFyaWFibGUoXCJhbnNpLWdyZWVuXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpWWVsbG93XCI6IHZhcmlhYmxlKFwiYW5zaS15ZWxsb3dcIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lCbHVlXCI6IHZhcmlhYmxlKFwiYW5zaS1ibHVlXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpTWFnZW50YVwiOiB2YXJpYWJsZShcImFuc2ktbWFnZW50YVwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUN5YW5cIjogdmFyaWFibGUoXCJhbnNpLWN5YW5cIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lXaGl0ZVwiOiB2YXJpYWJsZShcImFuc2ktd2hpdGVcIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lCcmlnaHRCbGFja1wiOiB2YXJpYWJsZShcImFuc2ktYnJpZ2h0LWJsYWNrXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpQnJpZ2h0UmVkXCI6IHZhcmlhYmxlKFwiYW5zaS1icmlnaHQtcmVkXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpQnJpZ2h0R3JlZW5cIjogdmFyaWFibGUoXCJhbnNpLWJyaWdodC1ncmVlblwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJyaWdodFllbGxvd1wiOiB2YXJpYWJsZShcImFuc2ktYnJpZ2h0LXllbGxvd1wiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJyaWdodEJsdWVcIjogdmFyaWFibGUoXCJhbnNpLWJyaWdodC1ibHVlXCIpLFxuICAgICAgXCJ0ZXJtaW5hbC5hbnNpQnJpZ2h0TWFnZW50YVwiOiB2YXJpYWJsZShcImFuc2ktYnJpZ2h0LW1hZ2VudGFcIiksXG4gICAgICBcInRlcm1pbmFsLmFuc2lCcmlnaHRDeWFuXCI6IHZhcmlhYmxlKFwiYW5zaS1icmlnaHQtY3lhblwiKSxcbiAgICAgIFwidGVybWluYWwuYW5zaUJyaWdodFdoaXRlXCI6IHZhcmlhYmxlKFwiYW5zaS1icmlnaHQtd2hpdGVcIilcbiAgICB9LFxuICAgIHRva2VuQ29sb3JzOiBbXG4gICAgICB7XG4gICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgXCJrZXl3b3JkLm9wZXJhdG9yLmFjY2Vzc29yXCIsXG4gICAgICAgICAgXCJtZXRhLmdyb3VwLmJyYWNlcy5yb3VuZC5mdW5jdGlvbi5hcmd1bWVudHNcIixcbiAgICAgICAgICBcIm1ldGEudGVtcGxhdGUuZXhwcmVzc2lvblwiLFxuICAgICAgICAgIFwibWFya3VwLmZlbmNlZF9jb2RlIG1ldGEuZW1iZWRkZWQuYmxvY2tcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwiZm9yZWdyb3VuZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogXCJlbXBoYXNpc1wiLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1wic3Ryb25nXCIsIFwibWFya3VwLmhlYWRpbmcubWFya2Rvd25cIiwgXCJtYXJrdXAuYm9sZC5tYXJrZG93blwiXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb250U3R5bGU6IFwiYm9sZFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHNjb3BlOiBbXCJtYXJrdXAuaXRhbGljLm1hcmtkb3duXCJdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogXCJtZXRhLmxpbmsuaW5saW5lLm1hcmtkb3duXCIsXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9udFN0eWxlOiBcInVuZGVybGluZVwiLFxuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tbGlua1wiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1wic3RyaW5nXCIsIFwibWFya3VwLmZlbmNlZF9jb2RlXCIsIFwibWFya3VwLmlubGluZVwiXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLXN0cmluZ1wiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1wiY29tbWVudFwiLCBcInN0cmluZy5xdW90ZWQuZG9jc3RyaW5nLm11bHRpXCJdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tY29tbWVudFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwiY29uc3RhbnQubnVtZXJpY1wiLFxuICAgICAgICAgIFwiY29uc3RhbnQubGFuZ3VhZ2VcIixcbiAgICAgICAgICBcImNvbnN0YW50Lm90aGVyLnBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgXCJjb25zdGFudC5jaGFyYWN0ZXIuZm9ybWF0LnBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgXCJ2YXJpYWJsZS5sYW5ndWFnZS50aGlzXCIsXG4gICAgICAgICAgXCJ2YXJpYWJsZS5vdGhlci5vYmplY3RcIixcbiAgICAgICAgICBcInZhcmlhYmxlLm90aGVyLmNsYXNzXCIsXG4gICAgICAgICAgXCJ2YXJpYWJsZS5vdGhlci5jb25zdGFudFwiLFxuICAgICAgICAgIFwibWV0YS5wcm9wZXJ0eS1uYW1lXCIsXG4gICAgICAgICAgXCJtZXRhLnByb3BlcnR5LXZhbHVlXCIsXG4gICAgICAgICAgXCJzdXBwb3J0XCJcbiAgICAgICAgXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLWNvbnN0YW50XCIpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgXCJrZXl3b3JkXCIsXG4gICAgICAgICAgXCJzdG9yYWdlLm1vZGlmaWVyXCIsXG4gICAgICAgICAgXCJzdG9yYWdlLnR5cGVcIixcbiAgICAgICAgICBcInN0b3JhZ2UuY29udHJvbC5jbG9qdXJlXCIsXG4gICAgICAgICAgXCJlbnRpdHkubmFtZS5mdW5jdGlvbi5jbG9qdXJlXCIsXG4gICAgICAgICAgXCJlbnRpdHkubmFtZS50YWcueWFtbFwiLFxuICAgICAgICAgIFwic3VwcG9ydC5mdW5jdGlvbi5ub2RlXCIsXG4gICAgICAgICAgXCJzdXBwb3J0LnR5cGUucHJvcGVydHktbmFtZS5qc29uXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5zZXBhcmF0b3Iua2V5LXZhbHVlXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLnRlbXBsYXRlLWV4cHJlc3Npb25cIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4ta2V5d29yZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogXCJ2YXJpYWJsZS5wYXJhbWV0ZXIuZnVuY3Rpb25cIixcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLXBhcmFtZXRlclwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwic3VwcG9ydC5mdW5jdGlvblwiLFxuICAgICAgICAgIFwiZW50aXR5Lm5hbWUudHlwZVwiLFxuICAgICAgICAgIFwiZW50aXR5Lm90aGVyLmluaGVyaXRlZC1jbGFzc1wiLFxuICAgICAgICAgIFwibWV0YS5mdW5jdGlvbi1jYWxsXCIsXG4gICAgICAgICAgXCJtZXRhLmluc3RhbmNlLmNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgXCJlbnRpdHkub3RoZXIuYXR0cmlidXRlLW5hbWVcIixcbiAgICAgICAgICBcImVudGl0eS5uYW1lLmZ1bmN0aW9uXCIsXG4gICAgICAgICAgXCJjb25zdGFudC5rZXl3b3JkLmNsb2p1cmVcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tZnVuY3Rpb25cIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2NvcGU6IFtcbiAgICAgICAgICBcImVudGl0eS5uYW1lLnRhZ1wiLFxuICAgICAgICAgIFwic3RyaW5nLnF1b3RlZFwiLFxuICAgICAgICAgIFwic3RyaW5nLnJlZ2V4cFwiLFxuICAgICAgICAgIFwic3RyaW5nLmludGVycG9sYXRlZFwiLFxuICAgICAgICAgIFwic3RyaW5nLnRlbXBsYXRlXCIsXG4gICAgICAgICAgXCJzdHJpbmcudW5xdW90ZWQucGxhaW4ub3V0LnlhbWxcIixcbiAgICAgICAgICBcImtleXdvcmQub3RoZXIudGVtcGxhdGVcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tc3RyaW5nLWV4cHJlc3Npb25cIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgc2NvcGU6IFtcbiAgICAgICAgICBcInB1bmN0dWF0aW9uLmRlZmluaXRpb24uYXJndW1lbnRzXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLmRpY3RcIixcbiAgICAgICAgICBcInB1bmN0dWF0aW9uLnNlcGFyYXRvclwiLFxuICAgICAgICAgIFwibWV0YS5mdW5jdGlvbi1jYWxsLmFyZ3VtZW50c1wiXG4gICAgICAgIF0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9yZWdyb3VuZDogdmFyaWFibGUoXCJ0b2tlbi1wdW5jdHVhdGlvblwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBbQ3VzdG9tXSBNYXJrZG93biBsaW5rc1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwibWFya3VwLnVuZGVybGluZS5saW5rXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLm1ldGFkYXRhLm1hcmtkb3duXCJcbiAgICAgICAgXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLWxpbmtcIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gW0N1c3RvbV0gTWFya2Rvd24gbGlzdFxuICAgICAgICBzY29wZTogW1wiYmVnaW5uaW5nLnB1bmN0dWF0aW9uLmRlZmluaXRpb24ubGlzdC5tYXJrZG93blwiXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBmb3JlZ3JvdW5kOiB2YXJpYWJsZShcInRva2VuLXN0cmluZ1wiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBbQ3VzdG9tXSBNYXJrZG93biBwdW5jdHVhdGlvbiBkZWZpbml0aW9uIGJyYWNrZXRzXG4gICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLnN0cmluZy5iZWdpbi5tYXJrZG93blwiLFxuICAgICAgICAgIFwicHVuY3R1YXRpb24uZGVmaW5pdGlvbi5zdHJpbmcuZW5kLm1hcmtkb3duXCIsXG4gICAgICAgICAgXCJzdHJpbmcub3RoZXIubGluay50aXRsZS5tYXJrZG93blwiLFxuICAgICAgICAgIFwic3RyaW5nLm90aGVyLmxpbmsuZGVzY3JpcHRpb24ubWFya2Rvd25cIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4ta2V5d29yZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBbQ3VzdG9tXSBEaWZmXG4gICAgICAgIHNjb3BlOiBbXG4gICAgICAgICAgXCJtYXJrdXAuaW5zZXJ0ZWRcIixcbiAgICAgICAgICBcIm1ldGEuZGlmZi5oZWFkZXIudG8tZmlsZVwiLFxuICAgICAgICAgIFwicHVuY3R1YXRpb24uZGVmaW5pdGlvbi5pbnNlcnRlZFwiXG4gICAgICAgIF0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9yZWdyb3VuZDogdmFyaWFibGUoXCJ0b2tlbi1pbnNlcnRlZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwibWFya3VwLmRlbGV0ZWRcIixcbiAgICAgICAgICBcIm1ldGEuZGlmZi5oZWFkZXIuZnJvbS1maWxlXCIsXG4gICAgICAgICAgXCJwdW5jdHVhdGlvbi5kZWZpbml0aW9uLmRlbGV0ZWRcIlxuICAgICAgICBdLFxuICAgICAgICBzZXR0aW5nczoge1xuICAgICAgICAgIGZvcmVncm91bmQ6IHZhcmlhYmxlKFwidG9rZW4tZGVsZXRlZFwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzY29wZTogW1xuICAgICAgICAgIFwibWFya3VwLmNoYW5nZWRcIixcbiAgICAgICAgICBcInB1bmN0dWF0aW9uLmRlZmluaXRpb24uY2hhbmdlZFwiXG4gICAgICAgIF0sXG4gICAgICAgIHNldHRpbmdzOiB7XG4gICAgICAgICAgZm9yZWdyb3VuZDogdmFyaWFibGUoXCJ0b2tlbi1jaGFuZ2VkXCIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH07XG4gIGlmICghZm9udFN0eWxlKSB7XG4gICAgdGhlbWUudG9rZW5Db2xvcnMgPSB0aGVtZS50b2tlbkNvbG9ycz8ubWFwKCh0b2tlbkNvbG9yKSA9PiB7XG4gICAgICBpZiAodG9rZW5Db2xvci5zZXR0aW5ncz8uZm9udFN0eWxlKVxuICAgICAgICBkZWxldGUgdG9rZW5Db2xvci5zZXR0aW5ncy5mb250U3R5bGU7XG4gICAgICByZXR1cm4gdG9rZW5Db2xvcjtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhlbWU7XG59XG5cbmV4cG9ydCB7IGFkZENsYXNzVG9IYXN0LCBhcHBseUNvbG9yUmVwbGFjZW1lbnRzLCBjb2RlVG9IYXN0LCBjb2RlVG9IdG1sLCBjb2RlVG9Ub2tlbnMsIGNvZGVUb1Rva2Vuc0Jhc2UsIGNvZGVUb1Rva2Vuc1dpdGhUaGVtZXMsIGNyZWF0ZUNzc1ZhcmlhYmxlc1RoZW1lLCBjcmVhdGVIaWdobGlnaHRlckNvcmUsIGNyZWF0ZUhpZ2hsaWdodGVyQ29yZVN5bmMsIGNyZWF0ZUphdmFTY3JpcHRSZWdleEVuZ2luZSwgY3JlYXRlT25pZ3VydW1hRW5naW5lLCBjcmVhdGVQb3NpdGlvbkNvbnZlcnRlciwgY3JlYXRlU2hpa2lJbnRlcm5hbCwgY3JlYXRlU2hpa2lJbnRlcm5hbFN5bmMsIGNyZWF0ZVNpbmdsZXRvblNob3J0aGFuZHMsIGNyZWF0ZVdhc21PbmlnRW5naW5lLCBjcmVhdGVkQnVuZGxlZEhpZ2hsaWdodGVyLCBkZWZhdWx0SmF2YVNjcmlwdFJlZ2V4Q29uc3RydWN0b3IsIGZsYXRUb2tlblZhcmlhbnRzLCBnZXRIaWdobGlnaHRlckNvcmUsIGdldFNoaWtpSW50ZXJuYWwsIGdldFNpbmdsZXRvbkhpZ2hsaWdodGVyQ29yZSwgZ2V0VG9rZW5TdHlsZU9iamVjdCwgZ3Vlc3NFbWJlZGRlZExhbmd1YWdlcywgaXNOb25lVGhlbWUsIGlzUGxhaW5MYW5nLCBpc1NwZWNpYWxMYW5nLCBpc1NwZWNpYWxUaGVtZSwgbG9hZFdhc20sIG1ha2VTaW5nbGV0b25IaWdobGlnaHRlciwgbWFrZVNpbmdsZXRvbkhpZ2hsaWdodGVyQ29yZSwgbm9ybWFsaXplR2V0dGVyLCBub3JtYWxpemVUaGVtZSwgcmVzb2x2ZUNvbG9yUmVwbGFjZW1lbnRzLCBzcGxpdExpbmVzLCBzcGxpdFRva2VuLCBzcGxpdFRva2Vucywgc3RyaW5naWZ5VG9rZW5TdHlsZSwgdG9BcnJheSwgdG9rZW5pemVBbnNpV2l0aFRoZW1lLCB0b2tlbml6ZVdpdGhUaGVtZSwgdG9rZW5zVG9IYXN0LCB0cmFuc2Zvcm1lckRlY29yYXRpb25zLCB3YXJuRGVwcmVjYXRlZCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@shikijs+core@2.5.0/node_modules/@shikijs/core/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@shikijs+core@2.5.0/node_modules/@shikijs/core/dist/shared/core.5hv0Law9.mjs":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@shikijs+core@2.5.0/node_modules/@shikijs/core/dist/shared/core.5hv0Law9.mjs ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   e: () => (/* binding */ enableDeprecationWarnings),\n/* harmony export */   w: () => (/* binding */ warnDeprecated)\n/* harmony export */ });\nlet _emitDeprecation = 3;\nlet _emitError = false;\nfunction enableDeprecationWarnings(emitDeprecation = true, emitError = false) {\n  _emitDeprecation = emitDeprecation;\n  _emitError = emitError;\n}\nfunction warnDeprecated(message, version = 3) {\n  if (!_emitDeprecation)\n    return;\n  if (typeof _emitDeprecation === \"number\" && version > _emitDeprecation)\n    return;\n  if (_emitError) {\n    throw new Error(`[SHIKI DEPRECATE]: ${message}`);\n  } else {\n    console.trace(`[SHIKI DEPRECATE]: ${message}`);\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNoaWtpanMrY29yZUAyLjUuMC9ub2RlX21vZHVsZXMvQHNoaWtpanMvY29yZS9kaXN0L3NoYXJlZC9jb3JlLjVodjBMYXc5Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xELElBQUk7QUFDSix3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBOztBQUUrRCIsInNvdXJjZXMiOlsiL2hvbWUvYnJvbnplL2NvZGluZy9mc2FrbS9ub2RlX21vZHVsZXMvLnBucG0vQHNoaWtpanMrY29yZUAyLjUuMC9ub2RlX21vZHVsZXMvQHNoaWtpanMvY29yZS9kaXN0L3NoYXJlZC9jb3JlLjVodjBMYXc5Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgX2VtaXREZXByZWNhdGlvbiA9IDM7XG5sZXQgX2VtaXRFcnJvciA9IGZhbHNlO1xuZnVuY3Rpb24gZW5hYmxlRGVwcmVjYXRpb25XYXJuaW5ncyhlbWl0RGVwcmVjYXRpb24gPSB0cnVlLCBlbWl0RXJyb3IgPSBmYWxzZSkge1xuICBfZW1pdERlcHJlY2F0aW9uID0gZW1pdERlcHJlY2F0aW9uO1xuICBfZW1pdEVycm9yID0gZW1pdEVycm9yO1xufVxuZnVuY3Rpb24gd2FybkRlcHJlY2F0ZWQobWVzc2FnZSwgdmVyc2lvbiA9IDMpIHtcbiAgaWYgKCFfZW1pdERlcHJlY2F0aW9uKVxuICAgIHJldHVybjtcbiAgaWYgKHR5cGVvZiBfZW1pdERlcHJlY2F0aW9uID09PSBcIm51bWJlclwiICYmIHZlcnNpb24gPiBfZW1pdERlcHJlY2F0aW9uKVxuICAgIHJldHVybjtcbiAgaWYgKF9lbWl0RXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFtTSElLSSBERVBSRUNBVEVdOiAke21lc3NhZ2V9YCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS50cmFjZShgW1NISUtJIERFUFJFQ0FURV06ICR7bWVzc2FnZX1gKTtcbiAgfVxufVxuXG5leHBvcnQgeyBlbmFibGVEZXByZWNhdGlvbldhcm5pbmdzIGFzIGUsIHdhcm5EZXByZWNhdGVkIGFzIHcgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@shikijs+core@2.5.0/node_modules/@shikijs/core/dist/shared/core.5hv0Law9.mjs\n");

/***/ })

};
;