"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/oniguruma-to-es@3.1.1";
exports.ids = ["vendor-chunks/oniguruma-to-es@3.1.1"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/oniguruma-to-es@3.1.1/node_modules/oniguruma-to-es/dist/esm/index.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/oniguruma-to-es@3.1.1/node_modules/oniguruma-to-es/dist/esm/index.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EmulatedRegExp: () => (/* binding */ EmulatedRegExp),\n/* harmony export */   toOnigurumaAst: () => (/* binding */ toOnigurumaAst),\n/* harmony export */   toRegExp: () => (/* binding */ toRegExp),\n/* harmony export */   toRegExpDetails: () => (/* binding */ toRegExpDetails)\n/* harmony export */ });\n/* harmony import */ var emoji_regex_xs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! emoji-regex-xs */ \"(rsc)/./node_modules/.pnpm/emoji-regex-xs@1.0.0/node_modules/emoji-regex-xs/index.mjs\");\n/* harmony import */ var regex_internals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! regex/internals */ \"(rsc)/./node_modules/.pnpm/regex@6.0.1/node_modules/regex/src/internals.js\");\n/* harmony import */ var regex_recursion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! regex-recursion */ \"(rsc)/./node_modules/.pnpm/regex-recursion@6.0.2/node_modules/regex-recursion/src/index.js\");\n// src/utils.js\nvar cp = String.fromCodePoint;\nvar r = String.raw;\nvar envFlags = {\n  flagGroups: (() => {\n    try {\n      new RegExp(\"(?i:)\");\n    } catch {\n      return false;\n    }\n    return true;\n  })(),\n  unicodeSets: (() => {\n    try {\n      new RegExp(\"\", \"v\");\n    } catch {\n      return false;\n    }\n    return true;\n  })()\n};\nenvFlags.literalHyphenIncorrectlyCreatesRange = (() => {\n  if (!envFlags.unicodeSets) {\n    return false;\n  }\n  try {\n    new RegExp(r`[\\d\\-a]`, \"v\");\n  } catch {\n    return true;\n  }\n  return false;\n})();\nfunction getNewCurrentFlags(current, { enable, disable }) {\n  return {\n    dotAll: !disable?.dotAll && !!(enable?.dotAll || current.dotAll),\n    ignoreCase: !disable?.ignoreCase && !!(enable?.ignoreCase || current.ignoreCase)\n  };\n}\nfunction getOrInsert(map, key, defaultValue) {\n  if (!map.has(key)) {\n    map.set(key, defaultValue);\n  }\n  return map.get(key);\n}\nfunction isMinTarget(target, min) {\n  return EsVersion[target] >= EsVersion[min];\n}\nfunction throwIfNot(value, msg) {\n  if (!value) {\n    throw new Error(msg ?? \"Value expected\");\n  }\n  return value;\n}\n\n// src/options.js\nvar EsVersion = {\n  ES2025: 2025,\n  ES2024: 2024,\n  ES2018: 2018\n};\nvar Target = (\n  /** @type {const} */\n  {\n    auto: \"auto\",\n    ES2025: \"ES2025\",\n    ES2024: \"ES2024\",\n    ES2018: \"ES2018\"\n  }\n);\nfunction getOptions(options) {\n  if (options?.target !== void 0 && !Target[options.target]) {\n    throw new Error(`Unexpected target \"${options.target}\"`);\n  }\n  const opts = {\n    // Sets the level of emulation rigor/strictness.\n    accuracy: \"default\",\n    // Disables advanced emulation that relies on returning a `RegExp` subclass, resulting in\n    // certain patterns not being emulatable.\n    avoidSubclass: false,\n    // Oniguruma flags; a string with `i`, `m`, `x`, `D`, `S`, `W` in any order (all optional).\n    // Oniguruma's `m` is equivalent to JavaScript's `s` (`dotAll`).\n    flags: \"\",\n    // Include JavaScript flag `g` (`global`) in the result.\n    global: false,\n    // Include JavaScript flag `d` (`hasIndices`) in the result.\n    hasIndices: false,\n    // Delay regex construction until first use if the transpiled pattern is at least this length.\n    lazyCompileLength: Infinity,\n    // JavaScript version used for generated regexes. Using `auto` detects the best value based on\n    // your environment. Later targets allow faster processing, simpler generated source, and\n    // support for additional features.\n    target: \"auto\",\n    // Disables optimizations that simplify the pattern when it doesn't change the meaning.\n    verbose: false,\n    ...options,\n    // Advanced options that override standard behavior, error checking, and flags when enabled.\n    rules: {\n      // Useful with TextMate grammars that merge backreferences across patterns.\n      allowOrphanBackrefs: false,\n      // Use ASCII-based `\\b` and `\\B`, which increases search performance of generated regexes.\n      asciiWordBoundaries: false,\n      // Allow unnamed captures and numbered calls (backreferences and subroutines) when using\n      // named capture. This is Oniguruma option `ONIG_OPTION_CAPTURE_GROUP`; on by default in\n      // `vscode-oniguruma`.\n      captureGroup: false,\n      // Change the recursion depth limit from Oniguruma's `20` to an integer `2`–`20`.\n      recursionLimit: 20,\n      // `^` as `\\A`; `$` as`\\Z`. Improves search performance of generated regexes without changing\n      // meaning if searching line by line. This is Oniguruma option `ONIG_OPTION_SINGLELINE`.\n      singleline: false,\n      ...options?.rules\n    }\n  };\n  if (opts.target === \"auto\") {\n    opts.target = envFlags.flagGroups ? \"ES2025\" : envFlags.unicodeSets ? \"ES2024\" : \"ES2018\";\n  }\n  return opts;\n}\n\n// src/unicode.js\nvar CharsWithoutIgnoreCaseExpansion = /* @__PURE__ */ new Set([\n  cp(304),\n  // İ\n  cp(305)\n  // ı\n]);\nfunction getIgnoreCaseMatchChars(char) {\n  if (CharsWithoutIgnoreCaseExpansion.has(char)) {\n    return [char];\n  }\n  const set = /* @__PURE__ */ new Set();\n  const lower = char.toLowerCase();\n  const upper = lower.toUpperCase();\n  const title = LowerToTitleCaseMap.get(lower);\n  const altLower = LowerToAlternativeLowerCaseMap.get(lower);\n  const altUpper = LowerToAlternativeUpperCaseMap.get(lower);\n  if ([...upper].length === 1) {\n    set.add(upper);\n  }\n  altUpper && set.add(altUpper);\n  title && set.add(title);\n  set.add(lower);\n  altLower && set.add(altLower);\n  return [...set];\n}\nvar JsUnicodeProperties = new Set(\n  `C Other\nCc Control cntrl\nCf Format\nCn Unassigned\nCo Private_Use\nCs Surrogate\nL Letter\nLC Cased_Letter\nLl Lowercase_Letter\nLm Modifier_Letter\nLo Other_Letter\nLt Titlecase_Letter\nLu Uppercase_Letter\nM Mark Combining_Mark\nMc Spacing_Mark\nMe Enclosing_Mark\nMn Nonspacing_Mark\nN Number\nNd Decimal_Number digit\nNl Letter_Number\nNo Other_Number\nP Punctuation punct\nPc Connector_Punctuation\nPd Dash_Punctuation\nPe Close_Punctuation\nPf Final_Punctuation\nPi Initial_Punctuation\nPo Other_Punctuation\nPs Open_Punctuation\nS Symbol\nSc Currency_Symbol\nSk Modifier_Symbol\nSm Math_Symbol\nSo Other_Symbol\nZ Separator\nZl Line_Separator\nZp Paragraph_Separator\nZs Space_Separator\nASCII\nASCII_Hex_Digit AHex\nAlphabetic Alpha\nAny\nAssigned\nBidi_Control Bidi_C\nBidi_Mirrored Bidi_M\nCase_Ignorable CI\nCased\nChanges_When_Casefolded CWCF\nChanges_When_Casemapped CWCM\nChanges_When_Lowercased CWL\nChanges_When_NFKC_Casefolded CWKCF\nChanges_When_Titlecased CWT\nChanges_When_Uppercased CWU\nDash\nDefault_Ignorable_Code_Point DI\nDeprecated Dep\nDiacritic Dia\nEmoji\nEmoji_Component EComp\nEmoji_Modifier EMod\nEmoji_Modifier_Base EBase\nEmoji_Presentation EPres\nExtended_Pictographic ExtPict\nExtender Ext\nGrapheme_Base Gr_Base\nGrapheme_Extend Gr_Ext\nHex_Digit Hex\nIDS_Binary_Operator IDSB\nIDS_Trinary_Operator IDST\nID_Continue IDC\nID_Start IDS\nIdeographic Ideo\nJoin_Control Join_C\nLogical_Order_Exception LOE\nLowercase Lower\nMath\nNoncharacter_Code_Point NChar\nPattern_Syntax Pat_Syn\nPattern_White_Space Pat_WS\nQuotation_Mark QMark\nRadical\nRegional_Indicator RI\nSentence_Terminal STerm\nSoft_Dotted SD\nTerminal_Punctuation Term\nUnified_Ideograph UIdeo\nUppercase Upper\nVariation_Selector VS\nWhite_Space space\nXID_Continue XIDC\nXID_Start XIDS`.split(/\\s/)\n);\nvar JsUnicodePropertiesMap = /* @__PURE__ */ new Map();\nfor (const p of JsUnicodeProperties) {\n  JsUnicodePropertiesMap.set(slug(p), p);\n}\nvar JsUnicodePropertiesOfStrings = /* @__PURE__ */ new Set([\n  // ES2024 properties of strings; none are supported by Oniguruma\n  \"Basic_Emoji\",\n  \"Emoji_Keycap_Sequence\",\n  \"RGI_Emoji\",\n  \"RGI_Emoji_Flag_Sequence\",\n  \"RGI_Emoji_Modifier_Sequence\",\n  \"RGI_Emoji_Tag_Sequence\",\n  \"RGI_Emoji_ZWJ_Sequence\"\n]);\nvar JsUnicodePropertiesOfStringsMap = /* @__PURE__ */ new Map();\nfor (const p of JsUnicodePropertiesOfStrings) {\n  JsUnicodePropertiesOfStringsMap.set(slug(p), p);\n}\nvar LowerToAlternativeLowerCaseMap = /* @__PURE__ */ new Map([\n  [\"s\", cp(383)],\n  // s, ſ\n  [cp(383), \"s\"]\n  // ſ, s\n]);\nvar LowerToAlternativeUpperCaseMap = /* @__PURE__ */ new Map([\n  [cp(223), cp(7838)],\n  // ß, ẞ\n  [cp(107), cp(8490)],\n  // k, K (Kelvin)\n  [cp(229), cp(8491)],\n  // å, Å (Angstrom)\n  [cp(969), cp(8486)]\n  // ω, Ω (Ohm)\n]);\nvar LowerToTitleCaseMap = new Map([\n  titleEntry(453),\n  titleEntry(456),\n  titleEntry(459),\n  titleEntry(498),\n  ...titleRange(8072, 8079),\n  ...titleRange(8088, 8095),\n  ...titleRange(8104, 8111),\n  titleEntry(8124),\n  titleEntry(8140),\n  titleEntry(8188)\n]);\nvar PosixClassesMap = /* @__PURE__ */ new Map([\n  [\"alnum\", r`[\\p{Alpha}\\p{Nd}]`],\n  [\"alpha\", r`\\p{Alpha}`],\n  [\"ascii\", r`\\p{ASCII}`],\n  [\"blank\", r`[\\p{Zs}\\t]`],\n  [\"cntrl\", r`\\p{cntrl}`],\n  [\"digit\", r`\\p{Nd}`],\n  [\"graph\", r`[\\P{space}&&\\P{cntrl}&&\\P{Cn}&&\\P{Cs}]`],\n  [\"lower\", r`\\p{Lower}`],\n  [\"print\", r`[[\\P{space}&&\\P{cntrl}&&\\P{Cn}&&\\P{Cs}]\\p{Zs}]`],\n  [\"punct\", r`[\\p{P}\\p{S}]`],\n  // New value from Oniguruma 6.9.9\n  [\"space\", r`\\p{space}`],\n  [\"upper\", r`\\p{Upper}`],\n  [\"word\", r`[\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}]`],\n  [\"xdigit\", r`\\p{AHex}`]\n]);\nvar PosixProperties = /* @__PURE__ */ new Set([\n  \"alnum\",\n  \"blank\",\n  \"graph\",\n  \"print\",\n  \"word\",\n  \"xdigit\"\n  // The following are available with the same name in JS (see `JsUnicodeProperties`), so can be\n  // handled as standard Unicode properties\n  // 'alpha', // (JS: Alpha)\n  // 'ascii', // (JS: ASCII)\n  // 'cntrl', // (JS: cntrl)\n  // 'digit', // (JS: digit)\n  // 'lower', // (JS: Lower)\n  // 'punct', // (JS: punct)\n  // 'space', // (JS: space)\n  // 'upper', // (JS: Upper)\n]);\nfunction range(start, end) {\n  const range2 = [];\n  for (let i = start; i <= end; i++) {\n    range2.push(i);\n  }\n  return range2;\n}\nfunction slug(name) {\n  return name.replace(/[- _]+/g, \"\").toLowerCase();\n}\nfunction titleEntry(codePoint) {\n  const char = cp(codePoint);\n  return [char.toLowerCase(), char];\n}\nfunction titleRange(start, end) {\n  return range(start, end).map((codePoint) => titleEntry(codePoint));\n}\nvar UnicodePropertiesWithSpecificCase = /* @__PURE__ */ new Set([\n  \"Lower\",\n  \"Lowercase\",\n  \"Upper\",\n  \"Uppercase\",\n  \"Ll\",\n  \"Lowercase_Letter\",\n  \"Lt\",\n  \"Titlecase_Letter\",\n  \"Lu\",\n  \"Uppercase_Letter\"\n  // The `Changes_When_*` properties (and their aliases) could be included, but they're very rare.\n  // Some other properties include a handful of chars with specific cases only, but these chars are\n  // generally extreme edge cases and using such properties case insensitively generally produces\n  // undesired behavior anyway\n]);\n\n// src/tokenize.js\nvar TokenTypes = (\n  /** @type {const} */\n  {\n    Alternator: \"Alternator\",\n    Assertion: \"Assertion\",\n    Backreference: \"Backreference\",\n    Character: \"Character\",\n    CharacterClassClose: \"CharacterClassClose\",\n    CharacterClassHyphen: \"CharacterClassHyphen\",\n    CharacterClassIntersector: \"CharacterClassIntersector\",\n    CharacterClassOpen: \"CharacterClassOpen\",\n    CharacterSet: \"CharacterSet\",\n    Directive: \"Directive\",\n    GroupClose: \"GroupClose\",\n    GroupOpen: \"GroupOpen\",\n    Subroutine: \"Subroutine\",\n    Quantifier: \"Quantifier\",\n    // These aren't allowed in char classes, so they aren't equivalent to JS `[\\q{}]`\n    VariableLengthCharacterSet: \"VariableLengthCharacterSet\",\n    // Intermediate representation not included in results\n    EscapedNumber: \"EscapedNumber\"\n  }\n);\nvar TokenCharacterSetKinds = {\n  any: \"any\",\n  digit: \"digit\",\n  dot: \"dot\",\n  hex: \"hex\",\n  non_newline: \"non_newline\",\n  posix: \"posix\",\n  property: \"property\",\n  space: \"space\",\n  word: \"word\"\n};\nvar TokenDirectiveKinds = {\n  flags: \"flags\",\n  keep: \"keep\"\n};\nvar TokenGroupKinds = {\n  absent_repeater: \"absent_repeater\",\n  atomic: \"atomic\",\n  capturing: \"capturing\",\n  group: \"group\",\n  lookahead: \"lookahead\",\n  lookbehind: \"lookbehind\"\n};\nvar EscapeCharCodes = /* @__PURE__ */ new Map([\n  [\"a\", 7],\n  // alert/bell (Not available in JS)\n  [\"b\", 8],\n  // backspace (only in char classes)\n  [\"e\", 27],\n  // escape (Not available in JS)\n  [\"f\", 12],\n  // form feed\n  [\"n\", 10],\n  // line feed\n  [\"r\", 13],\n  // carriage return\n  [\"t\", 9],\n  // horizontal tab\n  [\"v\", 11]\n  // vertical tab\n]);\nvar charClassOpenPattern = r`\\[\\^?`;\nvar sharedEscapesPattern = `${// Control char\n\"c.? | C(?:-.?)?\"}|${// Unicode property; Onig considers `\\p` an identity escape, but e.g. `\\p{`, `\\p{ ^L}`, and\n// `\\p{gc=L}` are invalid\nr`[pP]\\{(?:\\^?[-\\x20_]*[A-Za-z][-\\x20\\w]*\\})?`}|${// Hex encoded byte sequence; attempt match before other `\\xNN` hex char\nr`x[89A-Fa-f]\\p{AHex}(?:\\\\x[89A-Fa-f]\\p{AHex})*`}|${// Hex char\nr`u(?:\\p{AHex}{4})? | x\\{[^\\}]*\\}? | x\\p{AHex}{0,2}`}|${// Enclosed octal code point\nr`o\\{[^\\}]*\\}?`}|${// Escaped number\nr`\\d{1,3}`}`;\nvar quantifierRe = /[?*+][?+]?|\\{(?:\\d+(?:,\\d*)?|,\\d+)\\}\\??/;\nvar tokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | [gk]<[^>]*>?\n    | [gk]'[^']*'?\n    | .\n  )\n  | \\( (?:\n    \\? (?:\n      [:=!>({]\n      | <[=!]\n      | <[^>]*>\n      | '[^']*'\n      | ~\\|?\n      | #(?:[^)\\\\]|\\\\.?)*\n      | [^:)]*[:)]\n    )?\n    | \\*\n  )?\n  | ${quantifierRe.source}\n  | ${charClassOpenPattern}\n  | .\n`.replace(/\\s+/g, \"\"), \"gsu\");\nvar charClassTokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | .\n  )\n  | \\[:(?:\\^?\\p{Alpha}+|\\^):\\]\n  | ${charClassOpenPattern}\n  | &&\n  | .\n`.replace(/\\s+/g, \"\"), \"gsu\");\nfunction tokenize(pattern, flags = \"\", rules) {\n  rules = {\n    // `ONIG_OPTION_CAPTURE_GROUP`\n    captureGroup: false,\n    // `ONIG_OPTION_SINGLELINE`\n    singleline: false,\n    ...rules\n  };\n  if (typeof pattern !== \"string\") {\n    throw new Error(\"String expected as pattern\");\n  }\n  if (!/^[imxDSW]*$/.test(flags)) {\n    throw new Error(`Flags \"${flags}\" includes unsupported value`);\n  }\n  const extended = flags.includes(\"x\");\n  const xStack = [extended];\n  const context = {\n    captureGroup: rules.captureGroup,\n    getCurrentModX: () => xStack.at(-1),\n    numOpenGroups: 0,\n    popModX() {\n      xStack.pop();\n    },\n    pushModX(isXOn) {\n      xStack.push(isXOn);\n    },\n    replaceCurrentModX(isXOn) {\n      xStack[xStack.length - 1] = isXOn;\n    },\n    singleline: rules.singleline\n  };\n  let tokens = [];\n  let match;\n  tokenRe.lastIndex = 0;\n  while (match = tokenRe.exec(pattern)) {\n    const result = getTokenWithDetails(context, pattern, match[0], tokenRe.lastIndex);\n    if (result.tokens) {\n      tokens.push(...result.tokens);\n    } else if (result.token) {\n      tokens.push(result.token);\n    }\n    if (result.lastIndex !== void 0) {\n      tokenRe.lastIndex = result.lastIndex;\n    }\n  }\n  const potentialUnnamedCaptureTokens = [];\n  let numNamedAndOptInUnnamedCaptures = 0;\n  tokens.forEach((t) => {\n    if (t.type === TokenTypes.GroupOpen) {\n      if (t.kind === TokenGroupKinds.capturing) {\n        t.number = ++numNamedAndOptInUnnamedCaptures;\n      } else if (t.raw === \"(\") {\n        potentialUnnamedCaptureTokens.push(t);\n      }\n    }\n  });\n  if (!numNamedAndOptInUnnamedCaptures) {\n    potentialUnnamedCaptureTokens.forEach((t, i) => {\n      t.kind = TokenGroupKinds.capturing;\n      t.number = i + 1;\n    });\n  }\n  const numCaptures = numNamedAndOptInUnnamedCaptures || potentialUnnamedCaptureTokens.length;\n  tokens = tokens.map(\n    (t) => t.type === TokenTypes.EscapedNumber ? splitEscapedNumToken(t, numCaptures) : t\n  ).flat();\n  return {\n    tokens,\n    flags: {\n      ignoreCase: flags.includes(\"i\"),\n      // Flag m is called `multiline` in Onig, but that has a different meaning in JS. Onig flag m\n      // is equivalent to JS flag s\n      dotAll: flags.includes(\"m\"),\n      // Flag x is fully handled during tokenization\n      extended,\n      // Flags D, S, W are currently only supported as top-level flags\n      digitIsAscii: flags.includes(\"D\"),\n      spaceIsAscii: flags.includes(\"S\"),\n      wordIsAscii: flags.includes(\"W\")\n    },\n    rules\n  };\n}\nfunction getTokenWithDetails(context, pattern, m, lastIndex) {\n  const [m0, m1] = m;\n  if (m0 === \"[\") {\n    const result = getAllTokensForCharClass(pattern, m, lastIndex);\n    return {\n      // Array of all of the char class's tokens\n      tokens: result.tokens,\n      // Jump forward to the end of the char class\n      lastIndex: result.lastIndex\n    };\n  }\n  if (m0 === \"\\\\\") {\n    if (\"AbBGzZ\".includes(m1)) {\n      return {\n        token: createToken(TokenTypes.Assertion, m, {\n          kind: m\n        })\n      };\n    }\n    if (/^\\\\g[<']/.test(m)) {\n      if (!/^\\\\g(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.Subroutine, m)\n      };\n    }\n    if (/^\\\\k[<']/.test(m)) {\n      if (!/^\\\\k(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.Backreference, m)\n      };\n    }\n    if (m1 === \"K\") {\n      return {\n        token: createToken(TokenTypes.Directive, m, {\n          kind: TokenDirectiveKinds.keep\n        })\n      };\n    }\n    if (m1 === \"N\") {\n      return {\n        token: createToken(TokenTypes.CharacterSet, m, {\n          kind: TokenCharacterSetKinds.non_newline\n        })\n      };\n    }\n    if (m1 === \"O\") {\n      return {\n        token: createToken(TokenTypes.CharacterSet, m, {\n          kind: TokenCharacterSetKinds.any\n        })\n      };\n    }\n    if (\"RX\".includes(m1)) {\n      return {\n        token: createToken(TokenTypes.VariableLengthCharacterSet, m, {\n          kind: m\n        })\n      };\n    }\n    if (\"yY\".includes(m1)) {\n      throw new Error(`Unsupported grapheme boundary \"${m}\"`);\n    }\n    const result = createTokenForSharedEscape(m, { inCharClass: false });\n    return Array.isArray(result) ? { tokens: result } : { token: result };\n  }\n  if (m0 === \"(\") {\n    if (m === \"(*\") {\n      throw new Error(`Unsupported named callout \"${m}\"`);\n    }\n    if (m === \"(?{\") {\n      throw new Error(`Unsupported callout \"${m}\"`);\n    }\n    if (m === \"(?#\") {\n      if (pattern[lastIndex] !== \")\") {\n        throw new Error('Unclosed comment group \"(?#\"');\n      }\n      return {\n        lastIndex: lastIndex + 1\n      };\n    }\n    if (/^\\(\\?[-imx]+[:)]$/.test(m)) {\n      return {\n        token: createTokenForFlagMod(m, context)\n      };\n    }\n    context.pushModX(context.getCurrentModX());\n    context.numOpenGroups++;\n    if (\n      // Unnamed capture if no named captures present and `captureGroup` not enabled, else\n      // noncapturing group\n      m === \"(\" && !context.captureGroup || // Noncapturing group\n      m === \"(?:\"\n    ) {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          // For `(`, will later change to `capturing` and add `number` prop if no named captures\n          kind: TokenGroupKinds.group\n        })\n      };\n    }\n    if (m === \"(?>\") {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: TokenGroupKinds.atomic\n        })\n      };\n    }\n    if (m === \"(?=\" || m === \"(?!\" || m === \"(?<=\" || m === \"(?<!\") {\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: m[2] === \"<\" ? TokenGroupKinds.lookbehind : TokenGroupKinds.lookahead,\n          negate: m.endsWith(\"!\")\n        })\n      };\n    }\n    if (m === \"(\" && context.captureGroup || m.startsWith(\"(?<\") && m.endsWith(\">\") || m.startsWith(\"(?'\") && m.endsWith(\"'\")) {\n      const token = createToken(TokenTypes.GroupOpen, m, {\n        kind: TokenGroupKinds.capturing\n        // Will add `number` prop in a second pass\n      });\n      if (m !== \"(\") {\n        token.name = m.slice(3, -1);\n      }\n      return {\n        token\n      };\n    }\n    if (m.startsWith(\"(?~\")) {\n      if (m === \"(?~|\") {\n        throw new Error(`Unsupported absent function kind \"${m}\"`);\n      }\n      return {\n        token: createToken(TokenTypes.GroupOpen, m, {\n          kind: TokenGroupKinds.absent_repeater\n        })\n      };\n    }\n    if (m === \"(?(\") {\n      throw new Error(`Unsupported conditional \"${m}\"`);\n    }\n    throw new Error(`Invalid or unsupported group option \"${m}\"`);\n  }\n  if (m === \")\") {\n    context.popModX();\n    context.numOpenGroups--;\n    if (context.numOpenGroups < 0) {\n      throw new Error('Unmatched \")\"');\n    }\n    return {\n      token: createToken(TokenTypes.GroupClose, m)\n    };\n  }\n  if (m === \"#\" && context.getCurrentModX()) {\n    const end = pattern.indexOf(\"\\n\", lastIndex);\n    return {\n      // Jump forward to the end of the comment\n      lastIndex: end === -1 ? pattern.length : end\n    };\n  }\n  if (/^\\s$/.test(m) && context.getCurrentModX()) {\n    const re = /\\s+/y;\n    re.lastIndex = lastIndex;\n    const rest = re.exec(pattern);\n    return {\n      // Jump forward to the end of the whitespace\n      lastIndex: rest ? re.lastIndex : lastIndex\n    };\n  }\n  if (m === \".\") {\n    return {\n      token: createToken(TokenTypes.CharacterSet, m, {\n        kind: TokenCharacterSetKinds.dot\n      })\n    };\n  }\n  if (m === \"^\" || m === \"$\") {\n    const kind = context.singleline ? {\n      \"^\": r`\\A`,\n      \"$\": r`\\Z`\n    }[m] : m;\n    return {\n      token: createToken(TokenTypes.Assertion, m, {\n        kind\n      })\n    };\n  }\n  if (m === \"|\") {\n    return {\n      token: createToken(TokenTypes.Alternator, m)\n    };\n  }\n  if (quantifierRe.test(m)) {\n    return {\n      token: createTokenForQuantifier(m)\n    };\n  }\n  assertSingleCodePoint(m);\n  return {\n    token: createToken(TokenTypes.Character, m, {\n      value: m.codePointAt(0)\n    })\n  };\n}\nfunction getAllTokensForCharClass(pattern, opener, lastIndex) {\n  const tokens = [createToken(TokenTypes.CharacterClassOpen, opener, {\n    negate: opener[1] === \"^\"\n  })];\n  let numCharClassesOpen = 1;\n  let match;\n  charClassTokenRe.lastIndex = lastIndex;\n  while (match = charClassTokenRe.exec(pattern)) {\n    const m = match[0];\n    if (m[0] === \"[\" && m[1] !== \":\") {\n      numCharClassesOpen++;\n      tokens.push(createToken(TokenTypes.CharacterClassOpen, m, {\n        negate: m[1] === \"^\"\n      }));\n    } else if (m === \"]\") {\n      if (tokens.at(-1).type === TokenTypes.CharacterClassOpen) {\n        tokens.push(createToken(TokenTypes.Character, m, {\n          value: 93\n        }));\n      } else {\n        numCharClassesOpen--;\n        tokens.push(createToken(TokenTypes.CharacterClassClose, m));\n        if (!numCharClassesOpen) {\n          break;\n        }\n      }\n    } else {\n      const result = createTokenForAnyTokenWithinCharClass(m);\n      if (Array.isArray(result)) {\n        tokens.push(...result);\n      } else {\n        tokens.push(result);\n      }\n    }\n  }\n  return {\n    tokens,\n    lastIndex: charClassTokenRe.lastIndex || pattern.length\n  };\n}\nfunction createTokenForAnyTokenWithinCharClass(raw) {\n  if (raw[0] === \"\\\\\") {\n    return createTokenForSharedEscape(raw, { inCharClass: true });\n  }\n  if (raw[0] === \"[\") {\n    const posix = /\\[:(?<negate>\\^?)(?<name>[a-z]+):\\]/.exec(raw);\n    if (!posix || !PosixClassesMap.get(posix.groups.name)) {\n      throw new Error(`Invalid POSIX class \"${raw}\"`);\n    }\n    return createToken(TokenTypes.CharacterSet, raw, {\n      kind: TokenCharacterSetKinds.posix,\n      negate: !!posix.groups.negate,\n      value: posix.groups.name\n    });\n  }\n  if (raw === \"-\") {\n    return createToken(TokenTypes.CharacterClassHyphen, raw);\n  }\n  if (raw === \"&&\") {\n    return createToken(TokenTypes.CharacterClassIntersector, raw);\n  }\n  assertSingleCodePoint(raw);\n  return createToken(TokenTypes.Character, raw, {\n    value: raw.codePointAt(0)\n  });\n}\nfunction createTokenForSharedEscape(raw, { inCharClass }) {\n  const char1 = raw[1];\n  if (char1 === \"c\" || char1 === \"C\") {\n    return createTokenForControlChar(raw);\n  }\n  if (\"dDhHsSwW\".includes(char1)) {\n    return createTokenForShorthandCharClass(raw);\n  }\n  if (raw.startsWith(r`\\o{`)) {\n    throw new Error(`Incomplete, invalid, or unsupported octal code point \"${raw}\"`);\n  }\n  if (/^\\\\[pP]\\{/.test(raw)) {\n    if (raw.length === 3) {\n      throw new Error(`Incomplete or invalid Unicode property \"${raw}\"`);\n    }\n    return createTokenForUnicodeProperty(raw);\n  }\n  if (/^\\\\x[89A-Fa-f]\\p{AHex}/u.test(raw)) {\n    try {\n      const bytes = raw.split(/\\\\x/).slice(1).map((hex) => parseInt(hex, 16));\n      const decoded = new TextDecoder(\"utf-8\", {\n        ignoreBOM: true,\n        fatal: true\n      }).decode(new Uint8Array(bytes));\n      const encoder = new TextEncoder();\n      const tokens = [...decoded].map((char) => {\n        const raw2 = [...encoder.encode(char)].map((byte) => `\\\\x${byte.toString(16)}`).join(\"\");\n        return createToken(TokenTypes.Character, raw2, {\n          value: char.codePointAt(0)\n        });\n      });\n      return tokens;\n    } catch {\n      throw new Error(`Multibyte code \"${raw}\" incomplete or invalid in Oniguruma`);\n    }\n  }\n  if (char1 === \"u\" || char1 === \"x\") {\n    return createToken(TokenTypes.Character, raw, {\n      value: getValidatedHexCharCode(raw)\n    });\n  }\n  if (EscapeCharCodes.has(char1)) {\n    return createToken(TokenTypes.Character, raw, {\n      value: EscapeCharCodes.get(char1)\n    });\n  }\n  if (/\\d/.test(char1)) {\n    return createToken(TokenTypes.EscapedNumber, raw, {\n      inCharClass\n    });\n  }\n  if (raw === \"\\\\\") {\n    throw new Error(r`Incomplete escape \"\\\"`);\n  }\n  if (char1 === \"M\") {\n    throw new Error(`Unsupported meta \"${raw}\"`);\n  }\n  if ([...raw].length === 2) {\n    return createToken(TokenTypes.Character, raw, {\n      value: raw.codePointAt(1)\n    });\n  }\n  throw new Error(`Unexpected escape \"${raw}\"`);\n}\nfunction createToken(type, raw, data) {\n  return {\n    type,\n    raw,\n    ...data\n  };\n}\nfunction createTokenForControlChar(raw) {\n  const char = raw[1] === \"c\" ? raw[2] : raw[3];\n  if (!char || !/[A-Za-z]/.test(char)) {\n    throw new Error(`Unsupported control character \"${raw}\"`);\n  }\n  return createToken(TokenTypes.Character, raw, {\n    value: char.toUpperCase().codePointAt(0) - 64\n  });\n}\nfunction createTokenForFlagMod(raw, context) {\n  let { on, off } = /^\\(\\?(?<on>[imx]*)(?:-(?<off>[-imx]*))?/.exec(raw).groups;\n  off ??= \"\";\n  const isXOn = (context.getCurrentModX() || on.includes(\"x\")) && !off.includes(\"x\");\n  const enabledFlags = getFlagPropsForToken(on);\n  const disabledFlags = getFlagPropsForToken(off);\n  const flagChanges = {};\n  enabledFlags && (flagChanges.enable = enabledFlags);\n  disabledFlags && (flagChanges.disable = disabledFlags);\n  if (raw.endsWith(\")\")) {\n    context.replaceCurrentModX(isXOn);\n    return createToken(TokenTypes.Directive, raw, {\n      kind: TokenDirectiveKinds.flags,\n      flags: flagChanges\n    });\n  }\n  if (raw.endsWith(\":\")) {\n    context.pushModX(isXOn);\n    context.numOpenGroups++;\n    const token = createToken(TokenTypes.GroupOpen, raw, {\n      kind: TokenGroupKinds.group\n    });\n    if (enabledFlags || disabledFlags) {\n      token.flags = flagChanges;\n    }\n    return token;\n  }\n  throw new Error(`Unexpected flag modifier \"${raw}\"`);\n}\nfunction createTokenForQuantifier(raw) {\n  const data = {};\n  if (raw[0] === \"{\") {\n    const { min, max } = /^\\{(?<min>\\d*)(?:,(?<max>\\d*))?/.exec(raw).groups;\n    const limit = 1e5;\n    if (+min > limit || +max > limit) {\n      throw new Error(\"Quantifier value unsupported in Oniguruma\");\n    }\n    data.min = +min;\n    data.max = max === void 0 ? +min : max === \"\" ? Infinity : +max;\n    data.greedy = !raw.endsWith(\"?\");\n    data.possessive = false;\n  } else {\n    data.min = raw[0] === \"+\" ? 1 : 0;\n    data.max = raw[0] === \"?\" ? 1 : Infinity;\n    data.greedy = raw[1] !== \"?\";\n    data.possessive = raw[1] === \"+\";\n  }\n  return createToken(TokenTypes.Quantifier, raw, data);\n}\nfunction createTokenForShorthandCharClass(raw) {\n  const lower = raw[1].toLowerCase();\n  return createToken(TokenTypes.CharacterSet, raw, {\n    kind: {\n      \"d\": TokenCharacterSetKinds.digit,\n      \"h\": TokenCharacterSetKinds.hex,\n      // Not available in JS\n      \"s\": TokenCharacterSetKinds.space,\n      // Different than JS\n      \"w\": TokenCharacterSetKinds.word\n    }[lower],\n    negate: raw[1] !== lower\n  });\n}\nfunction createTokenForUnicodeProperty(raw) {\n  const { p, neg, value } = /^\\\\(?<p>[pP])\\{(?<neg>\\^?)(?<value>[^}]+)/.exec(raw).groups;\n  const negate = p === \"P\" && !neg || p === \"p\" && !!neg;\n  return createToken(TokenTypes.CharacterSet, raw, {\n    kind: TokenCharacterSetKinds.property,\n    negate,\n    value\n  });\n}\nfunction getFlagPropsForToken(flags) {\n  const obj = {};\n  if (flags.includes(\"i\")) {\n    obj.ignoreCase = true;\n  }\n  if (flags.includes(\"m\")) {\n    obj.dotAll = true;\n  }\n  if (flags.includes(\"x\")) {\n    obj.extended = true;\n  }\n  return Object.keys(obj).length ? obj : null;\n}\nfunction getValidatedHexCharCode(raw) {\n  if (/^(?:\\\\u(?!\\p{AHex}{4})|\\\\x(?!\\p{AHex}{1,2}|\\{\\p{AHex}{1,8}\\}))/u.test(raw)) {\n    throw new Error(`Incomplete or invalid escape \"${raw}\"`);\n  }\n  const hex = raw[2] === \"{\" ? /^\\\\x\\{\\s*(?<hex>\\p{AHex}+)/u.exec(raw).groups.hex : raw.slice(2);\n  const dec = parseInt(hex, 16);\n  return dec;\n}\nfunction splitEscapedNumToken(token, numCaptures) {\n  const { raw, inCharClass } = token;\n  const value = raw.slice(1);\n  if (!inCharClass && // Single digit 1-9 outside a char class is always treated as a backref\n  (value !== \"0\" && value.length === 1 || // Leading 0 makes it octal; backrefs can't include following literal digits\n  value[0] !== \"0\" && +value <= numCaptures)) {\n    return [createToken(TokenTypes.Backreference, raw)];\n  }\n  const tokens = [];\n  const matches = value.match(/^[0-7]+|\\d/g);\n  for (let i = 0; i < matches.length; i++) {\n    const m = matches[i];\n    let value2;\n    if (i === 0 && m !== \"8\" && m !== \"9\") {\n      value2 = parseInt(m, 8);\n      if (value2 > 127) {\n        throw new Error(r`Octal encoded byte above 177 unsupported \"${raw}\"`);\n      }\n    } else {\n      value2 = m.codePointAt(0);\n    }\n    tokens.push(createToken(TokenTypes.Character, (i === 0 ? \"\\\\\" : \"\") + m, {\n      value: value2\n    }));\n  }\n  return tokens;\n}\nfunction assertSingleCodePoint(raw) {\n  if ([...raw].length !== 1) {\n    throw new Error(`Expected \"${raw}\" to be a single code point`);\n  }\n}\n\n// src/utils-ast.js\nfunction hasOnlyChild({ alternatives }, kidFn) {\n  return alternatives.length === 1 && alternatives[0].elements.length === 1 && (!kidFn || kidFn(alternatives[0].elements[0]));\n}\nfunction isAlwaysZeroLength({ type }) {\n  return type === AstTypes.Assertion || type === AstTypes.Directive;\n}\nfunction isAlwaysNonZeroLength(node) {\n  const types = [\n    AstTypes.Character,\n    AstTypes.CharacterClass,\n    AstTypes.CharacterSet\n  ];\n  return types.includes(node.type) || node.type === AstTypes.Quantifier && node.min && types.includes(node.element.type);\n}\nfunction isConsumptiveGroup({ type }) {\n  return type === AstTypes.CapturingGroup || type === AstTypes.Group;\n}\nfunction isLookaround({ type, kind }) {\n  return type === AstTypes.Assertion && (kind === AstAssertionKinds.lookahead || kind === AstAssertionKinds.lookbehind);\n}\n\n// src/traverse.js\nfunction traverse(path, state, visitor) {\n  let ast = path.node;\n  while (ast.parent) {\n    ast = ast.parent;\n  }\n  function traverseArray(array, parent) {\n    for (let i = 0; i < array.length; i++) {\n      const keyShift = traverseNode(array[i], parent, i, array);\n      i = Math.max(-1, i + keyShift);\n    }\n  }\n  function traverseNode(node, parent = null, key = null, container = null) {\n    let keyShift = 0;\n    let skipTraversingKidsOfPath = false;\n    const path2 = {\n      node,\n      parent,\n      key,\n      container,\n      ast,\n      remove() {\n        throwIfNot(container, \"Container expected\").splice(Math.max(0, key + keyShift), 1);\n        keyShift -= 1;\n      },\n      removeAllNextSiblings() {\n        return throwIfNot(container, \"Container expected\").splice(key + 1);\n      },\n      removeAllPrevSiblings() {\n        const shifted = key + keyShift;\n        keyShift -= shifted;\n        return throwIfNot(container, \"Container expected\").splice(0, Math.max(0, shifted));\n      },\n      replaceWith(newNode) {\n        setParent(newNode, parent);\n        if (container) {\n          container[Math.max(0, key + keyShift)] = newNode;\n        } else {\n          parent[key] = newNode;\n        }\n      },\n      skip() {\n        skipTraversingKidsOfPath = true;\n      }\n    };\n    const visitorKey = getAstTypeAliases(node).find((key2) => !!visitor[key2]);\n    const methods = visitorKey && visitor[visitorKey];\n    const enterFn = typeof methods === \"function\" ? methods : methods?.enter;\n    const exitFn = methods?.exit;\n    enterFn?.(path2, state);\n    if (!skipTraversingKidsOfPath) {\n      switch (node.type) {\n        case AstTypes.Regex:\n          traverseNode(node.pattern, node, \"pattern\");\n          traverseNode(node.flags, node, \"flags\");\n          break;\n        case AstTypes.Alternative:\n        case AstTypes.CharacterClass:\n          traverseArray(node.elements, node);\n          break;\n        case AstTypes.Assertion:\n          if (isLookaround(node)) {\n            traverseArray(node.alternatives, node);\n          }\n          break;\n        case AstTypes.Backreference:\n        case AstTypes.Character:\n        case AstTypes.CharacterSet:\n        case AstTypes.Directive:\n        case AstTypes.Flags:\n        case AstTypes.Recursion:\n        case AstTypes.Subroutine:\n        case AstTypes.VariableLengthCharacterSet:\n          break;\n        case AstTypes.AbsentFunction:\n        case AstTypes.CapturingGroup:\n        case AstTypes.Group:\n        case AstTypes.Pattern:\n          traverseArray(node.alternatives, node);\n          break;\n        case AstTypes.CharacterClassIntersection:\n          traverseArray(node.classes, node);\n          break;\n        case AstTypes.CharacterClassRange:\n          traverseNode(node.min, node, \"min\");\n          traverseNode(node.max, node, \"max\");\n          break;\n        case AstTypes.Quantifier:\n          traverseNode(node.element, node, \"element\");\n          break;\n        default:\n          throw new Error(`Unexpected node type \"${node.type}\"`);\n      }\n    }\n    exitFn?.(path2, state);\n    return keyShift;\n  }\n  traverseNode(path.node, path.parent, path.key, path.container);\n}\nvar AstTypeAliases = {\n  AnyGroup: \"AnyGroup\",\n  AnyNode: \"AnyNode\"\n};\nfunction getAstTypeAliases(node) {\n  const types = [AstTypeAliases.AnyNode];\n  if (isConsumptiveGroup(node) || isLookaround(node)) {\n    types.push(AstTypeAliases.AnyGroup);\n  }\n  types.push(node.type);\n  return types;\n}\nfunction setParent(node, parent) {\n  if (\"parent\" in parent) {\n    node.parent = parent;\n  }\n}\n\n// src/parse.js\nvar AstTypes = {\n  AbsentFunction: \"AbsentFunction\",\n  Alternative: \"Alternative\",\n  Assertion: \"Assertion\",\n  Backreference: \"Backreference\",\n  CapturingGroup: \"CapturingGroup\",\n  Character: \"Character\",\n  CharacterClass: \"CharacterClass\",\n  CharacterClassIntersection: \"CharacterClassIntersection\",\n  CharacterClassRange: \"CharacterClassRange\",\n  CharacterSet: \"CharacterSet\",\n  Directive: \"Directive\",\n  Flags: \"Flags\",\n  Group: \"Group\",\n  Pattern: \"Pattern\",\n  Quantifier: \"Quantifier\",\n  Regex: \"Regex\",\n  Subroutine: \"Subroutine\",\n  VariableLengthCharacterSet: \"VariableLengthCharacterSet\",\n  // Used only by the transformer for Regex+ ASTs\n  Recursion: \"Recursion\"\n};\nvar AstAbsentFunctionKinds = {\n  // See <github.com/slevithan/oniguruma-to-es/issues/13>\n  repeater: \"repeater\"\n};\nvar AstAssertionKinds = {\n  line_end: \"line_end\",\n  line_start: \"line_start\",\n  lookahead: \"lookahead\",\n  lookbehind: \"lookbehind\",\n  search_start: \"search_start\",\n  string_end: \"string_end\",\n  string_end_newline: \"string_end_newline\",\n  string_start: \"string_start\",\n  word_boundary: \"word_boundary\"\n};\nvar AstCharacterSetKinds = TokenCharacterSetKinds;\nvar AstDirectiveKinds = TokenDirectiveKinds;\nvar AstVariableLengthCharacterSetKinds = {\n  grapheme: \"grapheme\",\n  newline: \"newline\"\n};\nfunction parse({ tokens, flags, rules }, options) {\n  const opts = {\n    skipBackrefValidation: false,\n    skipLookbehindValidation: false,\n    skipPropertyNameValidation: false,\n    verbose: false,\n    ...options\n  };\n  const context = {\n    capturingGroups: [],\n    current: 0,\n    hasNumberedRef: false,\n    namedGroupsByName: /* @__PURE__ */ new Map(),\n    parent: null,\n    skipBackrefValidation: opts.skipBackrefValidation,\n    skipLookbehindValidation: opts.skipLookbehindValidation,\n    skipPropertyNameValidation: opts.skipPropertyNameValidation,\n    subroutines: [],\n    token: null,\n    tokens,\n    verbose: opts.verbose,\n    walk\n  };\n  function walk(parent, state) {\n    const token = tokens[context.current];\n    context.parent = parent;\n    context.token = token;\n    context.current++;\n    switch (token.type) {\n      case TokenTypes.Alternator:\n        return createAlternative();\n      case TokenTypes.Assertion:\n        return createAssertionFromToken(token);\n      case TokenTypes.Backreference:\n        return parseBackreference(context);\n      case TokenTypes.Character:\n        return createCharacter(token.value, { useLastValid: !!state.isCheckingRangeEnd });\n      case TokenTypes.CharacterClassHyphen:\n        return parseCharacterClassHyphen(context, state);\n      case TokenTypes.CharacterClassOpen:\n        return parseCharacterClassOpen(context, state);\n      case TokenTypes.CharacterSet:\n        return parseCharacterSet(context);\n      case TokenTypes.Directive:\n        return createDirectiveFromToken(token);\n      case TokenTypes.GroupOpen:\n        return parseGroupOpen(context, state);\n      case TokenTypes.Quantifier:\n        return parseQuantifier(context);\n      case TokenTypes.Subroutine:\n        return parseSubroutine(context);\n      case TokenTypes.VariableLengthCharacterSet:\n        return createVariableLengthCharacterSet(token.kind);\n      default:\n        throw new Error(`Unexpected token type \"${token.type}\"`);\n    }\n  }\n  const ast = createRegex(createPattern(), createFlags(flags));\n  let top = ast.pattern.alternatives[0];\n  while (context.current < tokens.length) {\n    const node = walk(top, {});\n    if (node.type === AstTypes.Alternative) {\n      ast.pattern.alternatives.push(node);\n      top = node;\n    } else {\n      top.elements.push(node);\n    }\n  }\n  const { capturingGroups, hasNumberedRef, namedGroupsByName, subroutines } = context;\n  if (hasNumberedRef && namedGroupsByName.size && !rules.captureGroup) {\n    throw new Error(\"Numbered backref/subroutine not allowed when using named capture\");\n  }\n  for (const { ref } of subroutines) {\n    if (typeof ref === \"number\") {\n      if (ref > capturingGroups.length) {\n        throw new Error(`Subroutine uses a group number that's not defined`);\n      }\n    } else if (!namedGroupsByName.has(ref)) {\n      throw new Error(r`Subroutine uses a group name that's not defined \"\\g<${ref}>\"`);\n    } else if (namedGroupsByName.get(ref).length > 1) {\n      throw new Error(r`Subroutine uses a duplicate group name \"\\g<${ref}>\"`);\n    }\n  }\n  traverse({ node: ast }, null, {\n    AnyNode({ node, parent }) {\n      node.parent = parent;\n    }\n  });\n  return ast;\n}\nfunction parseBackreference(context) {\n  const { raw } = context.token;\n  const hasKWrapper = /^\\\\k[<']/.test(raw);\n  const ref = hasKWrapper ? raw.slice(3, -1) : raw.slice(1);\n  const fromNum = (num, isRelative = false) => {\n    const numCapturesToLeft = context.capturingGroups.length;\n    let orphan = false;\n    if (num > numCapturesToLeft) {\n      if (context.skipBackrefValidation) {\n        orphan = true;\n      } else {\n        throw new Error(`Not enough capturing groups defined to the left \"${raw}\"`);\n      }\n    }\n    context.hasNumberedRef = true;\n    return createBackreference(isRelative ? numCapturesToLeft + 1 - num : num, { orphan });\n  };\n  if (hasKWrapper) {\n    const numberedRef = /^(?<sign>-?)0*(?<num>[1-9]\\d*)$/.exec(ref);\n    if (numberedRef) {\n      return fromNum(+numberedRef.groups.num, !!numberedRef.groups.sign);\n    }\n    if (/[-+]/.test(ref)) {\n      throw new Error(`Invalid backref name \"${raw}\"`);\n    }\n    if (!context.namedGroupsByName.has(ref)) {\n      throw new Error(`Group name not defined to the left \"${raw}\"`);\n    }\n    return createBackreference(ref);\n  }\n  return fromNum(+ref);\n}\nfunction parseCharacterClassHyphen(context, state) {\n  const { parent, tokens, walk } = context;\n  const prevSiblingNode = parent.elements.at(-1);\n  const nextToken = tokens[context.current];\n  if (!state.isCheckingRangeEnd && prevSiblingNode && prevSiblingNode.type !== AstTypes.CharacterClass && prevSiblingNode.type !== AstTypes.CharacterClassRange && nextToken && nextToken.type !== TokenTypes.CharacterClassOpen && nextToken.type !== TokenTypes.CharacterClassClose && nextToken.type !== TokenTypes.CharacterClassIntersector) {\n    const nextNode = walk(parent, {\n      ...state,\n      isCheckingRangeEnd: true\n    });\n    if (prevSiblingNode.type === AstTypes.Character && nextNode.type === AstTypes.Character) {\n      parent.elements.pop();\n      return createCharacterClassRange(prevSiblingNode, nextNode);\n    }\n    throw new Error(\"Invalid character class range\");\n  }\n  return createCharacter(45);\n}\nfunction parseCharacterClassOpen(context, state) {\n  const { token, tokens, verbose, walk } = context;\n  const firstClassToken = tokens[context.current];\n  let node = createCharacterClass({ negate: token.negate });\n  const intersection = node.elements[0];\n  let nextToken = throwIfUnclosedCharacterClass(firstClassToken);\n  while (nextToken.type !== TokenTypes.CharacterClassClose) {\n    if (nextToken.type === TokenTypes.CharacterClassIntersector) {\n      intersection.classes.push(createCharacterClass({ negate: false, baseOnly: true }));\n      context.current++;\n    } else {\n      const cc = intersection.classes.at(-1);\n      cc.elements.push(walk(cc, state));\n    }\n    nextToken = throwIfUnclosedCharacterClass(tokens[context.current], firstClassToken);\n  }\n  if (!verbose) {\n    optimizeCharacterClassIntersection(intersection);\n  }\n  if (intersection.classes.length === 1) {\n    const cc = intersection.classes[0];\n    cc.negate = node.negate !== cc.negate;\n    node = cc;\n  }\n  context.current++;\n  return node;\n}\nfunction parseCharacterSet({ token, skipPropertyNameValidation }) {\n  let { kind, negate, value } = token;\n  if (kind === TokenCharacterSetKinds.property) {\n    const normalized = slug(value);\n    if (PosixProperties.has(normalized)) {\n      kind = TokenCharacterSetKinds.posix;\n      value = normalized;\n    } else {\n      return createUnicodeProperty(value, {\n        negate,\n        skipPropertyNameValidation\n      });\n    }\n  }\n  if (kind === TokenCharacterSetKinds.posix) {\n    return {\n      type: AstTypes.CharacterSet,\n      kind: AstCharacterSetKinds.posix,\n      negate,\n      value\n    };\n  }\n  return createCharacterSet(kind, { negate });\n}\nfunction parseGroupOpen(context, state) {\n  const { token, tokens, capturingGroups, namedGroupsByName, skipLookbehindValidation, verbose, walk } = context;\n  let node = createByGroupKind(token);\n  const isAbsentFunction = node.type === AstTypes.AbsentFunction;\n  const isLookbehind = node.kind === AstAssertionKinds.lookbehind;\n  const isNegLookbehind = isLookbehind && node.negate;\n  if (node.type === AstTypes.CapturingGroup) {\n    capturingGroups.push(node);\n    if (node.name) {\n      getOrInsert(namedGroupsByName, node.name, []).push(node);\n    }\n  }\n  if (isAbsentFunction && state.isInAbsentFunction) {\n    throw new Error(\"Nested absent function not supported by Oniguruma\");\n  }\n  let nextToken = throwIfUnclosedGroup(tokens[context.current]);\n  while (nextToken.type !== TokenTypes.GroupClose) {\n    if (nextToken.type === TokenTypes.Alternator) {\n      node.alternatives.push(createAlternative());\n      context.current++;\n    } else {\n      const alt = node.alternatives.at(-1);\n      const child = walk(alt, {\n        ...state,\n        isInAbsentFunction: state.isInAbsentFunction || isAbsentFunction,\n        isInLookbehind: state.isInLookbehind || isLookbehind,\n        isInNegLookbehind: state.isInNegLookbehind || isNegLookbehind\n      });\n      alt.elements.push(child);\n      if ((isLookbehind || state.isInLookbehind) && !skipLookbehindValidation) {\n        const msg = \"Lookbehind includes a pattern not allowed by Oniguruma\";\n        if (isNegLookbehind || state.isInNegLookbehind) {\n          if (child.kind === AstAssertionKinds.lookahead || child.type === AstTypes.CapturingGroup) {\n            throw new Error(msg);\n          }\n        } else {\n          if (child.kind === AstAssertionKinds.lookahead || child.kind === AstAssertionKinds.lookbehind && child.negate) {\n            throw new Error(msg);\n          }\n        }\n      }\n    }\n    nextToken = throwIfUnclosedGroup(tokens[context.current]);\n  }\n  if (!verbose) {\n    node = getOptimizedGroup(node);\n  }\n  context.current++;\n  return node;\n}\nfunction parseQuantifier({ token, parent }) {\n  const { min, max, greedy, possessive: possessive2 } = token;\n  const quantifiedNode = parent.elements.at(-1);\n  if (!quantifiedNode || quantifiedNode.type === AstTypes.Assertion || quantifiedNode.type === AstTypes.Directive) {\n    throw new Error(`Quantifier requires a repeatable token`);\n  }\n  const node = createQuantifier(quantifiedNode, min, max, greedy, possessive2);\n  parent.elements.pop();\n  return node;\n}\nfunction parseSubroutine(context) {\n  const { token, capturingGroups, subroutines } = context;\n  let ref = token.raw.slice(3, -1);\n  const numberedRef = /^(?<sign>[-+]?)0*(?<num>[1-9]\\d*)$/.exec(ref);\n  if (numberedRef) {\n    const num = +numberedRef.groups.num;\n    const numCapturesToLeft = capturingGroups.length;\n    context.hasNumberedRef = true;\n    ref = {\n      \"\": num,\n      \"+\": numCapturesToLeft + num,\n      \"-\": numCapturesToLeft + 1 - num\n    }[numberedRef.groups.sign];\n    if (ref < 1) {\n      throw new Error(\"Invalid subroutine number\");\n    }\n  } else if (ref === \"0\") {\n    ref = 0;\n  }\n  const node = createSubroutine(ref);\n  subroutines.push(node);\n  return node;\n}\nfunction createAbsentFunction(kind) {\n  if (kind !== AstAbsentFunctionKinds.repeater) {\n    throw new Error(`Unexpected absent function kind \"${kind}\"`);\n  }\n  return {\n    type: AstTypes.AbsentFunction,\n    kind,\n    alternatives: [createAlternative()]\n  };\n}\nfunction createAlternative() {\n  return {\n    type: AstTypes.Alternative,\n    elements: []\n  };\n}\nfunction createAssertion(kind, options) {\n  const negate = !!options?.negate;\n  return {\n    type: AstTypes.Assertion,\n    kind,\n    ...kind === AstAssertionKinds.word_boundary && { negate }\n  };\n}\nfunction createAssertionFromToken({ kind }) {\n  return createAssertion(\n    throwIfNot({\n      \"^\": AstAssertionKinds.line_start,\n      \"$\": AstAssertionKinds.line_end,\n      \"\\\\A\": AstAssertionKinds.string_start,\n      \"\\\\b\": AstAssertionKinds.word_boundary,\n      \"\\\\B\": AstAssertionKinds.word_boundary,\n      \"\\\\G\": AstAssertionKinds.search_start,\n      \"\\\\z\": AstAssertionKinds.string_end,\n      \"\\\\Z\": AstAssertionKinds.string_end_newline\n    }[kind], `Unexpected assertion kind \"${kind}\"`),\n    { negate: kind === r`\\B` }\n  );\n}\nfunction createBackreference(ref, options) {\n  const orphan = !!options?.orphan;\n  return {\n    type: AstTypes.Backreference,\n    ...orphan && { orphan },\n    ref\n  };\n}\nfunction createByGroupKind({ flags, kind, name, negate, number }) {\n  switch (kind) {\n    case TokenGroupKinds.absent_repeater:\n      return createAbsentFunction(AstAbsentFunctionKinds.repeater);\n    case TokenGroupKinds.atomic:\n      return createGroup({ atomic: true });\n    case TokenGroupKinds.capturing:\n      return createCapturingGroup(number, name);\n    case TokenGroupKinds.group:\n      return createGroup({ flags });\n    case TokenGroupKinds.lookahead:\n    case TokenGroupKinds.lookbehind:\n      return createLookaround({\n        behind: kind === TokenGroupKinds.lookbehind,\n        negate\n      });\n    default:\n      throw new Error(`Unexpected group kind \"${kind}\"`);\n  }\n}\nfunction createCapturingGroup(number, name) {\n  const hasName = name !== void 0;\n  if (hasName && !isValidGroupNameOniguruma(name)) {\n    throw new Error(`Group name \"${name}\" invalid in Oniguruma`);\n  }\n  return {\n    type: AstTypes.CapturingGroup,\n    number,\n    ...hasName && { name },\n    alternatives: [createAlternative()]\n  };\n}\nfunction createCharacter(charCode, options) {\n  const opts = {\n    useLastValid: false,\n    ...options\n  };\n  if (charCode > 1114111) {\n    const hex = charCode.toString(16);\n    if (opts.useLastValid) {\n      charCode = 1114111;\n    } else if (charCode > 1310719) {\n      throw new Error(`Invalid code point out of range \"\\\\x{${hex}}\"`);\n    } else {\n      throw new Error(`Invalid code point out of range in JS \"\\\\x{${hex}}\"`);\n    }\n  }\n  return {\n    type: AstTypes.Character,\n    value: charCode\n  };\n}\nfunction createCharacterClass(options) {\n  const opts = {\n    baseOnly: false,\n    negate: false,\n    ...options\n  };\n  return {\n    type: AstTypes.CharacterClass,\n    negate: opts.negate,\n    elements: opts.baseOnly ? [] : [createCharacterClassIntersection()]\n  };\n}\nfunction createCharacterClassIntersection() {\n  return {\n    type: AstTypes.CharacterClassIntersection,\n    classes: [createCharacterClass({ negate: false, baseOnly: true })]\n  };\n}\nfunction createCharacterClassRange(min, max) {\n  if (max.value < min.value) {\n    throw new Error(\"Character class range out of order\");\n  }\n  return {\n    type: AstTypes.CharacterClassRange,\n    min,\n    max\n  };\n}\nfunction createCharacterSet(kind, { negate }) {\n  const node = {\n    type: AstTypes.CharacterSet,\n    kind: throwIfNot(AstCharacterSetKinds[kind], `Unexpected character set kind \"${kind}\"`)\n  };\n  if (kind === TokenCharacterSetKinds.digit || kind === TokenCharacterSetKinds.hex || kind === TokenCharacterSetKinds.space || kind === TokenCharacterSetKinds.word) {\n    node.negate = negate;\n  }\n  return node;\n}\nfunction createDirectiveFromToken({ kind, flags }) {\n  const node = {\n    type: AstTypes.Directive,\n    kind: throwIfNot(AstDirectiveKinds[kind], `Unexpected directive kind \"${kind}\"`)\n  };\n  if (kind === TokenDirectiveKinds.flags) {\n    node.flags = flags;\n  }\n  return node;\n}\nfunction createFlags({ ignoreCase, dotAll, extended, digitIsAscii, spaceIsAscii, wordIsAscii }) {\n  return {\n    type: AstTypes.Flags,\n    ignoreCase,\n    dotAll,\n    extended,\n    digitIsAscii,\n    spaceIsAscii,\n    wordIsAscii\n  };\n}\nfunction createGroup(options) {\n  const atomic2 = options?.atomic;\n  const flags = options?.flags;\n  return {\n    type: AstTypes.Group,\n    ...atomic2 && { atomic: atomic2 },\n    ...flags && { flags },\n    alternatives: [createAlternative()]\n  };\n}\nfunction createLookaround(options) {\n  const opts = {\n    behind: false,\n    negate: false,\n    ...options\n  };\n  return {\n    type: AstTypes.Assertion,\n    kind: opts.behind ? AstAssertionKinds.lookbehind : AstAssertionKinds.lookahead,\n    negate: opts.negate,\n    alternatives: [createAlternative()]\n  };\n}\nfunction createPattern() {\n  return {\n    type: AstTypes.Pattern,\n    alternatives: [createAlternative()]\n  };\n}\nfunction createQuantifier(element, min, max, greedy = true, possessive2 = false) {\n  const node = {\n    type: AstTypes.Quantifier,\n    min,\n    max,\n    greedy,\n    possessive: possessive2,\n    element\n  };\n  if (max < min) {\n    return {\n      ...node,\n      min: max,\n      max: min,\n      possessive: true\n    };\n  }\n  return node;\n}\nfunction createRegex(pattern, flags) {\n  return {\n    type: AstTypes.Regex,\n    pattern,\n    flags\n  };\n}\nfunction createSubroutine(ref) {\n  return {\n    type: AstTypes.Subroutine,\n    ref\n  };\n}\nfunction createUnicodeProperty(value, options) {\n  const opts = {\n    negate: false,\n    skipPropertyNameValidation: false,\n    ...options\n  };\n  return {\n    type: AstTypes.CharacterSet,\n    kind: AstCharacterSetKinds.property,\n    value: opts.skipPropertyNameValidation ? value : getJsUnicodePropertyName(value),\n    negate: opts.negate\n  };\n}\nfunction createVariableLengthCharacterSet(kind) {\n  return {\n    type: AstTypes.VariableLengthCharacterSet,\n    kind: throwIfNot({\n      \"\\\\R\": AstVariableLengthCharacterSetKinds.newline,\n      \"\\\\X\": AstVariableLengthCharacterSetKinds.grapheme\n    }[kind], `Unexpected varcharset kind \"${kind}\"`)\n  };\n}\nfunction getJsUnicodePropertyName(value) {\n  const slugged = slug(value);\n  if (JsUnicodePropertiesOfStringsMap.has(slugged)) {\n    throw new Error(r`Unicode property \"\\p{${value}}\" unsupported in Oniguruma`);\n  }\n  const jsName = JsUnicodePropertiesMap.get(slugged);\n  if (jsName) {\n    return jsName;\n  }\n  return value.trim().replace(/[- _]+/g, \"_\").replace(/[A-Z][a-z]+(?=[A-Z])/g, \"$&_\").replace(/[A-Za-z]+/g, (m) => m[0].toUpperCase() + m.slice(1).toLowerCase());\n}\nfunction getOptimizedGroup(node) {\n  const firstAltFirstEl = node.alternatives[0].elements[0];\n  if (node.type === AstTypes.Group && hasOnlyChild(node, (kid) => kid.type === AstTypes.Group) && !(node.atomic && firstAltFirstEl.flags) && !(node.flags && (firstAltFirstEl.atomic || firstAltFirstEl.flags))) {\n    if (node.atomic) {\n      firstAltFirstEl.atomic = true;\n    } else if (node.flags) {\n      firstAltFirstEl.flags = node.flags;\n    }\n    return firstAltFirstEl;\n  }\n  return node;\n}\nfunction isValidGroupNameOniguruma(name) {\n  return /^[\\p{Alpha}\\p{Pc}][^)]*$/u.test(name);\n}\nfunction optimizeCharacterClassIntersection(intersection) {\n  for (let i = 0; i < intersection.classes.length; i++) {\n    const cc = intersection.classes[i];\n    const firstChild = cc.elements[0];\n    if (cc.elements.length === 1 && firstChild.type === AstTypes.CharacterClass) {\n      intersection.classes[i] = firstChild;\n      firstChild.negate = cc.negate !== firstChild.negate;\n    }\n  }\n}\nfunction throwIfUnclosedCharacterClass(token, firstClassToken) {\n  return throwIfNot(\n    token,\n    // Easier to understand error when applicable\n    `${firstClassToken?.value === 93 ? \"Empty\" : \"Unclosed\"} character class`\n  );\n}\nfunction throwIfUnclosedGroup(token) {\n  return throwIfNot(token, \"Unclosed group\");\n}\n\n// src/transform.js\n\nfunction transform(ast, options) {\n  const opts = {\n    // A couple edge cases exist where options `accuracy` and `bestEffortTarget` are used:\n    // - `VariableLengthCharacterSet` kind `grapheme` (`\\X`): An exact representation would require\n    //   heavy Unicode data; a best-effort approximation requires knowing the target.\n    // - `CharacterSet` kind `posix` with values `graph` and `print`: Their complex Unicode-based\n    //   representations would be hard to change to ASCII-based after the fact in the generator\n    //   based on `target`/`accuracy`, so produce the appropriate structure here.\n    accuracy: \"default\",\n    asciiWordBoundaries: false,\n    avoidSubclass: false,\n    bestEffortTarget: \"ES2025\",\n    ...options\n  };\n  const firstPassState = {\n    accuracy: opts.accuracy,\n    asciiWordBoundaries: opts.asciiWordBoundaries,\n    avoidSubclass: opts.avoidSubclass,\n    flagDirectivesByAlt: /* @__PURE__ */ new Map(),\n    jsGroupNameMap: /* @__PURE__ */ new Map(),\n    minTargetEs2024: isMinTarget(opts.bestEffortTarget, \"ES2024\"),\n    passedLookbehind: false,\n    strategy: null,\n    // Subroutines can appear before the groups they ref, so collect reffed nodes for a second pass \n    subroutineRefMap: /* @__PURE__ */ new Map(),\n    supportedGNodes: /* @__PURE__ */ new Set(),\n    digitIsAscii: ast.flags.digitIsAscii,\n    spaceIsAscii: ast.flags.spaceIsAscii,\n    wordIsAscii: ast.flags.wordIsAscii\n  };\n  traverse({ node: ast }, firstPassState, FirstPassVisitor);\n  const globalFlags = {\n    dotAll: ast.flags.dotAll,\n    ignoreCase: ast.flags.ignoreCase\n  };\n  const secondPassState = {\n    currentFlags: globalFlags,\n    prevFlags: null,\n    globalFlags,\n    groupOriginByCopy: /* @__PURE__ */ new Map(),\n    groupsByName: /* @__PURE__ */ new Map(),\n    multiplexCapturesToLeftByRef: /* @__PURE__ */ new Map(),\n    openRefs: /* @__PURE__ */ new Map(),\n    reffedNodesByReferencer: /* @__PURE__ */ new Map(),\n    subroutineRefMap: firstPassState.subroutineRefMap\n  };\n  traverse({ node: ast }, secondPassState, SecondPassVisitor);\n  const thirdPassState = {\n    groupsByName: secondPassState.groupsByName,\n    highestOrphanBackref: 0,\n    numCapturesToLeft: 0,\n    reffedNodesByReferencer: secondPassState.reffedNodesByReferencer\n  };\n  traverse({ node: ast }, thirdPassState, ThirdPassVisitor);\n  ast._originMap = secondPassState.groupOriginByCopy;\n  ast._strategy = firstPassState.strategy;\n  return ast;\n}\nvar FirstPassVisitor = {\n  AbsentFunction({ node, replaceWith }) {\n    const group = prepContainer(createGroup(), [\n      adoptAndSwapKids(createLookaround({ negate: true }), node.alternatives),\n      createUnicodeProperty(\"Any\")\n    ]);\n    const quantifier = createQuantifier(group, 0, Infinity);\n    group.parent = quantifier;\n    replaceWith(prepContainer(createGroup(), [quantifier]));\n  },\n  Alternative: {\n    enter({ node, parent, key }, { flagDirectivesByAlt }) {\n      const flagDirectives = node.elements.filter((el) => el.kind === AstDirectiveKinds.flags);\n      for (let i = key + 1; i < parent.alternatives.length; i++) {\n        const forwardSiblingAlt = parent.alternatives[i];\n        getOrInsert(flagDirectivesByAlt, forwardSiblingAlt, []).push(...flagDirectives);\n      }\n    },\n    exit({ node }, { flagDirectivesByAlt }) {\n      if (flagDirectivesByAlt.get(node)?.length) {\n        const flags = getCombinedFlagModsFromFlagNodes(flagDirectivesByAlt.get(node));\n        if (flags) {\n          const flagGroup = prepContainer(createGroup({ flags }), node.elements);\n          flagGroup.parent = node;\n          node.elements = [flagGroup];\n        }\n      }\n    }\n  },\n  Assertion({ node, key, container, ast, remove, replaceWith }, state) {\n    const { kind, negate } = node;\n    const { asciiWordBoundaries, avoidSubclass, supportedGNodes, wordIsAscii } = state;\n    if (kind === AstAssertionKinds.line_end) {\n      replaceWith(parseFragment(r`(?=\\z|\\n)`));\n    } else if (kind === AstAssertionKinds.line_start) {\n      replaceWith(parseFragment(r`(?<=\\A|\\n(?!\\z))`, { skipLookbehindValidation: true }));\n    } else if (kind === AstAssertionKinds.lookbehind) {\n      state.passedLookbehind = true;\n    } else if (kind === AstAssertionKinds.search_start) {\n      if (supportedGNodes.has(node)) {\n        ast.flags.sticky = true;\n        remove();\n      } else {\n        const prev = container[key - 1];\n        if (prev && isAlwaysNonZeroLength(prev)) {\n          replaceWith(prepContainer(createLookaround({ negate: true })));\n        } else if (avoidSubclass) {\n          throw new Error(r`Uses \"\\G\" in a way that requires a subclass`);\n        } else {\n          replaceWith(createAssertion(AstAssertionKinds.string_start));\n          state.strategy = \"clip_search\";\n        }\n      }\n    } else if (kind === AstAssertionKinds.string_end_newline) {\n      replaceWith(parseFragment(r`(?=\\n?\\z)`));\n    } else if (kind === AstAssertionKinds.word_boundary && !wordIsAscii && !asciiWordBoundaries) {\n      const b = `(?:(?<=${defaultWordChar})(?!${defaultWordChar})|(?<!${defaultWordChar})(?=${defaultWordChar}))`;\n      const B = `(?:(?<=${defaultWordChar})(?=${defaultWordChar})|(?<!${defaultWordChar})(?!${defaultWordChar}))`;\n      replaceWith(parseFragment(negate ? B : b));\n    }\n  },\n  Backreference({ node }, { jsGroupNameMap }) {\n    let { ref } = node;\n    if (typeof ref === \"string\" && !isValidGroupNameJs(ref)) {\n      ref = getAndStoreJsGroupName(ref, jsGroupNameMap);\n      node.ref = ref;\n    }\n  },\n  CapturingGroup({ node }, { jsGroupNameMap, subroutineRefMap }) {\n    let { name } = node;\n    if (name && !isValidGroupNameJs(name)) {\n      name = getAndStoreJsGroupName(name, jsGroupNameMap);\n      node.name = name;\n    }\n    subroutineRefMap.set(node.number, node);\n    if (name) {\n      subroutineRefMap.set(name, node);\n    }\n  },\n  CharacterSet({ node, replaceWith }, { accuracy, minTargetEs2024, digitIsAscii, spaceIsAscii, wordIsAscii }) {\n    const { kind, negate, value } = node;\n    if (digitIsAscii && (kind === AstCharacterSetKinds.digit || value === \"digit\")) {\n      replaceWith(createCharacterSet(AstCharacterSetKinds.digit, { negate }));\n      return;\n    }\n    if (spaceIsAscii && (kind === AstCharacterSetKinds.space || value === \"space\")) {\n      replaceWith(setNegate(parseFragment(asciiSpaceChar), negate));\n      return;\n    }\n    if (wordIsAscii && (kind === AstCharacterSetKinds.word || value === \"word\")) {\n      replaceWith(createCharacterSet(AstCharacterSetKinds.word, { negate }));\n      return;\n    }\n    if (kind === AstCharacterSetKinds.any) {\n      replaceWith(createUnicodeProperty(\"Any\"));\n    } else if (kind === AstCharacterSetKinds.digit) {\n      replaceWith(createUnicodeProperty(\"Nd\", { negate }));\n    } else if (kind === AstCharacterSetKinds.hex) {\n      replaceWith(createUnicodeProperty(\"AHex\", { negate }));\n    } else if (kind === AstCharacterSetKinds.non_newline) {\n      replaceWith(parseFragment(r`[^\\n]`));\n    } else if (kind === AstCharacterSetKinds.space) {\n      replaceWith(createUnicodeProperty(\"space\", { negate }));\n    } else if (kind === AstCharacterSetKinds.word) {\n      replaceWith(setNegate(parseFragment(defaultWordChar), negate));\n    } else if (kind === AstCharacterSetKinds.property) {\n      if (!JsUnicodeProperties.has(value)) {\n        node.key = \"sc\";\n      }\n    } else if (kind === AstCharacterSetKinds.posix) {\n      if (!minTargetEs2024 && (value === \"graph\" || value === \"print\")) {\n        if (accuracy === \"strict\") {\n          throw new Error(`POSIX class \"${value}\" requires min target ES2024 or non-strict accuracy`);\n        }\n        let ascii = {\n          graph: \"!-~\",\n          print: \" -~\"\n        }[value];\n        if (negate) {\n          ascii = `\\0-${cp(ascii.codePointAt(0) - 1)}${cp(ascii.codePointAt(2) + 1)}-\\u{10FFFF}`;\n        }\n        replaceWith(parseFragment(`[${ascii}]`));\n      } else {\n        replaceWith(setNegate(parseFragment(PosixClassesMap.get(value)), negate));\n      }\n    }\n  },\n  Directive(path, state) {\n    const { node, parent, ast, remove, replaceWith, removeAllPrevSiblings, removeAllNextSiblings } = path;\n    const { kind, flags } = node;\n    if (kind === AstDirectiveKinds.flags) {\n      if (!flags.enable && !flags.disable) {\n        remove();\n      } else {\n        const flagGroup = prepContainer(createGroup({ flags }), removeAllNextSiblings());\n        replaceWith(flagGroup);\n        traverseReplacement(flagGroup, path, state, FirstPassVisitor);\n      }\n    } else if (kind === AstDirectiveKinds.keep) {\n      const firstAltFirstEl = ast.pattern.alternatives[0].elements[0];\n      const hasWrapperGroup = (\n        // Not emulatable if within a `CapturingGroup`\n        hasOnlyChild(ast.pattern, (kid) => kid.type === AstTypes.Group) && firstAltFirstEl.alternatives.length === 1\n      );\n      const topLevel = hasWrapperGroup ? firstAltFirstEl : ast.pattern;\n      if (parent.parent !== topLevel || topLevel.alternatives.length > 1) {\n        throw new Error(r`Uses \"\\K\" in a way that's unsupported`);\n      }\n      replaceWith(prepContainer(createLookaround({ behind: true }), removeAllPrevSiblings()));\n    }\n  },\n  Flags({ node, parent }) {\n    [\n      \"digitIsAscii\",\n      // Flag D\n      \"extended\",\n      // Flag x\n      \"spaceIsAscii\",\n      // Flag S\n      \"wordIsAscii\"\n      // Flag W\n    ].forEach((f) => delete node[f]);\n    Object.assign(node, {\n      // JS flag g; no Onig equiv\n      global: false,\n      // JS flag d; no Onig equiv\n      hasIndices: false,\n      // JS flag m; no Onig equiv but its behavior is always on in Onig. Onig's only line break\n      // char is line feed, unlike JS, so this flag isn't used since it would produce inaccurate\n      // results (also allows `^` and `$` to be used in the generator for string start and end)\n      multiline: false,\n      // JS flag y; no Onig equiv, but used for `\\G` emulation\n      sticky: node.sticky ?? false\n      // Note: Regex+ doesn't allow explicitly adding flags it handles implicitly, so leave out\n      // properties `unicode` (JS flag u) and `unicodeSets` (JS flag v). Keep the existing values\n      // for `ignoreCase` (flag i) and `dotAll` (JS flag s, but Onig flag m)\n    });\n    parent.options = {\n      disable: {\n        // Onig uses different rules for flag x than Regex+, so disable the implicit flag\n        x: true,\n        // Onig has no flag to control \"named capture only\" mode but contextually applies its\n        // behavior when named capturing is used, so disable Regex+'s implicit flag for it\n        n: true\n      },\n      force: {\n        // Always add flag v because we're generating an AST that relies on it (it enables JS\n        // support for Onig features nested classes, set intersection, Unicode properties, etc.).\n        // However, the generator might disable flag v based on its `target` option\n        v: true\n      }\n    };\n  },\n  Group({ node }) {\n    if (!node.flags) {\n      return;\n    }\n    const { enable, disable } = node.flags;\n    enable?.extended && delete enable.extended;\n    disable?.extended && delete disable.extended;\n    enable?.dotAll && disable?.dotAll && delete enable.dotAll;\n    enable?.ignoreCase && disable?.ignoreCase && delete enable.ignoreCase;\n    enable && !Object.keys(enable).length && delete node.flags.enable;\n    disable && !Object.keys(disable).length && delete node.flags.disable;\n    !node.flags.enable && !node.flags.disable && delete node.flags;\n  },\n  Pattern: {\n    enter({ node }, { supportedGNodes }) {\n      const leadingGs = [];\n      let hasAltWithLeadG = false;\n      let hasAltWithoutLeadG = false;\n      for (const alt of node.alternatives) {\n        if (alt.elements.length === 1 && alt.elements[0].kind === AstAssertionKinds.search_start) {\n          alt.elements.pop();\n        } else {\n          const leadingG = getLeadingG(alt.elements);\n          if (leadingG) {\n            hasAltWithLeadG = true;\n            Array.isArray(leadingG) ? leadingGs.push(...leadingG) : leadingGs.push(leadingG);\n          } else {\n            hasAltWithoutLeadG = true;\n          }\n        }\n      }\n      if (hasAltWithLeadG && !hasAltWithoutLeadG) {\n        leadingGs.forEach((g) => supportedGNodes.add(g));\n      }\n    },\n    exit(_, { accuracy, passedLookbehind, strategy }) {\n      if (accuracy === \"strict\" && passedLookbehind && strategy) {\n        throw new Error(r`Uses \"\\G\" in a way that requires non-strict accuracy`);\n      }\n    }\n  },\n  Quantifier({ node }) {\n    if (node.element.type === AstTypes.Quantifier) {\n      const group = prepContainer(createGroup(), [node.element]);\n      group.parent = node;\n      node.element = group;\n    }\n  },\n  Subroutine({ node }, { jsGroupNameMap }) {\n    let { ref } = node;\n    if (typeof ref === \"string\" && !isValidGroupNameJs(ref)) {\n      ref = getAndStoreJsGroupName(ref, jsGroupNameMap);\n      node.ref = ref;\n    }\n  },\n  VariableLengthCharacterSet({ node, replaceWith }, { accuracy, minTargetEs2024 }) {\n    const { kind } = node;\n    if (kind === AstVariableLengthCharacterSetKinds.newline) {\n      replaceWith(parseFragment(\"(?>\\r\\n?|[\\n\\v\\f\\x85\\u2028\\u2029])\"));\n    } else if (kind === AstVariableLengthCharacterSetKinds.grapheme) {\n      if (accuracy === \"strict\") {\n        throw new Error(r`Use of \"\\X\" requires non-strict accuracy`);\n      }\n      const emoji = minTargetEs2024 ? r`\\p{RGI_Emoji}` : (0,emoji_regex_xs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().source.replace(/\\\\u\\{/g, `\\\\x{`);\n      replaceWith(parseFragment(r`(?>\\r\\n|${emoji}|\\P{M}\\p{M}*)`, { skipPropertyNameValidation: true }));\n    } else {\n      throw new Error(`Unexpected varcharset kind \"${kind}\"`);\n    }\n  }\n};\nvar SecondPassVisitor = {\n  Backreference({ node }, { multiplexCapturesToLeftByRef, reffedNodesByReferencer }) {\n    const { orphan, ref } = node;\n    if (!orphan) {\n      reffedNodesByReferencer.set(node, [...multiplexCapturesToLeftByRef.get(ref).map(({ node: node2 }) => node2)]);\n    }\n  },\n  CapturingGroup: {\n    enter({\n      node,\n      replaceWith,\n      skip\n    }, {\n      groupOriginByCopy,\n      groupsByName,\n      multiplexCapturesToLeftByRef,\n      openRefs,\n      reffedNodesByReferencer\n    }) {\n      const origin = groupOriginByCopy.get(node);\n      if (origin && openRefs.has(node.number)) {\n        const recursion2 = createRecursion(node.number);\n        reffedNodesByReferencer.set(recursion2, openRefs.get(node.number));\n        replaceWith(recursion2);\n        skip();\n        return;\n      }\n      openRefs.set(node.number, node);\n      multiplexCapturesToLeftByRef.set(node.number, []);\n      if (node.name) {\n        getOrInsert(multiplexCapturesToLeftByRef, node.name, []);\n      }\n      const multiplexNodes = multiplexCapturesToLeftByRef.get(node.name ?? node.number);\n      for (let i = 0; i < multiplexNodes.length; i++) {\n        const multiplex = multiplexNodes[i];\n        if (\n          // This group is from subroutine expansion, and there's a multiplex value from either the\n          // origin node or a prior subroutine expansion group with the same origin\n          origin === multiplex.node || origin && origin === multiplex.origin || // This group is not from subroutine expansion, and it comes after a subroutine expansion\n          // group that refers to this group\n          node === multiplex.origin\n        ) {\n          multiplexNodes.splice(i, 1);\n          break;\n        }\n      }\n      multiplexCapturesToLeftByRef.get(node.number).push({ node, origin });\n      if (node.name) {\n        multiplexCapturesToLeftByRef.get(node.name).push({ node, origin });\n      }\n      if (node.name) {\n        const groupsWithSameName = getOrInsert(groupsByName, node.name, /* @__PURE__ */ new Map());\n        let hasDuplicateNameToRemove = false;\n        if (origin) {\n          hasDuplicateNameToRemove = true;\n        } else {\n          for (const groupInfo of groupsWithSameName.values()) {\n            if (!groupInfo.hasDuplicateNameToRemove) {\n              hasDuplicateNameToRemove = true;\n              break;\n            }\n          }\n        }\n        groupsByName.get(node.name).set(node, { node, hasDuplicateNameToRemove });\n      }\n    },\n    exit({ node }, { openRefs }) {\n      openRefs.delete(node.number);\n    }\n  },\n  Group: {\n    enter({ node }, state) {\n      state.prevFlags = state.currentFlags;\n      if (node.flags) {\n        state.currentFlags = getNewCurrentFlags(state.currentFlags, node.flags);\n      }\n    },\n    exit(_, state) {\n      state.currentFlags = state.prevFlags;\n    }\n  },\n  Recursion({ node, parent }, { reffedNodesByReferencer }) {\n    const { ref } = node;\n    let reffed = parent;\n    while (reffed = reffed.parent) {\n      if (reffed.type === AstTypes.CapturingGroup && (reffed.name === ref || reffed.number === ref)) {\n        break;\n      }\n    }\n    reffedNodesByReferencer.set(node, reffed);\n  },\n  Subroutine(path, state) {\n    const { node, replaceWith } = path;\n    const { ref } = node;\n    const reffedGroupNode = state.subroutineRefMap.get(ref);\n    const isGlobalRecursion = ref === 0;\n    const expandedSubroutine = isGlobalRecursion ? createRecursion(0) : (\n      // The reffed group might itself contain subroutines, which are expanded during sub-traversal\n      cloneCapturingGroup(reffedGroupNode, state.groupOriginByCopy, null)\n    );\n    let replacement = expandedSubroutine;\n    if (!isGlobalRecursion) {\n      const reffedGroupFlagMods = getCombinedFlagModsFromFlagNodes(getAllParents(reffedGroupNode, (node2) => {\n        return node2.type === AstTypes.Group && !!node2.flags;\n      }));\n      const reffedGroupFlags = reffedGroupFlagMods ? getNewCurrentFlags(state.globalFlags, reffedGroupFlagMods) : state.globalFlags;\n      if (!areFlagsEqual(reffedGroupFlags, state.currentFlags)) {\n        replacement = prepContainer(createGroup({\n          flags: getFlagModsFromFlags(reffedGroupFlags)\n        }), [expandedSubroutine]);\n      }\n    }\n    replaceWith(replacement);\n    if (!isGlobalRecursion) {\n      traverseReplacement(replacement, path, state, SecondPassVisitor);\n    }\n  }\n};\nvar ThirdPassVisitor = {\n  Backreference({ node, replaceWith }, state) {\n    if (node.orphan) {\n      state.highestOrphanBackref = Math.max(state.highestOrphanBackref, node.ref);\n      return;\n    }\n    const reffedNodes = state.reffedNodesByReferencer.get(node);\n    const participants = reffedNodes.filter((reffed) => canParticipateWithNode(reffed, node));\n    if (!participants.length) {\n      replaceWith(prepContainer(createLookaround({ negate: true })));\n    } else if (participants.length > 1) {\n      const alts = participants.map((reffed) => adoptAndSwapKids(\n        createAlternative(),\n        [createBackreference(reffed.number)]\n      ));\n      replaceWith(adoptAndSwapKids(createGroup(), alts));\n    } else {\n      node.ref = participants[0].number;\n    }\n  },\n  CapturingGroup({ node }, state) {\n    node.number = ++state.numCapturesToLeft;\n    if (node.name) {\n      if (state.groupsByName.get(node.name).get(node).hasDuplicateNameToRemove) {\n        delete node.name;\n      }\n    }\n  },\n  Recursion({ node }, state) {\n    if (node.ref === 0) {\n      return;\n    }\n    node.ref = state.reffedNodesByReferencer.get(node).number;\n  },\n  Regex: {\n    exit({ node }, state) {\n      const numCapsNeeded = Math.max(state.highestOrphanBackref - state.numCapturesToLeft, 0);\n      for (let i = 0; i < numCapsNeeded; i++) {\n        const emptyCapture = createCapturingGroup();\n        node.pattern.alternatives.at(-1).elements.push(emptyCapture);\n      }\n    }\n  }\n};\nvar asciiSpaceChar = \"[\t-\\r ]\";\nvar defaultWordChar = r`[\\p{L}\\p{M}\\p{N}\\p{Pc}]`;\nfunction adoptAndSwapKids(parent, kids) {\n  kids.forEach((kid) => kid.parent = parent);\n  parent[getContainerAccessor(parent)] = kids;\n  return parent;\n}\nfunction areFlagsEqual(a, b) {\n  return a.dotAll === b.dotAll && a.ignoreCase === b.ignoreCase;\n}\nfunction canParticipateWithNode(capture, node) {\n  let rightmostPoint = node;\n  do {\n    if (rightmostPoint.type === AstTypes.Pattern) {\n      return false;\n    }\n    if (rightmostPoint.type === AstTypes.Alternative) {\n      continue;\n    }\n    if (rightmostPoint === capture) {\n      return false;\n    }\n    const kidsOfParent = getKids(rightmostPoint.parent);\n    for (const kid of kidsOfParent) {\n      if (kid === rightmostPoint) {\n        break;\n      }\n      if (kid === capture) {\n        return true;\n      }\n      if (hasDescendant(kid, capture)) {\n        return true;\n      }\n    }\n  } while (rightmostPoint = rightmostPoint.parent);\n  throw new Error(\"Unexpected path\");\n}\nfunction cloneCapturingGroup(obj, originMap, up, up2) {\n  const store = Array.isArray(obj) ? [] : {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (key === \"parent\") {\n      store.parent = Array.isArray(up) ? up2 : up;\n    } else if (value && typeof value === \"object\") {\n      store[key] = cloneCapturingGroup(value, originMap, store, up);\n    } else {\n      if (key === \"type\" && value === AstTypes.CapturingGroup) {\n        originMap.set(store, originMap.get(obj) ?? obj);\n      }\n      store[key] = value;\n    }\n  }\n  return store;\n}\nfunction createRecursion(ref) {\n  return {\n    type: AstTypes.Recursion,\n    ref\n  };\n}\nfunction getAllParents(node, filterFn) {\n  const results = [];\n  while (node = node.parent) {\n    if (!filterFn || filterFn(node)) {\n      results.push(node);\n    }\n  }\n  return results;\n}\nfunction getAndStoreJsGroupName(name, map) {\n  if (map.has(name)) {\n    return map.get(name);\n  }\n  const jsName = `$${map.size}_${name.replace(/^[^$_\\p{IDS}]|[^$\\u200C\\u200D\\p{IDC}]/ug, \"_\")}`;\n  map.set(name, jsName);\n  return jsName;\n}\nfunction getContainerAccessor(node) {\n  for (const accessor of [\"alternatives\", \"classes\", \"elements\"]) {\n    if (node[accessor]) {\n      return accessor;\n    }\n  }\n  return null;\n}\nfunction getCombinedFlagModsFromFlagNodes(flagNodes) {\n  const flagProps = [\"dotAll\", \"ignoreCase\"];\n  const combinedFlags = { enable: {}, disable: {} };\n  flagNodes.forEach(({ flags }) => {\n    flagProps.forEach((prop) => {\n      if (flags.enable?.[prop]) {\n        delete combinedFlags.disable[prop];\n        combinedFlags.enable[prop] = true;\n      }\n      if (flags.disable?.[prop]) {\n        combinedFlags.disable[prop] = true;\n      }\n    });\n  });\n  if (!Object.keys(combinedFlags.enable).length) {\n    delete combinedFlags.enable;\n  }\n  if (!Object.keys(combinedFlags.disable).length) {\n    delete combinedFlags.disable;\n  }\n  if (combinedFlags.enable || combinedFlags.disable) {\n    return combinedFlags;\n  }\n  return null;\n}\nfunction getFlagModsFromFlags({ dotAll, ignoreCase }) {\n  const mods = {};\n  if (dotAll || ignoreCase) {\n    mods.enable = {};\n    dotAll && (mods.enable.dotAll = true);\n    ignoreCase && (mods.enable.ignoreCase = true);\n  }\n  if (!dotAll || !ignoreCase) {\n    mods.disable = {};\n    !dotAll && (mods.disable.dotAll = true);\n    !ignoreCase && (mods.disable.ignoreCase = true);\n  }\n  return mods;\n}\nfunction getKids(node) {\n  if (!node) {\n    throw new Error(\"Node expected\");\n  }\n  if (node.type === AstTypes.Quantifier) {\n    return [node.element];\n  }\n  const accessor = getContainerAccessor(node);\n  return accessor && node[accessor];\n}\nfunction getLeadingG(els) {\n  const firstToConsider = els.find((el) => el.kind === AstAssertionKinds.search_start || isLoneGLookaround(el, { negate: false }) || !isAlwaysZeroLength(el));\n  if (!firstToConsider) {\n    return null;\n  }\n  if (firstToConsider.kind === AstAssertionKinds.search_start) {\n    return firstToConsider;\n  }\n  if (isLookaround(firstToConsider)) {\n    return firstToConsider.alternatives[0].elements[0];\n  }\n  if (isConsumptiveGroup(firstToConsider)) {\n    const gNodesForGroup = [];\n    for (const alt of firstToConsider.alternatives) {\n      const leadingG = getLeadingG(alt.elements);\n      if (!leadingG) {\n        return null;\n      }\n      Array.isArray(leadingG) ? gNodesForGroup.push(...leadingG) : gNodesForGroup.push(leadingG);\n    }\n    return gNodesForGroup;\n  }\n  return null;\n}\nfunction hasDescendant(node, descendant) {\n  const kids = getKids(node) ?? [];\n  for (const kid of kids) {\n    if (kid === descendant || hasDescendant(kid, descendant)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isLoneGLookaround(node, options) {\n  const opts = {\n    negate: null,\n    ...options\n  };\n  return isLookaround(node) && (opts.negate === null || node.negate === opts.negate) && hasOnlyChild(node, (kid) => kid.kind === AstAssertionKinds.search_start);\n}\nfunction isValidGroupNameJs(name) {\n  return /^[$_\\p{IDS}][$\\u200C\\u200D\\p{IDC}]*$/u.test(name);\n}\nfunction parseFragment(pattern, options) {\n  const ast = parse(tokenize(pattern), options);\n  const alts = ast.pattern.alternatives;\n  if (alts.length > 1 || alts[0].elements.length > 1) {\n    return adoptAndSwapKids(createGroup(), alts);\n  }\n  return alts[0].elements[0];\n}\nfunction prepContainer(node, kids) {\n  const accessor = getContainerAccessor(node);\n  node[accessor][0].parent = node;\n  if (kids) {\n    adoptAndSwapKids(node[accessor][0], kids);\n  }\n  return node;\n}\nfunction setNegate(node, negate) {\n  node.negate = negate;\n  return node;\n}\nfunction traverseReplacement(replacement, { parent, key, container }, state, visitor) {\n  traverse({\n    // Don't use the `node` from `path`\n    node: replacement,\n    parent,\n    key,\n    container\n  }, state, visitor);\n}\n\n// src/generate.js\nfunction generate(ast, options) {\n  const opts = getOptions(options);\n  const minTargetEs2024 = isMinTarget(opts.target, \"ES2024\");\n  const minTargetEs2025 = isMinTarget(opts.target, \"ES2025\");\n  const recursionLimit = opts.rules.recursionLimit;\n  if (!Number.isInteger(recursionLimit) || recursionLimit < 2 || recursionLimit > 20) {\n    throw new Error(\"Invalid recursionLimit; use 2-20\");\n  }\n  let hasCaseInsensitiveNode = null;\n  let hasCaseSensitiveNode = null;\n  if (!minTargetEs2025) {\n    const iStack = [ast.flags.ignoreCase];\n    traverse({ node: ast }, {\n      getCurrentModI: () => iStack.at(-1),\n      popModI() {\n        iStack.pop();\n      },\n      pushModI(isIOn) {\n        iStack.push(isIOn);\n      },\n      setHasCasedChar() {\n        if (iStack.at(-1)) {\n          hasCaseInsensitiveNode = true;\n        } else {\n          hasCaseSensitiveNode = true;\n        }\n      }\n    }, FlagModifierVisitor);\n  }\n  const appliedGlobalFlags = {\n    dotAll: ast.flags.dotAll,\n    // - Turn global flag i on if a case insensitive node was used and no case sensitive nodes were\n    //   used (to avoid unnecessary node expansion).\n    // - Turn global flag i off if a case sensitive node was used (since case sensitivity can't be\n    //   forced without the use of ES2025 flag groups)\n    ignoreCase: !!((ast.flags.ignoreCase || hasCaseInsensitiveNode) && !hasCaseSensitiveNode)\n  };\n  let lastNode = null;\n  const state = {\n    accuracy: opts.accuracy,\n    appliedGlobalFlags,\n    captureMap: /* @__PURE__ */ new Map(),\n    currentFlags: {\n      dotAll: ast.flags.dotAll,\n      ignoreCase: ast.flags.ignoreCase\n    },\n    inCharClass: false,\n    lastNode,\n    originMap: ast._originMap,\n    recursionLimit,\n    useAppliedIgnoreCase: !!(!minTargetEs2025 && hasCaseInsensitiveNode && hasCaseSensitiveNode),\n    useFlagMods: minTargetEs2025,\n    useFlagV: minTargetEs2024,\n    verbose: opts.verbose\n  };\n  function gen(node) {\n    state.lastNode = lastNode;\n    lastNode = node;\n    switch (node.type) {\n      case AstTypes.Regex:\n        return {\n          pattern: gen(node.pattern),\n          flags: gen(node.flags),\n          options: { ...node.options }\n        };\n      case AstTypes.Alternative:\n        return node.elements.map(gen).join(\"\");\n      case AstTypes.Assertion:\n        return genAssertion(node, state, gen);\n      case AstTypes.Backreference:\n        return genBackreference(node, state);\n      case AstTypes.CapturingGroup:\n        return genCapturingGroup(node, state, gen);\n      case AstTypes.Character:\n        return genCharacter(node, state);\n      case AstTypes.CharacterClass:\n        return genCharacterClass(node, state, gen);\n      case AstTypes.CharacterClassIntersection:\n        if (!state.useFlagV) {\n          throw new Error(\"Use of class intersection requires min target ES2024\");\n        }\n        return node.classes.map(gen).join(\"&&\");\n      case AstTypes.CharacterClassRange:\n        return genCharacterClassRange(node, state);\n      case AstTypes.CharacterSet:\n        return genCharacterSet(node, state);\n      case AstTypes.Flags:\n        return genFlags(node, state);\n      case AstTypes.Group:\n        return genGroup(node, state, gen);\n      case AstTypes.Pattern:\n        return node.alternatives.map(gen).join(\"|\");\n      case AstTypes.Quantifier:\n        return gen(node.element) + getQuantifierStr(node);\n      case AstTypes.Recursion:\n        return genRecursion(node, state);\n      default:\n        throw new Error(`Unexpected node type \"${node.type}\"`);\n    }\n  }\n  const result = gen(ast);\n  if (!minTargetEs2024) {\n    delete result.options.force.v;\n    result.options.disable.v = true;\n    result.options.unicodeSetsPlugin = null;\n  }\n  result._captureTransfers = /* @__PURE__ */ new Map();\n  result._hiddenCaptures = [];\n  state.captureMap.forEach((value, key) => {\n    if (value.hidden) {\n      result._hiddenCaptures.push(key);\n    }\n    if (value.transferTo) {\n      getOrInsert(result._captureTransfers, value.transferTo, []).push(key);\n    }\n  });\n  return result;\n}\nvar FlagModifierVisitor = {\n  AnyGroup: {\n    enter({ node }, state) {\n      const currentModI = state.getCurrentModI();\n      state.pushModI(\n        node.flags ? getNewCurrentFlags({ ignoreCase: currentModI }, node.flags).ignoreCase : currentModI\n      );\n    },\n    exit(_, state) {\n      state.popModI();\n    }\n  },\n  Backreference(_, state) {\n    state.setHasCasedChar();\n  },\n  Character({ node }, state) {\n    if (charHasCase(cp(node.value))) {\n      state.setHasCasedChar();\n    }\n  },\n  CharacterClassRange({ node, skip }, state) {\n    skip();\n    if (getCasesOutsideCharClassRange(node, { firstOnly: true }).length) {\n      state.setHasCasedChar();\n    }\n  },\n  CharacterSet({ node }, state) {\n    if (node.kind === AstCharacterSetKinds.property && UnicodePropertiesWithSpecificCase.has(node.value)) {\n      state.setHasCasedChar();\n    }\n  }\n};\nvar BaseEscapeChars = /* @__PURE__ */ new Set([\n  \"$\",\n  \"(\",\n  \")\",\n  \"*\",\n  \"+\",\n  \".\",\n  \"?\",\n  \"[\",\n  \"\\\\\",\n  \"]\",\n  \"^\",\n  \"{\",\n  \"|\",\n  \"}\"\n]);\nvar CharClassEscapeChars = /* @__PURE__ */ new Set([\n  \"-\",\n  \"\\\\\",\n  \"]\",\n  \"^\",\n  // Literal `[` doesn't require escaping with flag u, but this can help work around regex source\n  // linters and regex syntax processors that expect unescaped `[` to create a nested class\n  \"[\"\n]);\nvar CharClassEscapeCharsFlagV = /* @__PURE__ */ new Set([\n  \"(\",\n  \")\",\n  \"-\",\n  \"/\",\n  \"[\",\n  \"\\\\\",\n  \"]\",\n  \"^\",\n  \"{\",\n  \"|\",\n  \"}\",\n  // Double punctuators; also includes already-listed `-` and `^`\n  \"!\",\n  \"#\",\n  \"$\",\n  \"%\",\n  \"&\",\n  \"*\",\n  \"+\",\n  \",\",\n  \".\",\n  \":\",\n  \";\",\n  \"<\",\n  \"=\",\n  \">\",\n  \"?\",\n  \"@\",\n  \"`\",\n  \"~\"\n]);\nvar CharCodeEscapeMap = /* @__PURE__ */ new Map([\n  [9, r`\\t`],\n  // horizontal tab\n  [10, r`\\n`],\n  // line feed\n  [11, r`\\v`],\n  // vertical tab\n  [12, r`\\f`],\n  // form feed\n  [13, r`\\r`],\n  // carriage return\n  [8232, r`\\u2028`],\n  // line separator\n  [8233, r`\\u2029`],\n  // paragraph separator\n  [65279, r`\\uFEFF`]\n  // ZWNBSP/BOM\n]);\nvar casedRe = /^\\p{Cased}$/u;\nfunction charHasCase(char) {\n  return casedRe.test(char);\n}\nfunction genAssertion(node, _, gen) {\n  const { kind, negate, alternatives } = node;\n  if (isLookaround(node)) {\n    const prefix = `${kind === AstAssertionKinds.lookahead ? \"\" : \"<\"}${negate ? \"!\" : \"=\"}`;\n    return `(?${prefix}${alternatives.map(gen).join(\"|\")})`;\n  }\n  if (kind === AstAssertionKinds.string_end) {\n    return \"$\";\n  }\n  if (kind === AstAssertionKinds.string_start) {\n    return \"^\";\n  }\n  if (kind === AstAssertionKinds.word_boundary) {\n    return negate ? r`\\B` : r`\\b`;\n  }\n  throw new Error(`Unexpected assertion kind \"${kind}\"`);\n}\nfunction genBackreference({ ref }, state) {\n  if (typeof ref !== \"number\") {\n    throw new Error(\"Unexpected named backref in transformed AST\");\n  }\n  if (!state.useFlagMods && state.accuracy === \"strict\" && state.currentFlags.ignoreCase && !state.captureMap.get(ref).ignoreCase) {\n    throw new Error(\"Use of case-insensitive backref to case-sensitive group requires target ES2025 or non-strict accuracy\");\n  }\n  return \"\\\\\" + ref;\n}\nfunction genCapturingGroup(node, state, gen) {\n  const { name, number, alternatives } = node;\n  const data = { ignoreCase: state.currentFlags.ignoreCase };\n  const origin = state.originMap.get(node);\n  if (origin) {\n    data.hidden = true;\n    if (number > origin.number) {\n      data.transferTo = origin.number;\n    }\n  }\n  state.captureMap.set(number, data);\n  return `(${name ? `?<${name}>` : \"\"}${alternatives.map(gen).join(\"|\")})`;\n}\nfunction genCharacter({ value }, state) {\n  const char = cp(value);\n  const escaped = getCharEscape(value, {\n    isAfterBackref: state.lastNode.type === AstTypes.Backreference,\n    inCharClass: state.inCharClass,\n    useFlagV: state.useFlagV\n  });\n  if (escaped !== char) {\n    return escaped;\n  }\n  if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && charHasCase(char)) {\n    const cases = getIgnoreCaseMatchChars(char);\n    return state.inCharClass ? cases.join(\"\") : cases.length > 1 ? `[${cases.join(\"\")}]` : cases[0];\n  }\n  return char;\n}\nfunction genCharacterClass({ negate, parent, elements }, state, gen) {\n  if (envFlags.literalHyphenIncorrectlyCreatesRange && state.useFlagV && elements.some(isLiteralHyphen)) {\n    elements = elements.filter((node) => !isLiteralHyphen(node));\n    elements.push(createCharacter(45));\n  }\n  const genClass = () => `[${negate ? \"^\" : \"\"}${elements.map(gen).join(\"\")}]`;\n  if (!state.inCharClass) {\n    state.inCharClass = true;\n    const result = genClass();\n    state.inCharClass = false;\n    return result;\n  }\n  const firstType = elements[0]?.type;\n  if (!negate && firstType && // Allows many nested classes to work with `target` ES2018 which doesn't support nesting\n  ((!state.useFlagV || !state.verbose) && parent.type === AstTypes.CharacterClass && firstType !== AstTypes.CharacterClassIntersection && !(envFlags.literalHyphenIncorrectlyCreatesRange && state.useFlagV) || !state.verbose && parent.type === AstTypes.CharacterClassIntersection && // JS doesn't allow intersection with union or ranges\n  elements.length === 1 && firstType !== AstTypes.CharacterClass && firstType !== AstTypes.CharacterClassRange)) {\n    return elements.map(gen).join(\"\");\n  }\n  if (!state.useFlagV && parent.type === AstTypes.CharacterClass) {\n    throw new Error(\"Use of nested character class requires min target ES2024\");\n  }\n  return genClass();\n}\nfunction genCharacterClassRange(node, state) {\n  const min = node.min.value;\n  const max = node.max.value;\n  const escOpts = {\n    isAfterBackref: false,\n    inCharClass: true,\n    useFlagV: state.useFlagV\n  };\n  const minStr = getCharEscape(min, escOpts);\n  const maxStr = getCharEscape(max, escOpts);\n  const extraChars = /* @__PURE__ */ new Set();\n  if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase) {\n    const charsOutsideRange = getCasesOutsideCharClassRange(node);\n    const ranges = getCodePointRangesFromChars(charsOutsideRange);\n    ranges.forEach((value) => {\n      extraChars.add(\n        Array.isArray(value) ? `${getCharEscape(value[0], escOpts)}-${getCharEscape(value[1], escOpts)}` : getCharEscape(value, escOpts)\n      );\n    });\n  }\n  return `${minStr}-${maxStr}${[...extraChars].join(\"\")}`;\n}\nfunction genCharacterSet({ kind, negate, value, key }, state) {\n  if (kind === AstCharacterSetKinds.dot) {\n    return state.currentFlags.dotAll ? state.appliedGlobalFlags.dotAll || state.useFlagMods ? \".\" : \"[^]\" : (\n      // Onig's only line break char is line feed, unlike JS\n      r`[^\\n]`\n    );\n  }\n  if (kind === AstCharacterSetKinds.digit) {\n    return negate ? r`\\D` : r`\\d`;\n  }\n  if (kind === AstCharacterSetKinds.property) {\n    if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && UnicodePropertiesWithSpecificCase.has(value)) {\n      throw new Error(`Unicode property \"${value}\" can't be case-insensitive when other chars have specific case`);\n    }\n    return `${negate ? r`\\P` : r`\\p`}{${key ? `${key}=` : \"\"}${value}}`;\n  }\n  if (kind === AstCharacterSetKinds.word) {\n    return negate ? r`\\W` : r`\\w`;\n  }\n  throw new Error(`Unexpected character set kind \"${kind}\"`);\n}\nfunction genFlags(node, state) {\n  return (\n    // The transformer should never turn on the properties for flags d, g, and m since Onig doesn't\n    // have equivs. Flag m is never relied on since Onig uses different line break chars than JS\n    // (node.hasIndices ? 'd' : '') +\n    // (node.global ? 'g' : '') +\n    // (node.multiline ? 'm' : '') +\n    (state.appliedGlobalFlags.ignoreCase ? \"i\" : \"\") + (node.dotAll ? \"s\" : \"\") + (node.sticky ? \"y\" : \"\")\n  );\n}\nfunction genGroup({ atomic: atomic2, flags, parent, alternatives }, state, gen) {\n  const currentFlags = state.currentFlags;\n  if (flags) {\n    state.currentFlags = getNewCurrentFlags(currentFlags, flags);\n  }\n  const contents = alternatives.map(gen).join(\"|\");\n  const result = !state.verbose && alternatives.length === 1 && parent.type !== AstTypes.Quantifier && !atomic2 && (!state.useFlagMods || !flags) ? contents : `(?${getGroupPrefix(atomic2, flags, state.useFlagMods)}${contents})`;\n  state.currentFlags = currentFlags;\n  return result;\n}\nfunction genRecursion({ ref }, state) {\n  const limit = state.recursionLimit;\n  return ref === 0 ? `(?R=${limit})` : r`\\g<${ref}&R=${limit}>`;\n}\nfunction getCasesOutsideCharClassRange(node, options) {\n  const firstOnly = !!options?.firstOnly;\n  const min = node.min.value;\n  const max = node.max.value;\n  const found = [];\n  if (min < 65 && (max === 65535 || max >= 131071) || min === 65536 && max >= 131071) {\n    return found;\n  }\n  for (let i = min; i <= max; i++) {\n    const char = cp(i);\n    if (!charHasCase(char)) {\n      continue;\n    }\n    const charsOutsideRange = getIgnoreCaseMatchChars(char).filter((caseOfChar) => {\n      const num = caseOfChar.codePointAt(0);\n      return num < min || num > max;\n    });\n    if (charsOutsideRange.length) {\n      found.push(...charsOutsideRange);\n      if (firstOnly) {\n        break;\n      }\n    }\n  }\n  return found;\n}\nfunction getCharEscape(codePoint, { isAfterBackref, inCharClass, useFlagV }) {\n  if (CharCodeEscapeMap.has(codePoint)) {\n    return CharCodeEscapeMap.get(codePoint);\n  }\n  if (\n    // Control chars, etc.; condition modeled on the Chrome developer console's display for strings\n    codePoint < 32 || codePoint > 126 && codePoint < 160 || // Unicode planes 4-16; unassigned, special purpose, and private use area\n    codePoint > 262143 || // Avoid corrupting a preceding backref by immediately following it with a literal digit\n    isAfterBackref && isDigitCharCode(codePoint)\n  ) {\n    return codePoint > 255 ? `\\\\u{${codePoint.toString(16).toUpperCase()}}` : `\\\\x${codePoint.toString(16).toUpperCase().padStart(2, \"0\")}`;\n  }\n  const escapeChars = inCharClass ? useFlagV ? CharClassEscapeCharsFlagV : CharClassEscapeChars : BaseEscapeChars;\n  const char = cp(codePoint);\n  return (escapeChars.has(char) ? \"\\\\\" : \"\") + char;\n}\nfunction getCodePointRangesFromChars(chars) {\n  const codePoints = chars.map((char) => char.codePointAt(0)).sort((a, b) => a - b);\n  const values = [];\n  let start = null;\n  for (let i = 0; i < codePoints.length; i++) {\n    if (codePoints[i + 1] === codePoints[i] + 1) {\n      start ??= codePoints[i];\n    } else if (start === null) {\n      values.push(codePoints[i]);\n    } else {\n      values.push([start, codePoints[i]]);\n      start = null;\n    }\n  }\n  return values;\n}\nfunction getGroupPrefix(atomic2, flagMods, useFlagMods) {\n  if (atomic2) {\n    return \">\";\n  }\n  let mods = \"\";\n  if (flagMods && useFlagMods) {\n    const { enable, disable } = flagMods;\n    mods = (enable?.ignoreCase ? \"i\" : \"\") + (enable?.dotAll ? \"s\" : \"\") + (disable ? \"-\" : \"\") + (disable?.ignoreCase ? \"i\" : \"\") + (disable?.dotAll ? \"s\" : \"\");\n  }\n  return `${mods}:`;\n}\nfunction getQuantifierStr({ min, max, greedy, possessive: possessive2 }) {\n  let base;\n  if (!min && max === 1) {\n    base = \"?\";\n  } else if (!min && max === Infinity) {\n    base = \"*\";\n  } else if (min === 1 && max === Infinity) {\n    base = \"+\";\n  } else if (min === max) {\n    base = `{${min}}`;\n  } else {\n    base = `{${min},${max === Infinity ? \"\" : max}}`;\n  }\n  return base + (possessive2 ? \"+\" : greedy ? \"\" : \"?\");\n}\nfunction isDigitCharCode(value) {\n  return value > 47 && value < 58;\n}\nfunction isLiteralHyphen({ type, value }) {\n  return type === AstTypes.Character && value === 45;\n}\n\n// src/subclass.js\nvar EmulatedRegExp = class _EmulatedRegExp extends RegExp {\n  /**\n  @type {Map<number, {\n    hidden?: true;\n    transferTo?: number;\n  }>}\n  */\n  #captureMap = /* @__PURE__ */ new Map();\n  /**\n  @type {RegExp | EmulatedRegExp | null}\n  */\n  #compiled = null;\n  /**\n  @type {string}\n  */\n  #pattern;\n  /**\n  @type {Map<number, string>?}\n  */\n  #nameMap = null;\n  /**\n  @type {string?}\n  */\n  #strategy = null;\n  /**\n  Can be used to serialize the instance.\n  @type {EmulatedRegExpOptions}\n  */\n  rawOptions = {};\n  // Override the getter with one that works with lazy-compiled regexes\n  get source() {\n    return this.#pattern || \"(?:)\";\n  }\n  /**\n  @overload\n  @param {string} pattern\n  @param {string} [flags]\n  @param {EmulatedRegExpOptions} [options]\n  */\n  /**\n  @overload\n  @param {EmulatedRegExp} pattern\n  @param {string} [flags]\n  */\n  constructor(pattern, flags, options) {\n    const lazyCompile = !!options?.lazyCompile;\n    if (pattern instanceof RegExp) {\n      if (options) {\n        throw new Error(\"Cannot provide options when copying a regexp\");\n      }\n      const re = pattern;\n      super(re, flags);\n      this.#pattern = re.source;\n      if (re instanceof _EmulatedRegExp) {\n        this.#captureMap = re.#captureMap;\n        this.#nameMap = re.#nameMap;\n        this.#strategy = re.#strategy;\n        this.rawOptions = re.rawOptions;\n      }\n    } else {\n      const opts = {\n        hiddenCaptures: [],\n        strategy: null,\n        transfers: [],\n        ...options\n      };\n      super(lazyCompile ? \"\" : pattern, flags);\n      this.#pattern = pattern;\n      this.#captureMap = createCaptureMap(opts.hiddenCaptures, opts.transfers);\n      this.#strategy = opts.strategy;\n      this.rawOptions = options ?? {};\n    }\n    if (!lazyCompile) {\n      this.#compiled = this;\n    }\n  }\n  /**\n  Called internally by all String/RegExp methods that use regexes.\n  @override\n  @param {string} str\n  @returns {RegExpExecArray?}\n  */\n  exec(str) {\n    if (!this.#compiled) {\n      const { lazyCompile, ...rest } = this.rawOptions;\n      this.#compiled = new _EmulatedRegExp(this.#pattern, this.flags, rest);\n    }\n    const useLastIndex = this.global || this.sticky;\n    const pos = this.lastIndex;\n    if (this.#strategy === \"clip_search\" && useLastIndex && pos) {\n      this.lastIndex = 0;\n      const match = this.#execCore(str.slice(pos));\n      if (match) {\n        adjustMatchDetailsForOffset(match, pos, str, this.hasIndices);\n        this.lastIndex += pos;\n      }\n      return match;\n    }\n    return this.#execCore(str);\n  }\n  /**\n  Adds support for hidden and transfer captures.\n  @param {string} str\n  @returns\n  */\n  #execCore(str) {\n    this.#compiled.lastIndex = this.lastIndex;\n    const match = super.exec.call(this.#compiled, str);\n    this.lastIndex = this.#compiled.lastIndex;\n    if (!match || !this.#captureMap.size) {\n      return match;\n    }\n    const matchCopy = [...match];\n    match.length = 1;\n    let indicesCopy;\n    if (this.hasIndices) {\n      indicesCopy = [...match.indices];\n      match.indices.length = 1;\n    }\n    const mappedNums = [0];\n    for (let i = 1; i < matchCopy.length; i++) {\n      const { hidden, transferTo } = this.#captureMap.get(i) ?? {};\n      if (hidden) {\n        mappedNums.push(null);\n      } else {\n        mappedNums.push(match.length);\n        match.push(matchCopy[i]);\n        if (this.hasIndices) {\n          match.indices.push(indicesCopy[i]);\n        }\n      }\n      if (transferTo && matchCopy[i] !== void 0) {\n        const to = throwIfNot(mappedNums[transferTo]);\n        match[to] = matchCopy[i];\n        if (this.hasIndices) {\n          match.indices[to] = indicesCopy[i];\n        }\n        if (match.groups) {\n          if (!this.#nameMap) {\n            this.#nameMap = createNameMap(this.source);\n          }\n          const name = this.#nameMap.get(transferTo);\n          if (name) {\n            match.groups[name] = matchCopy[i];\n            if (this.hasIndices) {\n              match.indices.groups[name] = indicesCopy[i];\n            }\n          }\n        }\n      }\n    }\n    return match;\n  }\n};\nfunction adjustMatchDetailsForOffset(match, offset, input, hasIndices) {\n  match.index += offset;\n  match.input = input;\n  if (hasIndices) {\n    const indices = match.indices;\n    for (let i = 0; i < indices.length; i++) {\n      const arr = indices[i];\n      if (arr) {\n        indices[i] = [arr[0] + offset, arr[1] + offset];\n      }\n    }\n    const groupIndices = indices.groups;\n    if (groupIndices) {\n      Object.keys(groupIndices).forEach((key) => {\n        const arr = groupIndices[key];\n        if (arr) {\n          groupIndices[key] = [arr[0] + offset, arr[1] + offset];\n        }\n      });\n    }\n  }\n}\nfunction createCaptureMap(hiddenCaptures, transfers) {\n  const captureMap = /* @__PURE__ */ new Map();\n  for (const num of hiddenCaptures) {\n    captureMap.set(num, {\n      hidden: true\n    });\n  }\n  for (const [to, from] of transfers) {\n    for (const num of from) {\n      getOrInsert(captureMap, num, {}).transferTo = to;\n    }\n  }\n  return captureMap;\n}\nfunction createNameMap(pattern) {\n  const re = /(?<capture>\\((?:\\?<(?![=!])(?<name>[^>]+)>|(?!\\?)))|\\\\?./gsu;\n  const map = /* @__PURE__ */ new Map();\n  let numCharClassesOpen = 0;\n  let numCaptures = 0;\n  let match;\n  while (match = re.exec(pattern)) {\n    const { 0: m, groups: { capture, name } } = match;\n    if (m === \"[\") {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n      if (capture) {\n        numCaptures++;\n        if (name) {\n          map.set(numCaptures, name);\n        }\n      }\n    } else if (m === \"]\") {\n      numCharClassesOpen--;\n    }\n  }\n  return map;\n}\n\n// src/index.js\n\n\nfunction toOnigurumaAst(pattern, options) {\n  const opts = {\n    flags: options?.flags ?? \"\",\n    rules: {\n      captureGroup: false,\n      singleline: false,\n      ...options?.rules\n    }\n  };\n  return parse(tokenize(pattern, opts.flags, opts.rules));\n}\nfunction toRegExp(pattern, options) {\n  const d = toRegExpDetails(pattern, options);\n  if (d.options) {\n    return new EmulatedRegExp(d.pattern, d.flags, d.options);\n  }\n  return new RegExp(d.pattern, d.flags);\n}\nfunction toRegExpDetails(pattern, options) {\n  const opts = getOptions(options);\n  const tokenized = tokenize(pattern, opts.flags, {\n    captureGroup: opts.rules.captureGroup,\n    singleline: opts.rules.singleline\n  });\n  const onigurumaAst = parse(tokenized, {\n    skipBackrefValidation: opts.rules.allowOrphanBackrefs,\n    verbose: opts.verbose\n  });\n  const regexAst = transform(onigurumaAst, {\n    accuracy: opts.accuracy,\n    asciiWordBoundaries: opts.rules.asciiWordBoundaries,\n    avoidSubclass: opts.avoidSubclass,\n    bestEffortTarget: opts.target\n  });\n  const generated = generate(regexAst, opts);\n  const recursionResult = (0,regex_recursion__WEBPACK_IMPORTED_MODULE_2__.recursion)(generated.pattern, {\n    captureTransfers: generated._captureTransfers,\n    hiddenCaptures: generated._hiddenCaptures,\n    mode: \"external\"\n  });\n  const possessiveResult = (0,regex_internals__WEBPACK_IMPORTED_MODULE_1__.possessive)(recursionResult.pattern);\n  const atomicResult = (0,regex_internals__WEBPACK_IMPORTED_MODULE_1__.atomic)(possessiveResult.pattern, {\n    captureTransfers: recursionResult.captureTransfers,\n    hiddenCaptures: recursionResult.hiddenCaptures\n  });\n  const details = {\n    pattern: atomicResult.pattern,\n    flags: `${opts.hasIndices ? \"d\" : \"\"}${opts.global ? \"g\" : \"\"}${generated.flags}${generated.options.disable.v ? \"u\" : \"v\"}`\n  };\n  if (opts.avoidSubclass) {\n    if (opts.lazyCompileLength !== Infinity) {\n      throw new Error(\"Lazy compilation requires subclass\");\n    }\n  } else {\n    const hiddenCaptures = atomicResult.hiddenCaptures.sort((a, b) => a - b);\n    const transfers = Array.from(atomicResult.captureTransfers);\n    const strategy = regexAst._strategy;\n    const lazyCompile = details.pattern.length >= opts.lazyCompileLength;\n    if (hiddenCaptures.length || transfers.length || strategy || lazyCompile) {\n      details.options = {\n        ...hiddenCaptures.length && { hiddenCaptures },\n        ...transfers.length && { transfers },\n        ...strategy && { strategy },\n        ...lazyCompile && { lazyCompile }\n      };\n    }\n  }\n  return details;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vb25pZ3VydW1hLXRvLWVzQDMuMS4xL25vZGVfbW9kdWxlcy9vbmlndXJ1bWEtdG8tZXMvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx1Q0FBdUMsaUJBQWlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGVBQWU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNLEdBQUcsR0FBRztBQUM5QixpQkFBaUIsTUFBTTtBQUN2QixpQkFBaUIsTUFBTTtBQUN2QixrQkFBa0IsR0FBRztBQUNyQixpQkFBaUIsTUFBTTtBQUN2QixpQkFBaUIsR0FBRztBQUNwQixrQkFBa0IsTUFBTSxLQUFLLE1B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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMENBQTBDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNxRDtBQUNUO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwQkFBMEIsMERBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDJCQUEyQiwyREFBVTtBQUNyQyx1QkFBdUIsdURBQU07QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYywyQkFBMkIsRUFBRSx1QkFBdUIsRUFBRSxnQkFBZ0IsRUFBRSx3Q0FBd0M7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCO0FBQ3RELGlDQUFpQyxXQUFXO0FBQzVDLHlCQUF5QixVQUFVO0FBQ25DLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUU7QUFDRiIsInNvdXJjZXMiOlsiL2hvbWUvYnJvbnplL2NvZGluZy9mc2FrbS9ub2RlX21vZHVsZXMvLnBucG0vb25pZ3VydW1hLXRvLWVzQDMuMS4xL25vZGVfbW9kdWxlcy9vbmlndXJ1bWEtdG8tZXMvZGlzdC9lc20vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3V0aWxzLmpzXG52YXIgY3AgPSBTdHJpbmcuZnJvbUNvZGVQb2ludDtcbnZhciByID0gU3RyaW5nLnJhdztcbnZhciBlbnZGbGFncyA9IHtcbiAgZmxhZ0dyb3VwczogKCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgbmV3IFJlZ0V4cChcIig/aTopXCIpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkoKSxcbiAgdW5pY29kZVNldHM6ICgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBSZWdFeHAoXCJcIiwgXCJ2XCIpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSkoKVxufTtcbmVudkZsYWdzLmxpdGVyYWxIeXBoZW5JbmNvcnJlY3RseUNyZWF0ZXNSYW5nZSA9ICgoKSA9PiB7XG4gIGlmICghZW52RmxhZ3MudW5pY29kZVNldHMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICBuZXcgUmVnRXhwKHJgW1xcZFxcLWFdYCwgXCJ2XCIpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59KSgpO1xuZnVuY3Rpb24gZ2V0TmV3Q3VycmVudEZsYWdzKGN1cnJlbnQsIHsgZW5hYmxlLCBkaXNhYmxlIH0pIHtcbiAgcmV0dXJuIHtcbiAgICBkb3RBbGw6ICFkaXNhYmxlPy5kb3RBbGwgJiYgISEoZW5hYmxlPy5kb3RBbGwgfHwgY3VycmVudC5kb3RBbGwpLFxuICAgIGlnbm9yZUNhc2U6ICFkaXNhYmxlPy5pZ25vcmVDYXNlICYmICEhKGVuYWJsZT8uaWdub3JlQ2FzZSB8fCBjdXJyZW50Lmlnbm9yZUNhc2UpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRPckluc2VydChtYXAsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICghbWFwLmhhcyhrZXkpKSB7XG4gICAgbWFwLnNldChrZXksIGRlZmF1bHRWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG1hcC5nZXQoa2V5KTtcbn1cbmZ1bmN0aW9uIGlzTWluVGFyZ2V0KHRhcmdldCwgbWluKSB7XG4gIHJldHVybiBFc1ZlcnNpb25bdGFyZ2V0XSA+PSBFc1ZlcnNpb25bbWluXTtcbn1cbmZ1bmN0aW9uIHRocm93SWZOb3QodmFsdWUsIG1zZykge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyA/PyBcIlZhbHVlIGV4cGVjdGVkXCIpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gc3JjL29wdGlvbnMuanNcbnZhciBFc1ZlcnNpb24gPSB7XG4gIEVTMjAyNTogMjAyNSxcbiAgRVMyMDI0OiAyMDI0LFxuICBFUzIwMTg6IDIwMThcbn07XG52YXIgVGFyZ2V0ID0gKFxuICAvKiogQHR5cGUge2NvbnN0fSAqL1xuICB7XG4gICAgYXV0bzogXCJhdXRvXCIsXG4gICAgRVMyMDI1OiBcIkVTMjAyNVwiLFxuICAgIEVTMjAyNDogXCJFUzIwMjRcIixcbiAgICBFUzIwMTg6IFwiRVMyMDE4XCJcbiAgfVxuKTtcbmZ1bmN0aW9uIGdldE9wdGlvbnMob3B0aW9ucykge1xuICBpZiAob3B0aW9ucz8udGFyZ2V0ICE9PSB2b2lkIDAgJiYgIVRhcmdldFtvcHRpb25zLnRhcmdldF0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdGFyZ2V0IFwiJHtvcHRpb25zLnRhcmdldH1cImApO1xuICB9XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgLy8gU2V0cyB0aGUgbGV2ZWwgb2YgZW11bGF0aW9uIHJpZ29yL3N0cmljdG5lc3MuXG4gICAgYWNjdXJhY3k6IFwiZGVmYXVsdFwiLFxuICAgIC8vIERpc2FibGVzIGFkdmFuY2VkIGVtdWxhdGlvbiB0aGF0IHJlbGllcyBvbiByZXR1cm5pbmcgYSBgUmVnRXhwYCBzdWJjbGFzcywgcmVzdWx0aW5nIGluXG4gICAgLy8gY2VydGFpbiBwYXR0ZXJucyBub3QgYmVpbmcgZW11bGF0YWJsZS5cbiAgICBhdm9pZFN1YmNsYXNzOiBmYWxzZSxcbiAgICAvLyBPbmlndXJ1bWEgZmxhZ3M7IGEgc3RyaW5nIHdpdGggYGlgLCBgbWAsIGB4YCwgYERgLCBgU2AsIGBXYCBpbiBhbnkgb3JkZXIgKGFsbCBvcHRpb25hbCkuXG4gICAgLy8gT25pZ3VydW1hJ3MgYG1gIGlzIGVxdWl2YWxlbnQgdG8gSmF2YVNjcmlwdCdzIGBzYCAoYGRvdEFsbGApLlxuICAgIGZsYWdzOiBcIlwiLFxuICAgIC8vIEluY2x1ZGUgSmF2YVNjcmlwdCBmbGFnIGBnYCAoYGdsb2JhbGApIGluIHRoZSByZXN1bHQuXG4gICAgZ2xvYmFsOiBmYWxzZSxcbiAgICAvLyBJbmNsdWRlIEphdmFTY3JpcHQgZmxhZyBgZGAgKGBoYXNJbmRpY2VzYCkgaW4gdGhlIHJlc3VsdC5cbiAgICBoYXNJbmRpY2VzOiBmYWxzZSxcbiAgICAvLyBEZWxheSByZWdleCBjb25zdHJ1Y3Rpb24gdW50aWwgZmlyc3QgdXNlIGlmIHRoZSB0cmFuc3BpbGVkIHBhdHRlcm4gaXMgYXQgbGVhc3QgdGhpcyBsZW5ndGguXG4gICAgbGF6eUNvbXBpbGVMZW5ndGg6IEluZmluaXR5LFxuICAgIC8vIEphdmFTY3JpcHQgdmVyc2lvbiB1c2VkIGZvciBnZW5lcmF0ZWQgcmVnZXhlcy4gVXNpbmcgYGF1dG9gIGRldGVjdHMgdGhlIGJlc3QgdmFsdWUgYmFzZWQgb25cbiAgICAvLyB5b3VyIGVudmlyb25tZW50LiBMYXRlciB0YXJnZXRzIGFsbG93IGZhc3RlciBwcm9jZXNzaW5nLCBzaW1wbGVyIGdlbmVyYXRlZCBzb3VyY2UsIGFuZFxuICAgIC8vIHN1cHBvcnQgZm9yIGFkZGl0aW9uYWwgZmVhdHVyZXMuXG4gICAgdGFyZ2V0OiBcImF1dG9cIixcbiAgICAvLyBEaXNhYmxlcyBvcHRpbWl6YXRpb25zIHRoYXQgc2ltcGxpZnkgdGhlIHBhdHRlcm4gd2hlbiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgbWVhbmluZy5cbiAgICB2ZXJib3NlOiBmYWxzZSxcbiAgICAuLi5vcHRpb25zLFxuICAgIC8vIEFkdmFuY2VkIG9wdGlvbnMgdGhhdCBvdmVycmlkZSBzdGFuZGFyZCBiZWhhdmlvciwgZXJyb3IgY2hlY2tpbmcsIGFuZCBmbGFncyB3aGVuIGVuYWJsZWQuXG4gICAgcnVsZXM6IHtcbiAgICAgIC8vIFVzZWZ1bCB3aXRoIFRleHRNYXRlIGdyYW1tYXJzIHRoYXQgbWVyZ2UgYmFja3JlZmVyZW5jZXMgYWNyb3NzIHBhdHRlcm5zLlxuICAgICAgYWxsb3dPcnBoYW5CYWNrcmVmczogZmFsc2UsXG4gICAgICAvLyBVc2UgQVNDSUktYmFzZWQgYFxcYmAgYW5kIGBcXEJgLCB3aGljaCBpbmNyZWFzZXMgc2VhcmNoIHBlcmZvcm1hbmNlIG9mIGdlbmVyYXRlZCByZWdleGVzLlxuICAgICAgYXNjaWlXb3JkQm91bmRhcmllczogZmFsc2UsXG4gICAgICAvLyBBbGxvdyB1bm5hbWVkIGNhcHR1cmVzIGFuZCBudW1iZXJlZCBjYWxscyAoYmFja3JlZmVyZW5jZXMgYW5kIHN1YnJvdXRpbmVzKSB3aGVuIHVzaW5nXG4gICAgICAvLyBuYW1lZCBjYXB0dXJlLiBUaGlzIGlzIE9uaWd1cnVtYSBvcHRpb24gYE9OSUdfT1BUSU9OX0NBUFRVUkVfR1JPVVBgOyBvbiBieSBkZWZhdWx0IGluXG4gICAgICAvLyBgdnNjb2RlLW9uaWd1cnVtYWAuXG4gICAgICBjYXB0dXJlR3JvdXA6IGZhbHNlLFxuICAgICAgLy8gQ2hhbmdlIHRoZSByZWN1cnNpb24gZGVwdGggbGltaXQgZnJvbSBPbmlndXJ1bWEncyBgMjBgIHRvIGFuIGludGVnZXIgYDJg4oCTYDIwYC5cbiAgICAgIHJlY3Vyc2lvbkxpbWl0OiAyMCxcbiAgICAgIC8vIGBeYCBhcyBgXFxBYDsgYCRgIGFzYFxcWmAuIEltcHJvdmVzIHNlYXJjaCBwZXJmb3JtYW5jZSBvZiBnZW5lcmF0ZWQgcmVnZXhlcyB3aXRob3V0IGNoYW5naW5nXG4gICAgICAvLyBtZWFuaW5nIGlmIHNlYXJjaGluZyBsaW5lIGJ5IGxpbmUuIFRoaXMgaXMgT25pZ3VydW1hIG9wdGlvbiBgT05JR19PUFRJT05fU0lOR0xFTElORWAuXG4gICAgICBzaW5nbGVsaW5lOiBmYWxzZSxcbiAgICAgIC4uLm9wdGlvbnM/LnJ1bGVzXG4gICAgfVxuICB9O1xuICBpZiAob3B0cy50YXJnZXQgPT09IFwiYXV0b1wiKSB7XG4gICAgb3B0cy50YXJnZXQgPSBlbnZGbGFncy5mbGFnR3JvdXBzID8gXCJFUzIwMjVcIiA6IGVudkZsYWdzLnVuaWNvZGVTZXRzID8gXCJFUzIwMjRcIiA6IFwiRVMyMDE4XCI7XG4gIH1cbiAgcmV0dXJuIG9wdHM7XG59XG5cbi8vIHNyYy91bmljb2RlLmpzXG52YXIgQ2hhcnNXaXRob3V0SWdub3JlQ2FzZUV4cGFuc2lvbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgY3AoMzA0KSxcbiAgLy8gxLBcbiAgY3AoMzA1KVxuICAvLyDEsVxuXSk7XG5mdW5jdGlvbiBnZXRJZ25vcmVDYXNlTWF0Y2hDaGFycyhjaGFyKSB7XG4gIGlmIChDaGFyc1dpdGhvdXRJZ25vcmVDYXNlRXhwYW5zaW9uLmhhcyhjaGFyKSkge1xuICAgIHJldHVybiBbY2hhcl07XG4gIH1cbiAgY29uc3Qgc2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgbG93ZXIgPSBjaGFyLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IHVwcGVyID0gbG93ZXIudG9VcHBlckNhc2UoKTtcbiAgY29uc3QgdGl0bGUgPSBMb3dlclRvVGl0bGVDYXNlTWFwLmdldChsb3dlcik7XG4gIGNvbnN0IGFsdExvd2VyID0gTG93ZXJUb0FsdGVybmF0aXZlTG93ZXJDYXNlTWFwLmdldChsb3dlcik7XG4gIGNvbnN0IGFsdFVwcGVyID0gTG93ZXJUb0FsdGVybmF0aXZlVXBwZXJDYXNlTWFwLmdldChsb3dlcik7XG4gIGlmIChbLi4udXBwZXJdLmxlbmd0aCA9PT0gMSkge1xuICAgIHNldC5hZGQodXBwZXIpO1xuICB9XG4gIGFsdFVwcGVyICYmIHNldC5hZGQoYWx0VXBwZXIpO1xuICB0aXRsZSAmJiBzZXQuYWRkKHRpdGxlKTtcbiAgc2V0LmFkZChsb3dlcik7XG4gIGFsdExvd2VyICYmIHNldC5hZGQoYWx0TG93ZXIpO1xuICByZXR1cm4gWy4uLnNldF07XG59XG52YXIgSnNVbmljb2RlUHJvcGVydGllcyA9IG5ldyBTZXQoXG4gIGBDIE90aGVyXG5DYyBDb250cm9sIGNudHJsXG5DZiBGb3JtYXRcbkNuIFVuYXNzaWduZWRcbkNvIFByaXZhdGVfVXNlXG5DcyBTdXJyb2dhdGVcbkwgTGV0dGVyXG5MQyBDYXNlZF9MZXR0ZXJcbkxsIExvd2VyY2FzZV9MZXR0ZXJcbkxtIE1vZGlmaWVyX0xldHRlclxuTG8gT3RoZXJfTGV0dGVyXG5MdCBUaXRsZWNhc2VfTGV0dGVyXG5MdSBVcHBlcmNhc2VfTGV0dGVyXG5NIE1hcmsgQ29tYmluaW5nX01hcmtcbk1jIFNwYWNpbmdfTWFya1xuTWUgRW5jbG9zaW5nX01hcmtcbk1uIE5vbnNwYWNpbmdfTWFya1xuTiBOdW1iZXJcbk5kIERlY2ltYWxfTnVtYmVyIGRpZ2l0XG5ObCBMZXR0ZXJfTnVtYmVyXG5ObyBPdGhlcl9OdW1iZXJcblAgUHVuY3R1YXRpb24gcHVuY3RcblBjIENvbm5lY3Rvcl9QdW5jdHVhdGlvblxuUGQgRGFzaF9QdW5jdHVhdGlvblxuUGUgQ2xvc2VfUHVuY3R1YXRpb25cblBmIEZpbmFsX1B1bmN0dWF0aW9uXG5QaSBJbml0aWFsX1B1bmN0dWF0aW9uXG5QbyBPdGhlcl9QdW5jdHVhdGlvblxuUHMgT3Blbl9QdW5jdHVhdGlvblxuUyBTeW1ib2xcblNjIEN1cnJlbmN5X1N5bWJvbFxuU2sgTW9kaWZpZXJfU3ltYm9sXG5TbSBNYXRoX1N5bWJvbFxuU28gT3RoZXJfU3ltYm9sXG5aIFNlcGFyYXRvclxuWmwgTGluZV9TZXBhcmF0b3JcblpwIFBhcmFncmFwaF9TZXBhcmF0b3JcblpzIFNwYWNlX1NlcGFyYXRvclxuQVNDSUlcbkFTQ0lJX0hleF9EaWdpdCBBSGV4XG5BbHBoYWJldGljIEFscGhhXG5BbnlcbkFzc2lnbmVkXG5CaWRpX0NvbnRyb2wgQmlkaV9DXG5CaWRpX01pcnJvcmVkIEJpZGlfTVxuQ2FzZV9JZ25vcmFibGUgQ0lcbkNhc2VkXG5DaGFuZ2VzX1doZW5fQ2FzZWZvbGRlZCBDV0NGXG5DaGFuZ2VzX1doZW5fQ2FzZW1hcHBlZCBDV0NNXG5DaGFuZ2VzX1doZW5fTG93ZXJjYXNlZCBDV0xcbkNoYW5nZXNfV2hlbl9ORktDX0Nhc2Vmb2xkZWQgQ1dLQ0ZcbkNoYW5nZXNfV2hlbl9UaXRsZWNhc2VkIENXVFxuQ2hhbmdlc19XaGVuX1VwcGVyY2FzZWQgQ1dVXG5EYXNoXG5EZWZhdWx0X0lnbm9yYWJsZV9Db2RlX1BvaW50IERJXG5EZXByZWNhdGVkIERlcFxuRGlhY3JpdGljIERpYVxuRW1vamlcbkVtb2ppX0NvbXBvbmVudCBFQ29tcFxuRW1vamlfTW9kaWZpZXIgRU1vZFxuRW1vamlfTW9kaWZpZXJfQmFzZSBFQmFzZVxuRW1vamlfUHJlc2VudGF0aW9uIEVQcmVzXG5FeHRlbmRlZF9QaWN0b2dyYXBoaWMgRXh0UGljdFxuRXh0ZW5kZXIgRXh0XG5HcmFwaGVtZV9CYXNlIEdyX0Jhc2VcbkdyYXBoZW1lX0V4dGVuZCBHcl9FeHRcbkhleF9EaWdpdCBIZXhcbklEU19CaW5hcnlfT3BlcmF0b3IgSURTQlxuSURTX1RyaW5hcnlfT3BlcmF0b3IgSURTVFxuSURfQ29udGludWUgSURDXG5JRF9TdGFydCBJRFNcbklkZW9ncmFwaGljIElkZW9cbkpvaW5fQ29udHJvbCBKb2luX0NcbkxvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uIExPRVxuTG93ZXJjYXNlIExvd2VyXG5NYXRoXG5Ob25jaGFyYWN0ZXJfQ29kZV9Qb2ludCBOQ2hhclxuUGF0dGVybl9TeW50YXggUGF0X1N5blxuUGF0dGVybl9XaGl0ZV9TcGFjZSBQYXRfV1NcblF1b3RhdGlvbl9NYXJrIFFNYXJrXG5SYWRpY2FsXG5SZWdpb25hbF9JbmRpY2F0b3IgUklcblNlbnRlbmNlX1Rlcm1pbmFsIFNUZXJtXG5Tb2Z0X0RvdHRlZCBTRFxuVGVybWluYWxfUHVuY3R1YXRpb24gVGVybVxuVW5pZmllZF9JZGVvZ3JhcGggVUlkZW9cblVwcGVyY2FzZSBVcHBlclxuVmFyaWF0aW9uX1NlbGVjdG9yIFZTXG5XaGl0ZV9TcGFjZSBzcGFjZVxuWElEX0NvbnRpbnVlIFhJRENcblhJRF9TdGFydCBYSURTYC5zcGxpdCgvXFxzLylcbik7XG52YXIgSnNVbmljb2RlUHJvcGVydGllc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mb3IgKGNvbnN0IHAgb2YgSnNVbmljb2RlUHJvcGVydGllcykge1xuICBKc1VuaWNvZGVQcm9wZXJ0aWVzTWFwLnNldChzbHVnKHApLCBwKTtcbn1cbnZhciBKc1VuaWNvZGVQcm9wZXJ0aWVzT2ZTdHJpbmdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAvLyBFUzIwMjQgcHJvcGVydGllcyBvZiBzdHJpbmdzOyBub25lIGFyZSBzdXBwb3J0ZWQgYnkgT25pZ3VydW1hXG4gIFwiQmFzaWNfRW1vamlcIixcbiAgXCJFbW9qaV9LZXljYXBfU2VxdWVuY2VcIixcbiAgXCJSR0lfRW1vamlcIixcbiAgXCJSR0lfRW1vamlfRmxhZ19TZXF1ZW5jZVwiLFxuICBcIlJHSV9FbW9qaV9Nb2RpZmllcl9TZXF1ZW5jZVwiLFxuICBcIlJHSV9FbW9qaV9UYWdfU2VxdWVuY2VcIixcbiAgXCJSR0lfRW1vamlfWldKX1NlcXVlbmNlXCJcbl0pO1xudmFyIEpzVW5pY29kZVByb3BlcnRpZXNPZlN0cmluZ3NNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZm9yIChjb25zdCBwIG9mIEpzVW5pY29kZVByb3BlcnRpZXNPZlN0cmluZ3MpIHtcbiAgSnNVbmljb2RlUHJvcGVydGllc09mU3RyaW5nc01hcC5zZXQoc2x1ZyhwKSwgcCk7XG59XG52YXIgTG93ZXJUb0FsdGVybmF0aXZlTG93ZXJDYXNlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbXCJzXCIsIGNwKDM4MyldLFxuICAvLyBzLCDFv1xuICBbY3AoMzgzKSwgXCJzXCJdXG4gIC8vIMW/LCBzXG5dKTtcbnZhciBMb3dlclRvQWx0ZXJuYXRpdmVVcHBlckNhc2VNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFtjcCgyMjMpLCBjcCg3ODM4KV0sXG4gIC8vIMOfLCDhup5cbiAgW2NwKDEwNyksIGNwKDg0OTApXSxcbiAgLy8gaywg4oSqIChLZWx2aW4pXG4gIFtjcCgyMjkpLCBjcCg4NDkxKV0sXG4gIC8vIMOlLCDihKsgKEFuZ3N0cm9tKVxuICBbY3AoOTY5KSwgY3AoODQ4NildXG4gIC8vIM+JLCDihKYgKE9obSlcbl0pO1xudmFyIExvd2VyVG9UaXRsZUNhc2VNYXAgPSBuZXcgTWFwKFtcbiAgdGl0bGVFbnRyeSg0NTMpLFxuICB0aXRsZUVudHJ5KDQ1NiksXG4gIHRpdGxlRW50cnkoNDU5KSxcbiAgdGl0bGVFbnRyeSg0OTgpLFxuICAuLi50aXRsZVJhbmdlKDgwNzIsIDgwNzkpLFxuICAuLi50aXRsZVJhbmdlKDgwODgsIDgwOTUpLFxuICAuLi50aXRsZVJhbmdlKDgxMDQsIDgxMTEpLFxuICB0aXRsZUVudHJ5KDgxMjQpLFxuICB0aXRsZUVudHJ5KDgxNDApLFxuICB0aXRsZUVudHJ5KDgxODgpXG5dKTtcbnZhciBQb3NpeENsYXNzZXNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFtcImFsbnVtXCIsIHJgW1xccHtBbHBoYX1cXHB7TmR9XWBdLFxuICBbXCJhbHBoYVwiLCByYFxccHtBbHBoYX1gXSxcbiAgW1wiYXNjaWlcIiwgcmBcXHB7QVNDSUl9YF0sXG4gIFtcImJsYW5rXCIsIHJgW1xccHtac31cXHRdYF0sXG4gIFtcImNudHJsXCIsIHJgXFxwe2NudHJsfWBdLFxuICBbXCJkaWdpdFwiLCByYFxccHtOZH1gXSxcbiAgW1wiZ3JhcGhcIiwgcmBbXFxQe3NwYWNlfSYmXFxQe2NudHJsfSYmXFxQe0NufSYmXFxQe0NzfV1gXSxcbiAgW1wibG93ZXJcIiwgcmBcXHB7TG93ZXJ9YF0sXG4gIFtcInByaW50XCIsIHJgW1tcXFB7c3BhY2V9JiZcXFB7Y250cmx9JiZcXFB7Q259JiZcXFB7Q3N9XVxccHtac31dYF0sXG4gIFtcInB1bmN0XCIsIHJgW1xccHtQfVxccHtTfV1gXSxcbiAgLy8gTmV3IHZhbHVlIGZyb20gT25pZ3VydW1hIDYuOS45XG4gIFtcInNwYWNlXCIsIHJgXFxwe3NwYWNlfWBdLFxuICBbXCJ1cHBlclwiLCByYFxccHtVcHBlcn1gXSxcbiAgW1wid29yZFwiLCByYFtcXHB7QWxwaGF9XFxwe019XFxwe05kfVxccHtQY31dYF0sXG4gIFtcInhkaWdpdFwiLCByYFxccHtBSGV4fWBdXG5dKTtcbnZhciBQb3NpeFByb3BlcnRpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiYWxudW1cIixcbiAgXCJibGFua1wiLFxuICBcImdyYXBoXCIsXG4gIFwicHJpbnRcIixcbiAgXCJ3b3JkXCIsXG4gIFwieGRpZ2l0XCJcbiAgLy8gVGhlIGZvbGxvd2luZyBhcmUgYXZhaWxhYmxlIHdpdGggdGhlIHNhbWUgbmFtZSBpbiBKUyAoc2VlIGBKc1VuaWNvZGVQcm9wZXJ0aWVzYCksIHNvIGNhbiBiZVxuICAvLyBoYW5kbGVkIGFzIHN0YW5kYXJkIFVuaWNvZGUgcHJvcGVydGllc1xuICAvLyAnYWxwaGEnLCAvLyAoSlM6IEFscGhhKVxuICAvLyAnYXNjaWknLCAvLyAoSlM6IEFTQ0lJKVxuICAvLyAnY250cmwnLCAvLyAoSlM6IGNudHJsKVxuICAvLyAnZGlnaXQnLCAvLyAoSlM6IGRpZ2l0KVxuICAvLyAnbG93ZXInLCAvLyAoSlM6IExvd2VyKVxuICAvLyAncHVuY3QnLCAvLyAoSlM6IHB1bmN0KVxuICAvLyAnc3BhY2UnLCAvLyAoSlM6IHNwYWNlKVxuICAvLyAndXBwZXInLCAvLyAoSlM6IFVwcGVyKVxuXSk7XG5mdW5jdGlvbiByYW5nZShzdGFydCwgZW5kKSB7XG4gIGNvbnN0IHJhbmdlMiA9IFtdO1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICByYW5nZTIucHVzaChpKTtcbiAgfVxuICByZXR1cm4gcmFuZ2UyO1xufVxuZnVuY3Rpb24gc2x1ZyhuYW1lKSB7XG4gIHJldHVybiBuYW1lLnJlcGxhY2UoL1stIF9dKy9nLCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gdGl0bGVFbnRyeShjb2RlUG9pbnQpIHtcbiAgY29uc3QgY2hhciA9IGNwKGNvZGVQb2ludCk7XG4gIHJldHVybiBbY2hhci50b0xvd2VyQ2FzZSgpLCBjaGFyXTtcbn1cbmZ1bmN0aW9uIHRpdGxlUmFuZ2Uoc3RhcnQsIGVuZCkge1xuICByZXR1cm4gcmFuZ2Uoc3RhcnQsIGVuZCkubWFwKChjb2RlUG9pbnQpID0+IHRpdGxlRW50cnkoY29kZVBvaW50KSk7XG59XG52YXIgVW5pY29kZVByb3BlcnRpZXNXaXRoU3BlY2lmaWNDYXNlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcIkxvd2VyXCIsXG4gIFwiTG93ZXJjYXNlXCIsXG4gIFwiVXBwZXJcIixcbiAgXCJVcHBlcmNhc2VcIixcbiAgXCJMbFwiLFxuICBcIkxvd2VyY2FzZV9MZXR0ZXJcIixcbiAgXCJMdFwiLFxuICBcIlRpdGxlY2FzZV9MZXR0ZXJcIixcbiAgXCJMdVwiLFxuICBcIlVwcGVyY2FzZV9MZXR0ZXJcIlxuICAvLyBUaGUgYENoYW5nZXNfV2hlbl8qYCBwcm9wZXJ0aWVzIChhbmQgdGhlaXIgYWxpYXNlcykgY291bGQgYmUgaW5jbHVkZWQsIGJ1dCB0aGV5J3JlIHZlcnkgcmFyZS5cbiAgLy8gU29tZSBvdGhlciBwcm9wZXJ0aWVzIGluY2x1ZGUgYSBoYW5kZnVsIG9mIGNoYXJzIHdpdGggc3BlY2lmaWMgY2FzZXMgb25seSwgYnV0IHRoZXNlIGNoYXJzIGFyZVxuICAvLyBnZW5lcmFsbHkgZXh0cmVtZSBlZGdlIGNhc2VzIGFuZCB1c2luZyBzdWNoIHByb3BlcnRpZXMgY2FzZSBpbnNlbnNpdGl2ZWx5IGdlbmVyYWxseSBwcm9kdWNlc1xuICAvLyB1bmRlc2lyZWQgYmVoYXZpb3IgYW55d2F5XG5dKTtcblxuLy8gc3JjL3Rva2VuaXplLmpzXG52YXIgVG9rZW5UeXBlcyA9IChcbiAgLyoqIEB0eXBlIHtjb25zdH0gKi9cbiAge1xuICAgIEFsdGVybmF0b3I6IFwiQWx0ZXJuYXRvclwiLFxuICAgIEFzc2VydGlvbjogXCJBc3NlcnRpb25cIixcbiAgICBCYWNrcmVmZXJlbmNlOiBcIkJhY2tyZWZlcmVuY2VcIixcbiAgICBDaGFyYWN0ZXI6IFwiQ2hhcmFjdGVyXCIsXG4gICAgQ2hhcmFjdGVyQ2xhc3NDbG9zZTogXCJDaGFyYWN0ZXJDbGFzc0Nsb3NlXCIsXG4gICAgQ2hhcmFjdGVyQ2xhc3NIeXBoZW46IFwiQ2hhcmFjdGVyQ2xhc3NIeXBoZW5cIixcbiAgICBDaGFyYWN0ZXJDbGFzc0ludGVyc2VjdG9yOiBcIkNoYXJhY3RlckNsYXNzSW50ZXJzZWN0b3JcIixcbiAgICBDaGFyYWN0ZXJDbGFzc09wZW46IFwiQ2hhcmFjdGVyQ2xhc3NPcGVuXCIsXG4gICAgQ2hhcmFjdGVyU2V0OiBcIkNoYXJhY3RlclNldFwiLFxuICAgIERpcmVjdGl2ZTogXCJEaXJlY3RpdmVcIixcbiAgICBHcm91cENsb3NlOiBcIkdyb3VwQ2xvc2VcIixcbiAgICBHcm91cE9wZW46IFwiR3JvdXBPcGVuXCIsXG4gICAgU3Vicm91dGluZTogXCJTdWJyb3V0aW5lXCIsXG4gICAgUXVhbnRpZmllcjogXCJRdWFudGlmaWVyXCIsXG4gICAgLy8gVGhlc2UgYXJlbid0IGFsbG93ZWQgaW4gY2hhciBjbGFzc2VzLCBzbyB0aGV5IGFyZW4ndCBlcXVpdmFsZW50IHRvIEpTIGBbXFxxe31dYFxuICAgIFZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0OiBcIlZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0XCIsXG4gICAgLy8gSW50ZXJtZWRpYXRlIHJlcHJlc2VudGF0aW9uIG5vdCBpbmNsdWRlZCBpbiByZXN1bHRzXG4gICAgRXNjYXBlZE51bWJlcjogXCJFc2NhcGVkTnVtYmVyXCJcbiAgfVxuKTtcbnZhciBUb2tlbkNoYXJhY3RlclNldEtpbmRzID0ge1xuICBhbnk6IFwiYW55XCIsXG4gIGRpZ2l0OiBcImRpZ2l0XCIsXG4gIGRvdDogXCJkb3RcIixcbiAgaGV4OiBcImhleFwiLFxuICBub25fbmV3bGluZTogXCJub25fbmV3bGluZVwiLFxuICBwb3NpeDogXCJwb3NpeFwiLFxuICBwcm9wZXJ0eTogXCJwcm9wZXJ0eVwiLFxuICBzcGFjZTogXCJzcGFjZVwiLFxuICB3b3JkOiBcIndvcmRcIlxufTtcbnZhciBUb2tlbkRpcmVjdGl2ZUtpbmRzID0ge1xuICBmbGFnczogXCJmbGFnc1wiLFxuICBrZWVwOiBcImtlZXBcIlxufTtcbnZhciBUb2tlbkdyb3VwS2luZHMgPSB7XG4gIGFic2VudF9yZXBlYXRlcjogXCJhYnNlbnRfcmVwZWF0ZXJcIixcbiAgYXRvbWljOiBcImF0b21pY1wiLFxuICBjYXB0dXJpbmc6IFwiY2FwdHVyaW5nXCIsXG4gIGdyb3VwOiBcImdyb3VwXCIsXG4gIGxvb2thaGVhZDogXCJsb29rYWhlYWRcIixcbiAgbG9va2JlaGluZDogXCJsb29rYmVoaW5kXCJcbn07XG52YXIgRXNjYXBlQ2hhckNvZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbXCJhXCIsIDddLFxuICAvLyBhbGVydC9iZWxsIChOb3QgYXZhaWxhYmxlIGluIEpTKVxuICBbXCJiXCIsIDhdLFxuICAvLyBiYWNrc3BhY2UgKG9ubHkgaW4gY2hhciBjbGFzc2VzKVxuICBbXCJlXCIsIDI3XSxcbiAgLy8gZXNjYXBlIChOb3QgYXZhaWxhYmxlIGluIEpTKVxuICBbXCJmXCIsIDEyXSxcbiAgLy8gZm9ybSBmZWVkXG4gIFtcIm5cIiwgMTBdLFxuICAvLyBsaW5lIGZlZWRcbiAgW1wiclwiLCAxM10sXG4gIC8vIGNhcnJpYWdlIHJldHVyblxuICBbXCJ0XCIsIDldLFxuICAvLyBob3Jpem9udGFsIHRhYlxuICBbXCJ2XCIsIDExXVxuICAvLyB2ZXJ0aWNhbCB0YWJcbl0pO1xudmFyIGNoYXJDbGFzc09wZW5QYXR0ZXJuID0gcmBcXFtcXF4/YDtcbnZhciBzaGFyZWRFc2NhcGVzUGF0dGVybiA9IGAkey8vIENvbnRyb2wgY2hhclxuXCJjLj8gfCBDKD86LS4/KT9cIn18JHsvLyBVbmljb2RlIHByb3BlcnR5OyBPbmlnIGNvbnNpZGVycyBgXFxwYCBhbiBpZGVudGl0eSBlc2NhcGUsIGJ1dCBlLmcuIGBcXHB7YCwgYFxccHsgXkx9YCwgYW5kXG4vLyBgXFxwe2djPUx9YCBhcmUgaW52YWxpZFxucmBbcFBdXFx7KD86XFxeP1stXFx4MjBfXSpbQS1aYS16XVstXFx4MjBcXHddKlxcfSk/YH18JHsvLyBIZXggZW5jb2RlZCBieXRlIHNlcXVlbmNlOyBhdHRlbXB0IG1hdGNoIGJlZm9yZSBvdGhlciBgXFx4Tk5gIGhleCBjaGFyXG5yYHhbODlBLUZhLWZdXFxwe0FIZXh9KD86XFxcXHhbODlBLUZhLWZdXFxwe0FIZXh9KSpgfXwkey8vIEhleCBjaGFyXG5yYHUoPzpcXHB7QUhleH17NH0pPyB8IHhcXHtbXlxcfV0qXFx9PyB8IHhcXHB7QUhleH17MCwyfWB9fCR7Ly8gRW5jbG9zZWQgb2N0YWwgY29kZSBwb2ludFxucmBvXFx7W15cXH1dKlxcfT9gfXwkey8vIEVzY2FwZWQgbnVtYmVyXG5yYFxcZHsxLDN9YH1gO1xudmFyIHF1YW50aWZpZXJSZSA9IC9bPyorXVs/K10/fFxceyg/OlxcZCsoPzosXFxkKik/fCxcXGQrKVxcfVxcPz8vO1xudmFyIHRva2VuUmUgPSBuZXcgUmVnRXhwKHJgXG4gIFxcXFwgKD86XG4gICAgJHtzaGFyZWRFc2NhcGVzUGF0dGVybn1cbiAgICB8IFtna108W14+XSo+P1xuICAgIHwgW2drXSdbXiddKic/XG4gICAgfCAuXG4gIClcbiAgfCBcXCggKD86XG4gICAgXFw/ICg/OlxuICAgICAgWzo9IT4oe11cbiAgICAgIHwgPFs9IV1cbiAgICAgIHwgPFtePl0qPlxuICAgICAgfCAnW14nXSonXG4gICAgICB8IH5cXHw/XG4gICAgICB8ICMoPzpbXilcXFxcXXxcXFxcLj8pKlxuICAgICAgfCBbXjopXSpbOildXG4gICAgKT9cbiAgICB8IFxcKlxuICApP1xuICB8ICR7cXVhbnRpZmllclJlLnNvdXJjZX1cbiAgfCAke2NoYXJDbGFzc09wZW5QYXR0ZXJufVxuICB8IC5cbmAucmVwbGFjZSgvXFxzKy9nLCBcIlwiKSwgXCJnc3VcIik7XG52YXIgY2hhckNsYXNzVG9rZW5SZSA9IG5ldyBSZWdFeHAocmBcbiAgXFxcXCAoPzpcbiAgICAke3NoYXJlZEVzY2FwZXNQYXR0ZXJufVxuICAgIHwgLlxuICApXG4gIHwgXFxbOig/OlxcXj9cXHB7QWxwaGF9K3xcXF4pOlxcXVxuICB8ICR7Y2hhckNsYXNzT3BlblBhdHRlcm59XG4gIHwgJiZcbiAgfCAuXG5gLnJlcGxhY2UoL1xccysvZywgXCJcIiksIFwiZ3N1XCIpO1xuZnVuY3Rpb24gdG9rZW5pemUocGF0dGVybiwgZmxhZ3MgPSBcIlwiLCBydWxlcykge1xuICBydWxlcyA9IHtcbiAgICAvLyBgT05JR19PUFRJT05fQ0FQVFVSRV9HUk9VUGBcbiAgICBjYXB0dXJlR3JvdXA6IGZhbHNlLFxuICAgIC8vIGBPTklHX09QVElPTl9TSU5HTEVMSU5FYFxuICAgIHNpbmdsZWxpbmU6IGZhbHNlLFxuICAgIC4uLnJ1bGVzXG4gIH07XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmluZyBleHBlY3RlZCBhcyBwYXR0ZXJuXCIpO1xuICB9XG4gIGlmICghL15baW14RFNXXSokLy50ZXN0KGZsYWdzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmxhZ3MgXCIke2ZsYWdzfVwiIGluY2x1ZGVzIHVuc3VwcG9ydGVkIHZhbHVlYCk7XG4gIH1cbiAgY29uc3QgZXh0ZW5kZWQgPSBmbGFncy5pbmNsdWRlcyhcInhcIik7XG4gIGNvbnN0IHhTdGFjayA9IFtleHRlbmRlZF07XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgY2FwdHVyZUdyb3VwOiBydWxlcy5jYXB0dXJlR3JvdXAsXG4gICAgZ2V0Q3VycmVudE1vZFg6ICgpID0+IHhTdGFjay5hdCgtMSksXG4gICAgbnVtT3Blbkdyb3VwczogMCxcbiAgICBwb3BNb2RYKCkge1xuICAgICAgeFN0YWNrLnBvcCgpO1xuICAgIH0sXG4gICAgcHVzaE1vZFgoaXNYT24pIHtcbiAgICAgIHhTdGFjay5wdXNoKGlzWE9uKTtcbiAgICB9LFxuICAgIHJlcGxhY2VDdXJyZW50TW9kWChpc1hPbikge1xuICAgICAgeFN0YWNrW3hTdGFjay5sZW5ndGggLSAxXSA9IGlzWE9uO1xuICAgIH0sXG4gICAgc2luZ2xlbGluZTogcnVsZXMuc2luZ2xlbGluZVxuICB9O1xuICBsZXQgdG9rZW5zID0gW107XG4gIGxldCBtYXRjaDtcbiAgdG9rZW5SZS5sYXN0SW5kZXggPSAwO1xuICB3aGlsZSAobWF0Y2ggPSB0b2tlblJlLmV4ZWMocGF0dGVybikpIHtcbiAgICBjb25zdCByZXN1bHQgPSBnZXRUb2tlbldpdGhEZXRhaWxzKGNvbnRleHQsIHBhdHRlcm4sIG1hdGNoWzBdLCB0b2tlblJlLmxhc3RJbmRleCk7XG4gICAgaWYgKHJlc3VsdC50b2tlbnMpIHtcbiAgICAgIHRva2Vucy5wdXNoKC4uLnJlc3VsdC50b2tlbnMpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0LnRva2VuKSB7XG4gICAgICB0b2tlbnMucHVzaChyZXN1bHQudG9rZW4pO1xuICAgIH1cbiAgICBpZiAocmVzdWx0Lmxhc3RJbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgICB0b2tlblJlLmxhc3RJbmRleCA9IHJlc3VsdC5sYXN0SW5kZXg7XG4gICAgfVxuICB9XG4gIGNvbnN0IHBvdGVudGlhbFVubmFtZWRDYXB0dXJlVG9rZW5zID0gW107XG4gIGxldCBudW1OYW1lZEFuZE9wdEluVW5uYW1lZENhcHR1cmVzID0gMDtcbiAgdG9rZW5zLmZvckVhY2goKHQpID0+IHtcbiAgICBpZiAodC50eXBlID09PSBUb2tlblR5cGVzLkdyb3VwT3Blbikge1xuICAgICAgaWYgKHQua2luZCA9PT0gVG9rZW5Hcm91cEtpbmRzLmNhcHR1cmluZykge1xuICAgICAgICB0Lm51bWJlciA9ICsrbnVtTmFtZWRBbmRPcHRJblVubmFtZWRDYXB0dXJlcztcbiAgICAgIH0gZWxzZSBpZiAodC5yYXcgPT09IFwiKFwiKSB7XG4gICAgICAgIHBvdGVudGlhbFVubmFtZWRDYXB0dXJlVG9rZW5zLnB1c2godCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgaWYgKCFudW1OYW1lZEFuZE9wdEluVW5uYW1lZENhcHR1cmVzKSB7XG4gICAgcG90ZW50aWFsVW5uYW1lZENhcHR1cmVUb2tlbnMuZm9yRWFjaCgodCwgaSkgPT4ge1xuICAgICAgdC5raW5kID0gVG9rZW5Hcm91cEtpbmRzLmNhcHR1cmluZztcbiAgICAgIHQubnVtYmVyID0gaSArIDE7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbnVtQ2FwdHVyZXMgPSBudW1OYW1lZEFuZE9wdEluVW5uYW1lZENhcHR1cmVzIHx8IHBvdGVudGlhbFVubmFtZWRDYXB0dXJlVG9rZW5zLmxlbmd0aDtcbiAgdG9rZW5zID0gdG9rZW5zLm1hcChcbiAgICAodCkgPT4gdC50eXBlID09PSBUb2tlblR5cGVzLkVzY2FwZWROdW1iZXIgPyBzcGxpdEVzY2FwZWROdW1Ub2tlbih0LCBudW1DYXB0dXJlcykgOiB0XG4gICkuZmxhdCgpO1xuICByZXR1cm4ge1xuICAgIHRva2VucyxcbiAgICBmbGFnczoge1xuICAgICAgaWdub3JlQ2FzZTogZmxhZ3MuaW5jbHVkZXMoXCJpXCIpLFxuICAgICAgLy8gRmxhZyBtIGlzIGNhbGxlZCBgbXVsdGlsaW5lYCBpbiBPbmlnLCBidXQgdGhhdCBoYXMgYSBkaWZmZXJlbnQgbWVhbmluZyBpbiBKUy4gT25pZyBmbGFnIG1cbiAgICAgIC8vIGlzIGVxdWl2YWxlbnQgdG8gSlMgZmxhZyBzXG4gICAgICBkb3RBbGw6IGZsYWdzLmluY2x1ZGVzKFwibVwiKSxcbiAgICAgIC8vIEZsYWcgeCBpcyBmdWxseSBoYW5kbGVkIGR1cmluZyB0b2tlbml6YXRpb25cbiAgICAgIGV4dGVuZGVkLFxuICAgICAgLy8gRmxhZ3MgRCwgUywgVyBhcmUgY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGFzIHRvcC1sZXZlbCBmbGFnc1xuICAgICAgZGlnaXRJc0FzY2lpOiBmbGFncy5pbmNsdWRlcyhcIkRcIiksXG4gICAgICBzcGFjZUlzQXNjaWk6IGZsYWdzLmluY2x1ZGVzKFwiU1wiKSxcbiAgICAgIHdvcmRJc0FzY2lpOiBmbGFncy5pbmNsdWRlcyhcIldcIilcbiAgICB9LFxuICAgIHJ1bGVzXG4gIH07XG59XG5mdW5jdGlvbiBnZXRUb2tlbldpdGhEZXRhaWxzKGNvbnRleHQsIHBhdHRlcm4sIG0sIGxhc3RJbmRleCkge1xuICBjb25zdCBbbTAsIG0xXSA9IG07XG4gIGlmIChtMCA9PT0gXCJbXCIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBnZXRBbGxUb2tlbnNGb3JDaGFyQ2xhc3MocGF0dGVybiwgbSwgbGFzdEluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gQXJyYXkgb2YgYWxsIG9mIHRoZSBjaGFyIGNsYXNzJ3MgdG9rZW5zXG4gICAgICB0b2tlbnM6IHJlc3VsdC50b2tlbnMsXG4gICAgICAvLyBKdW1wIGZvcndhcmQgdG8gdGhlIGVuZCBvZiB0aGUgY2hhciBjbGFzc1xuICAgICAgbGFzdEluZGV4OiByZXN1bHQubGFzdEluZGV4XG4gICAgfTtcbiAgfVxuICBpZiAobTAgPT09IFwiXFxcXFwiKSB7XG4gICAgaWYgKFwiQWJCR3paXCIuaW5jbHVkZXMobTEpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbjogY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5Bc3NlcnRpb24sIG0sIHtcbiAgICAgICAgICBraW5kOiBtXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoL15cXFxcZ1s8J10vLnRlc3QobSkpIHtcbiAgICAgIGlmICghL15cXFxcZyg/OjxbXj5dKz58J1teJ10rJykkLy50ZXN0KG0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBncm91cCBuYW1lIFwiJHttfVwiYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbjogY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5TdWJyb3V0aW5lLCBtKVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKC9eXFxcXGtbPCddLy50ZXN0KG0pKSB7XG4gICAgICBpZiAoIS9eXFxcXGsoPzo8W14+XSs+fCdbXiddKycpJC8udGVzdChtKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZ3JvdXAgbmFtZSBcIiR7bX1cImApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW46IGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQmFja3JlZmVyZW5jZSwgbSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChtMSA9PT0gXCJLXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuOiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkRpcmVjdGl2ZSwgbSwge1xuICAgICAgICAgIGtpbmQ6IFRva2VuRGlyZWN0aXZlS2luZHMua2VlcFxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG0xID09PSBcIk5cIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW46IGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyU2V0LCBtLCB7XG4gICAgICAgICAga2luZDogVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcy5ub25fbmV3bGluZVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG0xID09PSBcIk9cIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW46IGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyU2V0LCBtLCB7XG4gICAgICAgICAga2luZDogVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcy5hbnlcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChcIlJYXCIuaW5jbHVkZXMobTEpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbjogY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5WYXJpYWJsZUxlbmd0aENoYXJhY3RlclNldCwgbSwge1xuICAgICAgICAgIGtpbmQ6IG1cbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChcInlZXCIuaW5jbHVkZXMobTEpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGdyYXBoZW1lIGJvdW5kYXJ5IFwiJHttfVwiYCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGNyZWF0ZVRva2VuRm9yU2hhcmVkRXNjYXBlKG0sIHsgaW5DaGFyQ2xhc3M6IGZhbHNlIH0pO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJlc3VsdCkgPyB7IHRva2VuczogcmVzdWx0IH0gOiB7IHRva2VuOiByZXN1bHQgfTtcbiAgfVxuICBpZiAobTAgPT09IFwiKFwiKSB7XG4gICAgaWYgKG0gPT09IFwiKCpcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBuYW1lZCBjYWxsb3V0IFwiJHttfVwiYCk7XG4gICAgfVxuICAgIGlmIChtID09PSBcIig/e1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNhbGxvdXQgXCIke219XCJgKTtcbiAgICB9XG4gICAgaWYgKG0gPT09IFwiKD8jXCIpIHtcbiAgICAgIGlmIChwYXR0ZXJuW2xhc3RJbmRleF0gIT09IFwiKVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgY29tbWVudCBncm91cCBcIig/I1wiJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYXN0SW5kZXg6IGxhc3RJbmRleCArIDFcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICgvXlxcKFxcP1staW14XStbOildJC8udGVzdChtKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW46IGNyZWF0ZVRva2VuRm9yRmxhZ01vZChtLCBjb250ZXh0KVxuICAgICAgfTtcbiAgICB9XG4gICAgY29udGV4dC5wdXNoTW9kWChjb250ZXh0LmdldEN1cnJlbnRNb2RYKCkpO1xuICAgIGNvbnRleHQubnVtT3Blbkdyb3VwcysrO1xuICAgIGlmIChcbiAgICAgIC8vIFVubmFtZWQgY2FwdHVyZSBpZiBubyBuYW1lZCBjYXB0dXJlcyBwcmVzZW50IGFuZCBgY2FwdHVyZUdyb3VwYCBub3QgZW5hYmxlZCwgZWxzZVxuICAgICAgLy8gbm9uY2FwdHVyaW5nIGdyb3VwXG4gICAgICBtID09PSBcIihcIiAmJiAhY29udGV4dC5jYXB0dXJlR3JvdXAgfHwgLy8gTm9uY2FwdHVyaW5nIGdyb3VwXG4gICAgICBtID09PSBcIig/OlwiXG4gICAgKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbjogY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5Hcm91cE9wZW4sIG0sIHtcbiAgICAgICAgICAvLyBGb3IgYChgLCB3aWxsIGxhdGVyIGNoYW5nZSB0byBgY2FwdHVyaW5nYCBhbmQgYWRkIGBudW1iZXJgIHByb3AgaWYgbm8gbmFtZWQgY2FwdHVyZXNcbiAgICAgICAgICBraW5kOiBUb2tlbkdyb3VwS2luZHMuZ3JvdXBcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChtID09PSBcIig/PlwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbjogY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5Hcm91cE9wZW4sIG0sIHtcbiAgICAgICAgICBraW5kOiBUb2tlbkdyb3VwS2luZHMuYXRvbWljXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobSA9PT0gXCIoPz1cIiB8fCBtID09PSBcIig/IVwiIHx8IG0gPT09IFwiKD88PVwiIHx8IG0gPT09IFwiKD88IVwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbjogY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5Hcm91cE9wZW4sIG0sIHtcbiAgICAgICAgICBraW5kOiBtWzJdID09PSBcIjxcIiA/IFRva2VuR3JvdXBLaW5kcy5sb29rYmVoaW5kIDogVG9rZW5Hcm91cEtpbmRzLmxvb2thaGVhZCxcbiAgICAgICAgICBuZWdhdGU6IG0uZW5kc1dpdGgoXCIhXCIpXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobSA9PT0gXCIoXCIgJiYgY29udGV4dC5jYXB0dXJlR3JvdXAgfHwgbS5zdGFydHNXaXRoKFwiKD88XCIpICYmIG0uZW5kc1dpdGgoXCI+XCIpIHx8IG0uc3RhcnRzV2l0aChcIig/J1wiKSAmJiBtLmVuZHNXaXRoKFwiJ1wiKSkge1xuICAgICAgY29uc3QgdG9rZW4gPSBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkdyb3VwT3BlbiwgbSwge1xuICAgICAgICBraW5kOiBUb2tlbkdyb3VwS2luZHMuY2FwdHVyaW5nXG4gICAgICAgIC8vIFdpbGwgYWRkIGBudW1iZXJgIHByb3AgaW4gYSBzZWNvbmQgcGFzc1xuICAgICAgfSk7XG4gICAgICBpZiAobSAhPT0gXCIoXCIpIHtcbiAgICAgICAgdG9rZW4ubmFtZSA9IG0uc2xpY2UoMywgLTEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9rZW5cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChtLnN0YXJ0c1dpdGgoXCIoP35cIikpIHtcbiAgICAgIGlmIChtID09PSBcIig/fnxcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFic2VudCBmdW5jdGlvbiBraW5kIFwiJHttfVwiYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbjogY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5Hcm91cE9wZW4sIG0sIHtcbiAgICAgICAgICBraW5kOiBUb2tlbkdyb3VwS2luZHMuYWJzZW50X3JlcGVhdGVyXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAobSA9PT0gXCIoPyhcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb25kaXRpb25hbCBcIiR7bX1cImApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb3IgdW5zdXBwb3J0ZWQgZ3JvdXAgb3B0aW9uIFwiJHttfVwiYCk7XG4gIH1cbiAgaWYgKG0gPT09IFwiKVwiKSB7XG4gICAgY29udGV4dC5wb3BNb2RYKCk7XG4gICAgY29udGV4dC5udW1PcGVuR3JvdXBzLS07XG4gICAgaWYgKGNvbnRleHQubnVtT3Blbkdyb3VwcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5tYXRjaGVkIFwiKVwiJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0b2tlbjogY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5Hcm91cENsb3NlLCBtKVxuICAgIH07XG4gIH1cbiAgaWYgKG0gPT09IFwiI1wiICYmIGNvbnRleHQuZ2V0Q3VycmVudE1vZFgoKSkge1xuICAgIGNvbnN0IGVuZCA9IHBhdHRlcm4uaW5kZXhPZihcIlxcblwiLCBsYXN0SW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICAvLyBKdW1wIGZvcndhcmQgdG8gdGhlIGVuZCBvZiB0aGUgY29tbWVudFxuICAgICAgbGFzdEluZGV4OiBlbmQgPT09IC0xID8gcGF0dGVybi5sZW5ndGggOiBlbmRcbiAgICB9O1xuICB9XG4gIGlmICgvXlxccyQvLnRlc3QobSkgJiYgY29udGV4dC5nZXRDdXJyZW50TW9kWCgpKSB7XG4gICAgY29uc3QgcmUgPSAvXFxzKy95O1xuICAgIHJlLmxhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICBjb25zdCByZXN0ID0gcmUuZXhlYyhwYXR0ZXJuKTtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gSnVtcCBmb3J3YXJkIHRvIHRoZSBlbmQgb2YgdGhlIHdoaXRlc3BhY2VcbiAgICAgIGxhc3RJbmRleDogcmVzdCA/IHJlLmxhc3RJbmRleCA6IGxhc3RJbmRleFxuICAgIH07XG4gIH1cbiAgaWYgKG0gPT09IFwiLlwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuOiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlclNldCwgbSwge1xuICAgICAgICBraW5kOiBUb2tlbkNoYXJhY3RlclNldEtpbmRzLmRvdFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIGlmIChtID09PSBcIl5cIiB8fCBtID09PSBcIiRcIikge1xuICAgIGNvbnN0IGtpbmQgPSBjb250ZXh0LnNpbmdsZWxpbmUgPyB7XG4gICAgICBcIl5cIjogcmBcXEFgLFxuICAgICAgXCIkXCI6IHJgXFxaYFxuICAgIH1bbV0gOiBtO1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbjogY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5Bc3NlcnRpb24sIG0sIHtcbiAgICAgICAga2luZFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIGlmIChtID09PSBcInxcIikge1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbjogY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5BbHRlcm5hdG9yLCBtKVxuICAgIH07XG4gIH1cbiAgaWYgKHF1YW50aWZpZXJSZS50ZXN0KG0pKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuOiBjcmVhdGVUb2tlbkZvclF1YW50aWZpZXIobSlcbiAgICB9O1xuICB9XG4gIGFzc2VydFNpbmdsZUNvZGVQb2ludChtKTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXIsIG0sIHtcbiAgICAgIHZhbHVlOiBtLmNvZGVQb2ludEF0KDApXG4gICAgfSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEFsbFRva2Vuc0ZvckNoYXJDbGFzcyhwYXR0ZXJuLCBvcGVuZXIsIGxhc3RJbmRleCkge1xuICBjb25zdCB0b2tlbnMgPSBbY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXJDbGFzc09wZW4sIG9wZW5lciwge1xuICAgIG5lZ2F0ZTogb3BlbmVyWzFdID09PSBcIl5cIlxuICB9KV07XG4gIGxldCBudW1DaGFyQ2xhc3Nlc09wZW4gPSAxO1xuICBsZXQgbWF0Y2g7XG4gIGNoYXJDbGFzc1Rva2VuUmUubGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICB3aGlsZSAobWF0Y2ggPSBjaGFyQ2xhc3NUb2tlblJlLmV4ZWMocGF0dGVybikpIHtcbiAgICBjb25zdCBtID0gbWF0Y2hbMF07XG4gICAgaWYgKG1bMF0gPT09IFwiW1wiICYmIG1bMV0gIT09IFwiOlwiKSB7XG4gICAgICBudW1DaGFyQ2xhc3Nlc09wZW4rKztcbiAgICAgIHRva2Vucy5wdXNoKGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyQ2xhc3NPcGVuLCBtLCB7XG4gICAgICAgIG5lZ2F0ZTogbVsxXSA9PT0gXCJeXCJcbiAgICAgIH0pKTtcbiAgICB9IGVsc2UgaWYgKG0gPT09IFwiXVwiKSB7XG4gICAgICBpZiAodG9rZW5zLmF0KC0xKS50eXBlID09PSBUb2tlblR5cGVzLkNoYXJhY3RlckNsYXNzT3Blbikge1xuICAgICAgICB0b2tlbnMucHVzaChjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlciwgbSwge1xuICAgICAgICAgIHZhbHVlOiA5M1xuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBudW1DaGFyQ2xhc3Nlc09wZW4tLTtcbiAgICAgICAgdG9rZW5zLnB1c2goY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXJDbGFzc0Nsb3NlLCBtKSk7XG4gICAgICAgIGlmICghbnVtQ2hhckNsYXNzZXNPcGVuKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY3JlYXRlVG9rZW5Gb3JBbnlUb2tlbldpdGhpbkNoYXJDbGFzcyhtKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goLi4ucmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdG9rZW5zLFxuICAgIGxhc3RJbmRleDogY2hhckNsYXNzVG9rZW5SZS5sYXN0SW5kZXggfHwgcGF0dGVybi5sZW5ndGhcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRva2VuRm9yQW55VG9rZW5XaXRoaW5DaGFyQ2xhc3MocmF3KSB7XG4gIGlmIChyYXdbMF0gPT09IFwiXFxcXFwiKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRva2VuRm9yU2hhcmVkRXNjYXBlKHJhdywgeyBpbkNoYXJDbGFzczogdHJ1ZSB9KTtcbiAgfVxuICBpZiAocmF3WzBdID09PSBcIltcIikge1xuICAgIGNvbnN0IHBvc2l4ID0gL1xcWzooPzxuZWdhdGU+XFxePykoPzxuYW1lPlthLXpdKyk6XFxdLy5leGVjKHJhdyk7XG4gICAgaWYgKCFwb3NpeCB8fCAhUG9zaXhDbGFzc2VzTWFwLmdldChwb3NpeC5ncm91cHMubmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBQT1NJWCBjbGFzcyBcIiR7cmF3fVwiYCk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlclNldCwgcmF3LCB7XG4gICAgICBraW5kOiBUb2tlbkNoYXJhY3RlclNldEtpbmRzLnBvc2l4LFxuICAgICAgbmVnYXRlOiAhIXBvc2l4Lmdyb3Vwcy5uZWdhdGUsXG4gICAgICB2YWx1ZTogcG9zaXguZ3JvdXBzLm5hbWVcbiAgICB9KTtcbiAgfVxuICBpZiAocmF3ID09PSBcIi1cIikge1xuICAgIHJldHVybiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlckNsYXNzSHlwaGVuLCByYXcpO1xuICB9XG4gIGlmIChyYXcgPT09IFwiJiZcIikge1xuICAgIHJldHVybiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlckNsYXNzSW50ZXJzZWN0b3IsIHJhdyk7XG4gIH1cbiAgYXNzZXJ0U2luZ2xlQ29kZVBvaW50KHJhdyk7XG4gIHJldHVybiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkNoYXJhY3RlciwgcmF3LCB7XG4gICAgdmFsdWU6IHJhdy5jb2RlUG9pbnRBdCgwKVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRva2VuRm9yU2hhcmVkRXNjYXBlKHJhdywgeyBpbkNoYXJDbGFzcyB9KSB7XG4gIGNvbnN0IGNoYXIxID0gcmF3WzFdO1xuICBpZiAoY2hhcjEgPT09IFwiY1wiIHx8IGNoYXIxID09PSBcIkNcIikge1xuICAgIHJldHVybiBjcmVhdGVUb2tlbkZvckNvbnRyb2xDaGFyKHJhdyk7XG4gIH1cbiAgaWYgKFwiZERoSHNTd1dcIi5pbmNsdWRlcyhjaGFyMSkpIHtcbiAgICByZXR1cm4gY3JlYXRlVG9rZW5Gb3JTaG9ydGhhbmRDaGFyQ2xhc3MocmF3KTtcbiAgfVxuICBpZiAocmF3LnN0YXJ0c1dpdGgocmBcXG97YCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEluY29tcGxldGUsIGludmFsaWQsIG9yIHVuc3VwcG9ydGVkIG9jdGFsIGNvZGUgcG9pbnQgXCIke3Jhd31cImApO1xuICB9XG4gIGlmICgvXlxcXFxbcFBdXFx7Ly50ZXN0KHJhdykpIHtcbiAgICBpZiAocmF3Lmxlbmd0aCA9PT0gMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmNvbXBsZXRlIG9yIGludmFsaWQgVW5pY29kZSBwcm9wZXJ0eSBcIiR7cmF3fVwiYCk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVUb2tlbkZvclVuaWNvZGVQcm9wZXJ0eShyYXcpO1xuICB9XG4gIGlmICgvXlxcXFx4Wzg5QS1GYS1mXVxccHtBSGV4fS91LnRlc3QocmF3KSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBieXRlcyA9IHJhdy5zcGxpdCgvXFxcXHgvKS5zbGljZSgxKS5tYXAoKGhleCkgPT4gcGFyc2VJbnQoaGV4LCAxNikpO1xuICAgICAgY29uc3QgZGVjb2RlZCA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIsIHtcbiAgICAgICAgaWdub3JlQk9NOiB0cnVlLFxuICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgfSkuZGVjb2RlKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICBjb25zdCB0b2tlbnMgPSBbLi4uZGVjb2RlZF0ubWFwKChjaGFyKSA9PiB7XG4gICAgICAgIGNvbnN0IHJhdzIgPSBbLi4uZW5jb2Rlci5lbmNvZGUoY2hhcildLm1hcCgoYnl0ZSkgPT4gYFxcXFx4JHtieXRlLnRvU3RyaW5nKDE2KX1gKS5qb2luKFwiXCIpO1xuICAgICAgICByZXR1cm4gY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXIsIHJhdzIsIHtcbiAgICAgICAgICB2YWx1ZTogY2hhci5jb2RlUG9pbnRBdCgwKVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlieXRlIGNvZGUgXCIke3Jhd31cIiBpbmNvbXBsZXRlIG9yIGludmFsaWQgaW4gT25pZ3VydW1hYCk7XG4gICAgfVxuICB9XG4gIGlmIChjaGFyMSA9PT0gXCJ1XCIgfHwgY2hhcjEgPT09IFwieFwiKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyLCByYXcsIHtcbiAgICAgIHZhbHVlOiBnZXRWYWxpZGF0ZWRIZXhDaGFyQ29kZShyYXcpXG4gICAgfSk7XG4gIH1cbiAgaWYgKEVzY2FwZUNoYXJDb2Rlcy5oYXMoY2hhcjEpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyLCByYXcsIHtcbiAgICAgIHZhbHVlOiBFc2NhcGVDaGFyQ29kZXMuZ2V0KGNoYXIxKVxuICAgIH0pO1xuICB9XG4gIGlmICgvXFxkLy50ZXN0KGNoYXIxKSkge1xuICAgIHJldHVybiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkVzY2FwZWROdW1iZXIsIHJhdywge1xuICAgICAgaW5DaGFyQ2xhc3NcbiAgICB9KTtcbiAgfVxuICBpZiAocmF3ID09PSBcIlxcXFxcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihyYEluY29tcGxldGUgZXNjYXBlIFwiXFxcImApO1xuICB9XG4gIGlmIChjaGFyMSA9PT0gXCJNXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG1ldGEgXCIke3Jhd31cImApO1xuICB9XG4gIGlmIChbLi4ucmF3XS5sZW5ndGggPT09IDIpIHtcbiAgICByZXR1cm4gY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXIsIHJhdywge1xuICAgICAgdmFsdWU6IHJhdy5jb2RlUG9pbnRBdCgxKVxuICAgIH0pO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBlc2NhcGUgXCIke3Jhd31cImApO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW4odHlwZSwgcmF3LCBkYXRhKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZSxcbiAgICByYXcsXG4gICAgLi4uZGF0YVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW5Gb3JDb250cm9sQ2hhcihyYXcpIHtcbiAgY29uc3QgY2hhciA9IHJhd1sxXSA9PT0gXCJjXCIgPyByYXdbMl0gOiByYXdbM107XG4gIGlmICghY2hhciB8fCAhL1tBLVphLXpdLy50ZXN0KGNoYXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb250cm9sIGNoYXJhY3RlciBcIiR7cmF3fVwiYCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyLCByYXcsIHtcbiAgICB2YWx1ZTogY2hhci50b1VwcGVyQ2FzZSgpLmNvZGVQb2ludEF0KDApIC0gNjRcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlbkZvckZsYWdNb2QocmF3LCBjb250ZXh0KSB7XG4gIGxldCB7IG9uLCBvZmYgfSA9IC9eXFwoXFw/KD88b24+W2lteF0qKSg/Oi0oPzxvZmY+Wy1pbXhdKikpPy8uZXhlYyhyYXcpLmdyb3VwcztcbiAgb2ZmID8/PSBcIlwiO1xuICBjb25zdCBpc1hPbiA9IChjb250ZXh0LmdldEN1cnJlbnRNb2RYKCkgfHwgb24uaW5jbHVkZXMoXCJ4XCIpKSAmJiAhb2ZmLmluY2x1ZGVzKFwieFwiKTtcbiAgY29uc3QgZW5hYmxlZEZsYWdzID0gZ2V0RmxhZ1Byb3BzRm9yVG9rZW4ob24pO1xuICBjb25zdCBkaXNhYmxlZEZsYWdzID0gZ2V0RmxhZ1Byb3BzRm9yVG9rZW4ob2ZmKTtcbiAgY29uc3QgZmxhZ0NoYW5nZXMgPSB7fTtcbiAgZW5hYmxlZEZsYWdzICYmIChmbGFnQ2hhbmdlcy5lbmFibGUgPSBlbmFibGVkRmxhZ3MpO1xuICBkaXNhYmxlZEZsYWdzICYmIChmbGFnQ2hhbmdlcy5kaXNhYmxlID0gZGlzYWJsZWRGbGFncyk7XG4gIGlmIChyYXcuZW5kc1dpdGgoXCIpXCIpKSB7XG4gICAgY29udGV4dC5yZXBsYWNlQ3VycmVudE1vZFgoaXNYT24pO1xuICAgIHJldHVybiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLkRpcmVjdGl2ZSwgcmF3LCB7XG4gICAgICBraW5kOiBUb2tlbkRpcmVjdGl2ZUtpbmRzLmZsYWdzLFxuICAgICAgZmxhZ3M6IGZsYWdDaGFuZ2VzXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJhdy5lbmRzV2l0aChcIjpcIikpIHtcbiAgICBjb250ZXh0LnB1c2hNb2RYKGlzWE9uKTtcbiAgICBjb250ZXh0Lm51bU9wZW5Hcm91cHMrKztcbiAgICBjb25zdCB0b2tlbiA9IGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuR3JvdXBPcGVuLCByYXcsIHtcbiAgICAgIGtpbmQ6IFRva2VuR3JvdXBLaW5kcy5ncm91cFxuICAgIH0pO1xuICAgIGlmIChlbmFibGVkRmxhZ3MgfHwgZGlzYWJsZWRGbGFncykge1xuICAgICAgdG9rZW4uZmxhZ3MgPSBmbGFnQ2hhbmdlcztcbiAgICB9XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBmbGFnIG1vZGlmaWVyIFwiJHtyYXd9XCJgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRva2VuRm9yUXVhbnRpZmllcihyYXcpIHtcbiAgY29uc3QgZGF0YSA9IHt9O1xuICBpZiAocmF3WzBdID09PSBcIntcIikge1xuICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IC9eXFx7KD88bWluPlxcZCopKD86LCg/PG1heD5cXGQqKSk/Ly5leGVjKHJhdykuZ3JvdXBzO1xuICAgIGNvbnN0IGxpbWl0ID0gMWU1O1xuICAgIGlmICgrbWluID4gbGltaXQgfHwgK21heCA+IGxpbWl0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRdWFudGlmaWVyIHZhbHVlIHVuc3VwcG9ydGVkIGluIE9uaWd1cnVtYVwiKTtcbiAgICB9XG4gICAgZGF0YS5taW4gPSArbWluO1xuICAgIGRhdGEubWF4ID0gbWF4ID09PSB2b2lkIDAgPyArbWluIDogbWF4ID09PSBcIlwiID8gSW5maW5pdHkgOiArbWF4O1xuICAgIGRhdGEuZ3JlZWR5ID0gIXJhdy5lbmRzV2l0aChcIj9cIik7XG4gICAgZGF0YS5wb3NzZXNzaXZlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgZGF0YS5taW4gPSByYXdbMF0gPT09IFwiK1wiID8gMSA6IDA7XG4gICAgZGF0YS5tYXggPSByYXdbMF0gPT09IFwiP1wiID8gMSA6IEluZmluaXR5O1xuICAgIGRhdGEuZ3JlZWR5ID0gcmF3WzFdICE9PSBcIj9cIjtcbiAgICBkYXRhLnBvc3Nlc3NpdmUgPSByYXdbMV0gPT09IFwiK1wiO1xuICB9XG4gIHJldHVybiBjcmVhdGVUb2tlbihUb2tlblR5cGVzLlF1YW50aWZpZXIsIHJhdywgZGF0YSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlbkZvclNob3J0aGFuZENoYXJDbGFzcyhyYXcpIHtcbiAgY29uc3QgbG93ZXIgPSByYXdbMV0udG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIGNyZWF0ZVRva2VuKFRva2VuVHlwZXMuQ2hhcmFjdGVyU2V0LCByYXcsIHtcbiAgICBraW5kOiB7XG4gICAgICBcImRcIjogVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcy5kaWdpdCxcbiAgICAgIFwiaFwiOiBUb2tlbkNoYXJhY3RlclNldEtpbmRzLmhleCxcbiAgICAgIC8vIE5vdCBhdmFpbGFibGUgaW4gSlNcbiAgICAgIFwic1wiOiBUb2tlbkNoYXJhY3RlclNldEtpbmRzLnNwYWNlLFxuICAgICAgLy8gRGlmZmVyZW50IHRoYW4gSlNcbiAgICAgIFwid1wiOiBUb2tlbkNoYXJhY3RlclNldEtpbmRzLndvcmRcbiAgICB9W2xvd2VyXSxcbiAgICBuZWdhdGU6IHJhd1sxXSAhPT0gbG93ZXJcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlbkZvclVuaWNvZGVQcm9wZXJ0eShyYXcpIHtcbiAgY29uc3QgeyBwLCBuZWcsIHZhbHVlIH0gPSAvXlxcXFwoPzxwPltwUF0pXFx7KD88bmVnPlxcXj8pKD88dmFsdWU+W159XSspLy5leGVjKHJhdykuZ3JvdXBzO1xuICBjb25zdCBuZWdhdGUgPSBwID09PSBcIlBcIiAmJiAhbmVnIHx8IHAgPT09IFwicFwiICYmICEhbmVnO1xuICByZXR1cm4gY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXJTZXQsIHJhdywge1xuICAgIGtpbmQ6IFRva2VuQ2hhcmFjdGVyU2V0S2luZHMucHJvcGVydHksXG4gICAgbmVnYXRlLFxuICAgIHZhbHVlXG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0RmxhZ1Byb3BzRm9yVG9rZW4oZmxhZ3MpIHtcbiAgY29uc3Qgb2JqID0ge307XG4gIGlmIChmbGFncy5pbmNsdWRlcyhcImlcIikpIHtcbiAgICBvYmouaWdub3JlQ2FzZSA9IHRydWU7XG4gIH1cbiAgaWYgKGZsYWdzLmluY2x1ZGVzKFwibVwiKSkge1xuICAgIG9iai5kb3RBbGwgPSB0cnVlO1xuICB9XG4gIGlmIChmbGFncy5pbmNsdWRlcyhcInhcIikpIHtcbiAgICBvYmouZXh0ZW5kZWQgPSB0cnVlO1xuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA/IG9iaiA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRWYWxpZGF0ZWRIZXhDaGFyQ29kZShyYXcpIHtcbiAgaWYgKC9eKD86XFxcXHUoPyFcXHB7QUhleH17NH0pfFxcXFx4KD8hXFxwe0FIZXh9ezEsMn18XFx7XFxwe0FIZXh9ezEsOH1cXH0pKS91LnRlc3QocmF3KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW5jb21wbGV0ZSBvciBpbnZhbGlkIGVzY2FwZSBcIiR7cmF3fVwiYCk7XG4gIH1cbiAgY29uc3QgaGV4ID0gcmF3WzJdID09PSBcIntcIiA/IC9eXFxcXHhcXHtcXHMqKD88aGV4PlxccHtBSGV4fSspL3UuZXhlYyhyYXcpLmdyb3Vwcy5oZXggOiByYXcuc2xpY2UoMik7XG4gIGNvbnN0IGRlYyA9IHBhcnNlSW50KGhleCwgMTYpO1xuICByZXR1cm4gZGVjO1xufVxuZnVuY3Rpb24gc3BsaXRFc2NhcGVkTnVtVG9rZW4odG9rZW4sIG51bUNhcHR1cmVzKSB7XG4gIGNvbnN0IHsgcmF3LCBpbkNoYXJDbGFzcyB9ID0gdG9rZW47XG4gIGNvbnN0IHZhbHVlID0gcmF3LnNsaWNlKDEpO1xuICBpZiAoIWluQ2hhckNsYXNzICYmIC8vIFNpbmdsZSBkaWdpdCAxLTkgb3V0c2lkZSBhIGNoYXIgY2xhc3MgaXMgYWx3YXlzIHRyZWF0ZWQgYXMgYSBiYWNrcmVmXG4gICh2YWx1ZSAhPT0gXCIwXCIgJiYgdmFsdWUubGVuZ3RoID09PSAxIHx8IC8vIExlYWRpbmcgMCBtYWtlcyBpdCBvY3RhbDsgYmFja3JlZnMgY2FuJ3QgaW5jbHVkZSBmb2xsb3dpbmcgbGl0ZXJhbCBkaWdpdHNcbiAgdmFsdWVbMF0gIT09IFwiMFwiICYmICt2YWx1ZSA8PSBudW1DYXB0dXJlcykpIHtcbiAgICByZXR1cm4gW2NyZWF0ZVRva2VuKFRva2VuVHlwZXMuQmFja3JlZmVyZW5jZSwgcmF3KV07XG4gIH1cbiAgY29uc3QgdG9rZW5zID0gW107XG4gIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZS5tYXRjaCgvXlswLTddK3xcXGQvZyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG0gPSBtYXRjaGVzW2ldO1xuICAgIGxldCB2YWx1ZTI7XG4gICAgaWYgKGkgPT09IDAgJiYgbSAhPT0gXCI4XCIgJiYgbSAhPT0gXCI5XCIpIHtcbiAgICAgIHZhbHVlMiA9IHBhcnNlSW50KG0sIDgpO1xuICAgICAgaWYgKHZhbHVlMiA+IDEyNykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmBPY3RhbCBlbmNvZGVkIGJ5dGUgYWJvdmUgMTc3IHVuc3VwcG9ydGVkIFwiJHtyYXd9XCJgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUyID0gbS5jb2RlUG9pbnRBdCgwKTtcbiAgICB9XG4gICAgdG9rZW5zLnB1c2goY3JlYXRlVG9rZW4oVG9rZW5UeXBlcy5DaGFyYWN0ZXIsIChpID09PSAwID8gXCJcXFxcXCIgOiBcIlwiKSArIG0sIHtcbiAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIHRva2Vucztcbn1cbmZ1bmN0aW9uIGFzc2VydFNpbmdsZUNvZGVQb2ludChyYXcpIHtcbiAgaWYgKFsuLi5yYXddLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgXCIke3Jhd31cIiB0byBiZSBhIHNpbmdsZSBjb2RlIHBvaW50YCk7XG4gIH1cbn1cblxuLy8gc3JjL3V0aWxzLWFzdC5qc1xuZnVuY3Rpb24gaGFzT25seUNoaWxkKHsgYWx0ZXJuYXRpdmVzIH0sIGtpZEZuKSB7XG4gIHJldHVybiBhbHRlcm5hdGl2ZXMubGVuZ3RoID09PSAxICYmIGFsdGVybmF0aXZlc1swXS5lbGVtZW50cy5sZW5ndGggPT09IDEgJiYgKCFraWRGbiB8fCBraWRGbihhbHRlcm5hdGl2ZXNbMF0uZWxlbWVudHNbMF0pKTtcbn1cbmZ1bmN0aW9uIGlzQWx3YXlzWmVyb0xlbmd0aCh7IHR5cGUgfSkge1xuICByZXR1cm4gdHlwZSA9PT0gQXN0VHlwZXMuQXNzZXJ0aW9uIHx8IHR5cGUgPT09IEFzdFR5cGVzLkRpcmVjdGl2ZTtcbn1cbmZ1bmN0aW9uIGlzQWx3YXlzTm9uWmVyb0xlbmd0aChub2RlKSB7XG4gIGNvbnN0IHR5cGVzID0gW1xuICAgIEFzdFR5cGVzLkNoYXJhY3RlcixcbiAgICBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzcyxcbiAgICBBc3RUeXBlcy5DaGFyYWN0ZXJTZXRcbiAgXTtcbiAgcmV0dXJuIHR5cGVzLmluY2x1ZGVzKG5vZGUudHlwZSkgfHwgbm9kZS50eXBlID09PSBBc3RUeXBlcy5RdWFudGlmaWVyICYmIG5vZGUubWluICYmIHR5cGVzLmluY2x1ZGVzKG5vZGUuZWxlbWVudC50eXBlKTtcbn1cbmZ1bmN0aW9uIGlzQ29uc3VtcHRpdmVHcm91cCh7IHR5cGUgfSkge1xuICByZXR1cm4gdHlwZSA9PT0gQXN0VHlwZXMuQ2FwdHVyaW5nR3JvdXAgfHwgdHlwZSA9PT0gQXN0VHlwZXMuR3JvdXA7XG59XG5mdW5jdGlvbiBpc0xvb2thcm91bmQoeyB0eXBlLCBraW5kIH0pIHtcbiAgcmV0dXJuIHR5cGUgPT09IEFzdFR5cGVzLkFzc2VydGlvbiAmJiAoa2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMubG9va2FoZWFkIHx8IGtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLmxvb2tiZWhpbmQpO1xufVxuXG4vLyBzcmMvdHJhdmVyc2UuanNcbmZ1bmN0aW9uIHRyYXZlcnNlKHBhdGgsIHN0YXRlLCB2aXNpdG9yKSB7XG4gIGxldCBhc3QgPSBwYXRoLm5vZGU7XG4gIHdoaWxlIChhc3QucGFyZW50KSB7XG4gICAgYXN0ID0gYXN0LnBhcmVudDtcbiAgfVxuICBmdW5jdGlvbiB0cmF2ZXJzZUFycmF5KGFycmF5LCBwYXJlbnQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXlTaGlmdCA9IHRyYXZlcnNlTm9kZShhcnJheVtpXSwgcGFyZW50LCBpLCBhcnJheSk7XG4gICAgICBpID0gTWF0aC5tYXgoLTEsIGkgKyBrZXlTaGlmdCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyYXZlcnNlTm9kZShub2RlLCBwYXJlbnQgPSBudWxsLCBrZXkgPSBudWxsLCBjb250YWluZXIgPSBudWxsKSB7XG4gICAgbGV0IGtleVNoaWZ0ID0gMDtcbiAgICBsZXQgc2tpcFRyYXZlcnNpbmdLaWRzT2ZQYXRoID0gZmFsc2U7XG4gICAgY29uc3QgcGF0aDIgPSB7XG4gICAgICBub2RlLFxuICAgICAgcGFyZW50LFxuICAgICAga2V5LFxuICAgICAgY29udGFpbmVyLFxuICAgICAgYXN0LFxuICAgICAgcmVtb3ZlKCkge1xuICAgICAgICB0aHJvd0lmTm90KGNvbnRhaW5lciwgXCJDb250YWluZXIgZXhwZWN0ZWRcIikuc3BsaWNlKE1hdGgubWF4KDAsIGtleSArIGtleVNoaWZ0KSwgMSk7XG4gICAgICAgIGtleVNoaWZ0IC09IDE7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQWxsTmV4dFNpYmxpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhyb3dJZk5vdChjb250YWluZXIsIFwiQ29udGFpbmVyIGV4cGVjdGVkXCIpLnNwbGljZShrZXkgKyAxKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVBbGxQcmV2U2libGluZ3MoKSB7XG4gICAgICAgIGNvbnN0IHNoaWZ0ZWQgPSBrZXkgKyBrZXlTaGlmdDtcbiAgICAgICAga2V5U2hpZnQgLT0gc2hpZnRlZDtcbiAgICAgICAgcmV0dXJuIHRocm93SWZOb3QoY29udGFpbmVyLCBcIkNvbnRhaW5lciBleHBlY3RlZFwiKS5zcGxpY2UoMCwgTWF0aC5tYXgoMCwgc2hpZnRlZCkpO1xuICAgICAgfSxcbiAgICAgIHJlcGxhY2VXaXRoKG5ld05vZGUpIHtcbiAgICAgICAgc2V0UGFyZW50KG5ld05vZGUsIHBhcmVudCk7XG4gICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICBjb250YWluZXJbTWF0aC5tYXgoMCwga2V5ICsga2V5U2hpZnQpXSA9IG5ld05vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyZW50W2tleV0gPSBuZXdOb2RlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2tpcCgpIHtcbiAgICAgICAgc2tpcFRyYXZlcnNpbmdLaWRzT2ZQYXRoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHZpc2l0b3JLZXkgPSBnZXRBc3RUeXBlQWxpYXNlcyhub2RlKS5maW5kKChrZXkyKSA9PiAhIXZpc2l0b3Jba2V5Ml0pO1xuICAgIGNvbnN0IG1ldGhvZHMgPSB2aXNpdG9yS2V5ICYmIHZpc2l0b3JbdmlzaXRvcktleV07XG4gICAgY29uc3QgZW50ZXJGbiA9IHR5cGVvZiBtZXRob2RzID09PSBcImZ1bmN0aW9uXCIgPyBtZXRob2RzIDogbWV0aG9kcz8uZW50ZXI7XG4gICAgY29uc3QgZXhpdEZuID0gbWV0aG9kcz8uZXhpdDtcbiAgICBlbnRlckZuPy4ocGF0aDIsIHN0YXRlKTtcbiAgICBpZiAoIXNraXBUcmF2ZXJzaW5nS2lkc09mUGF0aCkge1xuICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBBc3RUeXBlcy5SZWdleDpcbiAgICAgICAgICB0cmF2ZXJzZU5vZGUobm9kZS5wYXR0ZXJuLCBub2RlLCBcInBhdHRlcm5cIik7XG4gICAgICAgICAgdHJhdmVyc2VOb2RlKG5vZGUuZmxhZ3MsIG5vZGUsIFwiZmxhZ3NcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuQWx0ZXJuYXRpdmU6XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuQ2hhcmFjdGVyQ2xhc3M6XG4gICAgICAgICAgdHJhdmVyc2VBcnJheShub2RlLmVsZW1lbnRzLCBub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBc3RUeXBlcy5Bc3NlcnRpb246XG4gICAgICAgICAgaWYgKGlzTG9va2Fyb3VuZChub2RlKSkge1xuICAgICAgICAgICAgdHJhdmVyc2VBcnJheShub2RlLmFsdGVybmF0aXZlcywgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFzdFR5cGVzLkJhY2tyZWZlcmVuY2U6XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuQ2hhcmFjdGVyOlxuICAgICAgICBjYXNlIEFzdFR5cGVzLkNoYXJhY3RlclNldDpcbiAgICAgICAgY2FzZSBBc3RUeXBlcy5EaXJlY3RpdmU6XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuRmxhZ3M6XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuUmVjdXJzaW9uOlxuICAgICAgICBjYXNlIEFzdFR5cGVzLlN1YnJvdXRpbmU6XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuVmFyaWFibGVMZW5ndGhDaGFyYWN0ZXJTZXQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuQWJzZW50RnVuY3Rpb246XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuQ2FwdHVyaW5nR3JvdXA6XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuR3JvdXA6XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuUGF0dGVybjpcbiAgICAgICAgICB0cmF2ZXJzZUFycmF5KG5vZGUuYWx0ZXJuYXRpdmVzLCBub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzc0ludGVyc2VjdGlvbjpcbiAgICAgICAgICB0cmF2ZXJzZUFycmF5KG5vZGUuY2xhc3Nlcywgbm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuQ2hhcmFjdGVyQ2xhc3NSYW5nZTpcbiAgICAgICAgICB0cmF2ZXJzZU5vZGUobm9kZS5taW4sIG5vZGUsIFwibWluXCIpO1xuICAgICAgICAgIHRyYXZlcnNlTm9kZShub2RlLm1heCwgbm9kZSwgXCJtYXhcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQXN0VHlwZXMuUXVhbnRpZmllcjpcbiAgICAgICAgICB0cmF2ZXJzZU5vZGUobm9kZS5lbGVtZW50LCBub2RlLCBcImVsZW1lbnRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG5vZGUgdHlwZSBcIiR7bm9kZS50eXBlfVwiYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGV4aXRGbj8uKHBhdGgyLCBzdGF0ZSk7XG4gICAgcmV0dXJuIGtleVNoaWZ0O1xuICB9XG4gIHRyYXZlcnNlTm9kZShwYXRoLm5vZGUsIHBhdGgucGFyZW50LCBwYXRoLmtleSwgcGF0aC5jb250YWluZXIpO1xufVxudmFyIEFzdFR5cGVBbGlhc2VzID0ge1xuICBBbnlHcm91cDogXCJBbnlHcm91cFwiLFxuICBBbnlOb2RlOiBcIkFueU5vZGVcIlxufTtcbmZ1bmN0aW9uIGdldEFzdFR5cGVBbGlhc2VzKG5vZGUpIHtcbiAgY29uc3QgdHlwZXMgPSBbQXN0VHlwZUFsaWFzZXMuQW55Tm9kZV07XG4gIGlmIChpc0NvbnN1bXB0aXZlR3JvdXAobm9kZSkgfHwgaXNMb29rYXJvdW5kKG5vZGUpKSB7XG4gICAgdHlwZXMucHVzaChBc3RUeXBlQWxpYXNlcy5BbnlHcm91cCk7XG4gIH1cbiAgdHlwZXMucHVzaChub2RlLnR5cGUpO1xuICByZXR1cm4gdHlwZXM7XG59XG5mdW5jdGlvbiBzZXRQYXJlbnQobm9kZSwgcGFyZW50KSB7XG4gIGlmIChcInBhcmVudFwiIGluIHBhcmVudCkge1xuICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuICB9XG59XG5cbi8vIHNyYy9wYXJzZS5qc1xudmFyIEFzdFR5cGVzID0ge1xuICBBYnNlbnRGdW5jdGlvbjogXCJBYnNlbnRGdW5jdGlvblwiLFxuICBBbHRlcm5hdGl2ZTogXCJBbHRlcm5hdGl2ZVwiLFxuICBBc3NlcnRpb246IFwiQXNzZXJ0aW9uXCIsXG4gIEJhY2tyZWZlcmVuY2U6IFwiQmFja3JlZmVyZW5jZVwiLFxuICBDYXB0dXJpbmdHcm91cDogXCJDYXB0dXJpbmdHcm91cFwiLFxuICBDaGFyYWN0ZXI6IFwiQ2hhcmFjdGVyXCIsXG4gIENoYXJhY3RlckNsYXNzOiBcIkNoYXJhY3RlckNsYXNzXCIsXG4gIENoYXJhY3RlckNsYXNzSW50ZXJzZWN0aW9uOiBcIkNoYXJhY3RlckNsYXNzSW50ZXJzZWN0aW9uXCIsXG4gIENoYXJhY3RlckNsYXNzUmFuZ2U6IFwiQ2hhcmFjdGVyQ2xhc3NSYW5nZVwiLFxuICBDaGFyYWN0ZXJTZXQ6IFwiQ2hhcmFjdGVyU2V0XCIsXG4gIERpcmVjdGl2ZTogXCJEaXJlY3RpdmVcIixcbiAgRmxhZ3M6IFwiRmxhZ3NcIixcbiAgR3JvdXA6IFwiR3JvdXBcIixcbiAgUGF0dGVybjogXCJQYXR0ZXJuXCIsXG4gIFF1YW50aWZpZXI6IFwiUXVhbnRpZmllclwiLFxuICBSZWdleDogXCJSZWdleFwiLFxuICBTdWJyb3V0aW5lOiBcIlN1YnJvdXRpbmVcIixcbiAgVmFyaWFibGVMZW5ndGhDaGFyYWN0ZXJTZXQ6IFwiVmFyaWFibGVMZW5ndGhDaGFyYWN0ZXJTZXRcIixcbiAgLy8gVXNlZCBvbmx5IGJ5IHRoZSB0cmFuc2Zvcm1lciBmb3IgUmVnZXgrIEFTVHNcbiAgUmVjdXJzaW9uOiBcIlJlY3Vyc2lvblwiXG59O1xudmFyIEFzdEFic2VudEZ1bmN0aW9uS2luZHMgPSB7XG4gIC8vIFNlZSA8Z2l0aHViLmNvbS9zbGV2aXRoYW4vb25pZ3VydW1hLXRvLWVzL2lzc3Vlcy8xMz5cbiAgcmVwZWF0ZXI6IFwicmVwZWF0ZXJcIlxufTtcbnZhciBBc3RBc3NlcnRpb25LaW5kcyA9IHtcbiAgbGluZV9lbmQ6IFwibGluZV9lbmRcIixcbiAgbGluZV9zdGFydDogXCJsaW5lX3N0YXJ0XCIsXG4gIGxvb2thaGVhZDogXCJsb29rYWhlYWRcIixcbiAgbG9va2JlaGluZDogXCJsb29rYmVoaW5kXCIsXG4gIHNlYXJjaF9zdGFydDogXCJzZWFyY2hfc3RhcnRcIixcbiAgc3RyaW5nX2VuZDogXCJzdHJpbmdfZW5kXCIsXG4gIHN0cmluZ19lbmRfbmV3bGluZTogXCJzdHJpbmdfZW5kX25ld2xpbmVcIixcbiAgc3RyaW5nX3N0YXJ0OiBcInN0cmluZ19zdGFydFwiLFxuICB3b3JkX2JvdW5kYXJ5OiBcIndvcmRfYm91bmRhcnlcIlxufTtcbnZhciBBc3RDaGFyYWN0ZXJTZXRLaW5kcyA9IFRva2VuQ2hhcmFjdGVyU2V0S2luZHM7XG52YXIgQXN0RGlyZWN0aXZlS2luZHMgPSBUb2tlbkRpcmVjdGl2ZUtpbmRzO1xudmFyIEFzdFZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0S2luZHMgPSB7XG4gIGdyYXBoZW1lOiBcImdyYXBoZW1lXCIsXG4gIG5ld2xpbmU6IFwibmV3bGluZVwiXG59O1xuZnVuY3Rpb24gcGFyc2UoeyB0b2tlbnMsIGZsYWdzLCBydWxlcyB9LCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgc2tpcEJhY2tyZWZWYWxpZGF0aW9uOiBmYWxzZSxcbiAgICBza2lwTG9va2JlaGluZFZhbGlkYXRpb246IGZhbHNlLFxuICAgIHNraXBQcm9wZXJ0eU5hbWVWYWxpZGF0aW9uOiBmYWxzZSxcbiAgICB2ZXJib3NlOiBmYWxzZSxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgY2FwdHVyaW5nR3JvdXBzOiBbXSxcbiAgICBjdXJyZW50OiAwLFxuICAgIGhhc051bWJlcmVkUmVmOiBmYWxzZSxcbiAgICBuYW1lZEdyb3Vwc0J5TmFtZTogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBwYXJlbnQ6IG51bGwsXG4gICAgc2tpcEJhY2tyZWZWYWxpZGF0aW9uOiBvcHRzLnNraXBCYWNrcmVmVmFsaWRhdGlvbixcbiAgICBza2lwTG9va2JlaGluZFZhbGlkYXRpb246IG9wdHMuc2tpcExvb2tiZWhpbmRWYWxpZGF0aW9uLFxuICAgIHNraXBQcm9wZXJ0eU5hbWVWYWxpZGF0aW9uOiBvcHRzLnNraXBQcm9wZXJ0eU5hbWVWYWxpZGF0aW9uLFxuICAgIHN1YnJvdXRpbmVzOiBbXSxcbiAgICB0b2tlbjogbnVsbCxcbiAgICB0b2tlbnMsXG4gICAgdmVyYm9zZTogb3B0cy52ZXJib3NlLFxuICAgIHdhbGtcbiAgfTtcbiAgZnVuY3Rpb24gd2FsayhwYXJlbnQsIHN0YXRlKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbY29udGV4dC5jdXJyZW50XTtcbiAgICBjb250ZXh0LnBhcmVudCA9IHBhcmVudDtcbiAgICBjb250ZXh0LnRva2VuID0gdG9rZW47XG4gICAgY29udGV4dC5jdXJyZW50Kys7XG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICBjYXNlIFRva2VuVHlwZXMuQWx0ZXJuYXRvcjpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUFsdGVybmF0aXZlKCk7XG4gICAgICBjYXNlIFRva2VuVHlwZXMuQXNzZXJ0aW9uOlxuICAgICAgICByZXR1cm4gY3JlYXRlQXNzZXJ0aW9uRnJvbVRva2VuKHRva2VuKTtcbiAgICAgIGNhc2UgVG9rZW5UeXBlcy5CYWNrcmVmZXJlbmNlOlxuICAgICAgICByZXR1cm4gcGFyc2VCYWNrcmVmZXJlbmNlKGNvbnRleHQpO1xuICAgICAgY2FzZSBUb2tlblR5cGVzLkNoYXJhY3RlcjpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNoYXJhY3Rlcih0b2tlbi52YWx1ZSwgeyB1c2VMYXN0VmFsaWQ6ICEhc3RhdGUuaXNDaGVja2luZ1JhbmdlRW5kIH0pO1xuICAgICAgY2FzZSBUb2tlblR5cGVzLkNoYXJhY3RlckNsYXNzSHlwaGVuOlxuICAgICAgICByZXR1cm4gcGFyc2VDaGFyYWN0ZXJDbGFzc0h5cGhlbihjb250ZXh0LCBzdGF0ZSk7XG4gICAgICBjYXNlIFRva2VuVHlwZXMuQ2hhcmFjdGVyQ2xhc3NPcGVuOlxuICAgICAgICByZXR1cm4gcGFyc2VDaGFyYWN0ZXJDbGFzc09wZW4oY29udGV4dCwgc3RhdGUpO1xuICAgICAgY2FzZSBUb2tlblR5cGVzLkNoYXJhY3RlclNldDpcbiAgICAgICAgcmV0dXJuIHBhcnNlQ2hhcmFjdGVyU2V0KGNvbnRleHQpO1xuICAgICAgY2FzZSBUb2tlblR5cGVzLkRpcmVjdGl2ZTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURpcmVjdGl2ZUZyb21Ub2tlbih0b2tlbik7XG4gICAgICBjYXNlIFRva2VuVHlwZXMuR3JvdXBPcGVuOlxuICAgICAgICByZXR1cm4gcGFyc2VHcm91cE9wZW4oY29udGV4dCwgc3RhdGUpO1xuICAgICAgY2FzZSBUb2tlblR5cGVzLlF1YW50aWZpZXI6XG4gICAgICAgIHJldHVybiBwYXJzZVF1YW50aWZpZXIoY29udGV4dCk7XG4gICAgICBjYXNlIFRva2VuVHlwZXMuU3Vicm91dGluZTpcbiAgICAgICAgcmV0dXJuIHBhcnNlU3Vicm91dGluZShjb250ZXh0KTtcbiAgICAgIGNhc2UgVG9rZW5UeXBlcy5WYXJpYWJsZUxlbmd0aENoYXJhY3RlclNldDpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0KHRva2VuLmtpbmQpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHRva2VuIHR5cGUgXCIke3Rva2VuLnR5cGV9XCJgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgYXN0ID0gY3JlYXRlUmVnZXgoY3JlYXRlUGF0dGVybigpLCBjcmVhdGVGbGFncyhmbGFncykpO1xuICBsZXQgdG9wID0gYXN0LnBhdHRlcm4uYWx0ZXJuYXRpdmVzWzBdO1xuICB3aGlsZSAoY29udGV4dC5jdXJyZW50IDwgdG9rZW5zLmxlbmd0aCkge1xuICAgIGNvbnN0IG5vZGUgPSB3YWxrKHRvcCwge30pO1xuICAgIGlmIChub2RlLnR5cGUgPT09IEFzdFR5cGVzLkFsdGVybmF0aXZlKSB7XG4gICAgICBhc3QucGF0dGVybi5hbHRlcm5hdGl2ZXMucHVzaChub2RlKTtcbiAgICAgIHRvcCA9IG5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcC5lbGVtZW50cy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuICBjb25zdCB7IGNhcHR1cmluZ0dyb3VwcywgaGFzTnVtYmVyZWRSZWYsIG5hbWVkR3JvdXBzQnlOYW1lLCBzdWJyb3V0aW5lcyB9ID0gY29udGV4dDtcbiAgaWYgKGhhc051bWJlcmVkUmVmICYmIG5hbWVkR3JvdXBzQnlOYW1lLnNpemUgJiYgIXJ1bGVzLmNhcHR1cmVHcm91cCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlcmVkIGJhY2tyZWYvc3Vicm91dGluZSBub3QgYWxsb3dlZCB3aGVuIHVzaW5nIG5hbWVkIGNhcHR1cmVcIik7XG4gIH1cbiAgZm9yIChjb25zdCB7IHJlZiB9IG9mIHN1YnJvdXRpbmVzKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChyZWYgPiBjYXB0dXJpbmdHcm91cHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU3Vicm91dGluZSB1c2VzIGEgZ3JvdXAgbnVtYmVyIHRoYXQncyBub3QgZGVmaW5lZGApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW5hbWVkR3JvdXBzQnlOYW1lLmhhcyhyZWYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmBTdWJyb3V0aW5lIHVzZXMgYSBncm91cCBuYW1lIHRoYXQncyBub3QgZGVmaW5lZCBcIlxcZzwke3JlZn0+XCJgKTtcbiAgICB9IGVsc2UgaWYgKG5hbWVkR3JvdXBzQnlOYW1lLmdldChyZWYpLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyYFN1YnJvdXRpbmUgdXNlcyBhIGR1cGxpY2F0ZSBncm91cCBuYW1lIFwiXFxnPCR7cmVmfT5cImApO1xuICAgIH1cbiAgfVxuICB0cmF2ZXJzZSh7IG5vZGU6IGFzdCB9LCBudWxsLCB7XG4gICAgQW55Tm9kZSh7IG5vZGUsIHBhcmVudCB9KSB7XG4gICAgICBub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYXN0O1xufVxuZnVuY3Rpb24gcGFyc2VCYWNrcmVmZXJlbmNlKGNvbnRleHQpIHtcbiAgY29uc3QgeyByYXcgfSA9IGNvbnRleHQudG9rZW47XG4gIGNvbnN0IGhhc0tXcmFwcGVyID0gL15cXFxca1s8J10vLnRlc3QocmF3KTtcbiAgY29uc3QgcmVmID0gaGFzS1dyYXBwZXIgPyByYXcuc2xpY2UoMywgLTEpIDogcmF3LnNsaWNlKDEpO1xuICBjb25zdCBmcm9tTnVtID0gKG51bSwgaXNSZWxhdGl2ZSA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgbnVtQ2FwdHVyZXNUb0xlZnQgPSBjb250ZXh0LmNhcHR1cmluZ0dyb3Vwcy5sZW5ndGg7XG4gICAgbGV0IG9ycGhhbiA9IGZhbHNlO1xuICAgIGlmIChudW0gPiBudW1DYXB0dXJlc1RvTGVmdCkge1xuICAgICAgaWYgKGNvbnRleHQuc2tpcEJhY2tyZWZWYWxpZGF0aW9uKSB7XG4gICAgICAgIG9ycGhhbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBlbm91Z2ggY2FwdHVyaW5nIGdyb3VwcyBkZWZpbmVkIHRvIHRoZSBsZWZ0IFwiJHtyYXd9XCJgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29udGV4dC5oYXNOdW1iZXJlZFJlZiA9IHRydWU7XG4gICAgcmV0dXJuIGNyZWF0ZUJhY2tyZWZlcmVuY2UoaXNSZWxhdGl2ZSA/IG51bUNhcHR1cmVzVG9MZWZ0ICsgMSAtIG51bSA6IG51bSwgeyBvcnBoYW4gfSk7XG4gIH07XG4gIGlmIChoYXNLV3JhcHBlcikge1xuICAgIGNvbnN0IG51bWJlcmVkUmVmID0gL14oPzxzaWduPi0/KTAqKD88bnVtPlsxLTldXFxkKikkLy5leGVjKHJlZik7XG4gICAgaWYgKG51bWJlcmVkUmVmKSB7XG4gICAgICByZXR1cm4gZnJvbU51bSgrbnVtYmVyZWRSZWYuZ3JvdXBzLm51bSwgISFudW1iZXJlZFJlZi5ncm91cHMuc2lnbik7XG4gICAgfVxuICAgIGlmICgvWy0rXS8udGVzdChyZWYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYmFja3JlZiBuYW1lIFwiJHtyYXd9XCJgKTtcbiAgICB9XG4gICAgaWYgKCFjb250ZXh0Lm5hbWVkR3JvdXBzQnlOYW1lLmhhcyhyZWYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEdyb3VwIG5hbWUgbm90IGRlZmluZWQgdG8gdGhlIGxlZnQgXCIke3Jhd31cImApO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQmFja3JlZmVyZW5jZShyZWYpO1xuICB9XG4gIHJldHVybiBmcm9tTnVtKCtyZWYpO1xufVxuZnVuY3Rpb24gcGFyc2VDaGFyYWN0ZXJDbGFzc0h5cGhlbihjb250ZXh0LCBzdGF0ZSkge1xuICBjb25zdCB7IHBhcmVudCwgdG9rZW5zLCB3YWxrIH0gPSBjb250ZXh0O1xuICBjb25zdCBwcmV2U2libGluZ05vZGUgPSBwYXJlbnQuZWxlbWVudHMuYXQoLTEpO1xuICBjb25zdCBuZXh0VG9rZW4gPSB0b2tlbnNbY29udGV4dC5jdXJyZW50XTtcbiAgaWYgKCFzdGF0ZS5pc0NoZWNraW5nUmFuZ2VFbmQgJiYgcHJldlNpYmxpbmdOb2RlICYmIHByZXZTaWJsaW5nTm9kZS50eXBlICE9PSBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzcyAmJiBwcmV2U2libGluZ05vZGUudHlwZSAhPT0gQXN0VHlwZXMuQ2hhcmFjdGVyQ2xhc3NSYW5nZSAmJiBuZXh0VG9rZW4gJiYgbmV4dFRva2VuLnR5cGUgIT09IFRva2VuVHlwZXMuQ2hhcmFjdGVyQ2xhc3NPcGVuICYmIG5leHRUb2tlbi50eXBlICE9PSBUb2tlblR5cGVzLkNoYXJhY3RlckNsYXNzQ2xvc2UgJiYgbmV4dFRva2VuLnR5cGUgIT09IFRva2VuVHlwZXMuQ2hhcmFjdGVyQ2xhc3NJbnRlcnNlY3Rvcikge1xuICAgIGNvbnN0IG5leHROb2RlID0gd2FsayhwYXJlbnQsIHtcbiAgICAgIC4uLnN0YXRlLFxuICAgICAgaXNDaGVja2luZ1JhbmdlRW5kOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHByZXZTaWJsaW5nTm9kZS50eXBlID09PSBBc3RUeXBlcy5DaGFyYWN0ZXIgJiYgbmV4dE5vZGUudHlwZSA9PT0gQXN0VHlwZXMuQ2hhcmFjdGVyKSB7XG4gICAgICBwYXJlbnQuZWxlbWVudHMucG9wKCk7XG4gICAgICByZXR1cm4gY3JlYXRlQ2hhcmFjdGVyQ2xhc3NSYW5nZShwcmV2U2libGluZ05vZGUsIG5leHROb2RlKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjaGFyYWN0ZXIgY2xhc3MgcmFuZ2VcIik7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYXJhY3Rlcig0NSk7XG59XG5mdW5jdGlvbiBwYXJzZUNoYXJhY3RlckNsYXNzT3Blbihjb250ZXh0LCBzdGF0ZSkge1xuICBjb25zdCB7IHRva2VuLCB0b2tlbnMsIHZlcmJvc2UsIHdhbGsgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IGZpcnN0Q2xhc3NUb2tlbiA9IHRva2Vuc1tjb250ZXh0LmN1cnJlbnRdO1xuICBsZXQgbm9kZSA9IGNyZWF0ZUNoYXJhY3RlckNsYXNzKHsgbmVnYXRlOiB0b2tlbi5uZWdhdGUgfSk7XG4gIGNvbnN0IGludGVyc2VjdGlvbiA9IG5vZGUuZWxlbWVudHNbMF07XG4gIGxldCBuZXh0VG9rZW4gPSB0aHJvd0lmVW5jbG9zZWRDaGFyYWN0ZXJDbGFzcyhmaXJzdENsYXNzVG9rZW4pO1xuICB3aGlsZSAobmV4dFRva2VuLnR5cGUgIT09IFRva2VuVHlwZXMuQ2hhcmFjdGVyQ2xhc3NDbG9zZSkge1xuICAgIGlmIChuZXh0VG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlcy5DaGFyYWN0ZXJDbGFzc0ludGVyc2VjdG9yKSB7XG4gICAgICBpbnRlcnNlY3Rpb24uY2xhc3Nlcy5wdXNoKGNyZWF0ZUNoYXJhY3RlckNsYXNzKHsgbmVnYXRlOiBmYWxzZSwgYmFzZU9ubHk6IHRydWUgfSkpO1xuICAgICAgY29udGV4dC5jdXJyZW50Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNjID0gaW50ZXJzZWN0aW9uLmNsYXNzZXMuYXQoLTEpO1xuICAgICAgY2MuZWxlbWVudHMucHVzaCh3YWxrKGNjLCBzdGF0ZSkpO1xuICAgIH1cbiAgICBuZXh0VG9rZW4gPSB0aHJvd0lmVW5jbG9zZWRDaGFyYWN0ZXJDbGFzcyh0b2tlbnNbY29udGV4dC5jdXJyZW50XSwgZmlyc3RDbGFzc1Rva2VuKTtcbiAgfVxuICBpZiAoIXZlcmJvc2UpIHtcbiAgICBvcHRpbWl6ZUNoYXJhY3RlckNsYXNzSW50ZXJzZWN0aW9uKGludGVyc2VjdGlvbik7XG4gIH1cbiAgaWYgKGludGVyc2VjdGlvbi5jbGFzc2VzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGNjID0gaW50ZXJzZWN0aW9uLmNsYXNzZXNbMF07XG4gICAgY2MubmVnYXRlID0gbm9kZS5uZWdhdGUgIT09IGNjLm5lZ2F0ZTtcbiAgICBub2RlID0gY2M7XG4gIH1cbiAgY29udGV4dC5jdXJyZW50Kys7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcGFyc2VDaGFyYWN0ZXJTZXQoeyB0b2tlbiwgc2tpcFByb3BlcnR5TmFtZVZhbGlkYXRpb24gfSkge1xuICBsZXQgeyBraW5kLCBuZWdhdGUsIHZhbHVlIH0gPSB0b2tlbjtcbiAgaWYgKGtpbmQgPT09IFRva2VuQ2hhcmFjdGVyU2V0S2luZHMucHJvcGVydHkpIHtcbiAgICBjb25zdCBub3JtYWxpemVkID0gc2x1Zyh2YWx1ZSk7XG4gICAgaWYgKFBvc2l4UHJvcGVydGllcy5oYXMobm9ybWFsaXplZCkpIHtcbiAgICAgIGtpbmQgPSBUb2tlbkNoYXJhY3RlclNldEtpbmRzLnBvc2l4O1xuICAgICAgdmFsdWUgPSBub3JtYWxpemVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3JlYXRlVW5pY29kZVByb3BlcnR5KHZhbHVlLCB7XG4gICAgICAgIG5lZ2F0ZSxcbiAgICAgICAgc2tpcFByb3BlcnR5TmFtZVZhbGlkYXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoa2luZCA9PT0gVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcy5wb3NpeCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBBc3RUeXBlcy5DaGFyYWN0ZXJTZXQsXG4gICAgICBraW5kOiBBc3RDaGFyYWN0ZXJTZXRLaW5kcy5wb3NpeCxcbiAgICAgIG5lZ2F0ZSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhcmFjdGVyU2V0KGtpbmQsIHsgbmVnYXRlIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VHcm91cE9wZW4oY29udGV4dCwgc3RhdGUpIHtcbiAgY29uc3QgeyB0b2tlbiwgdG9rZW5zLCBjYXB0dXJpbmdHcm91cHMsIG5hbWVkR3JvdXBzQnlOYW1lLCBza2lwTG9va2JlaGluZFZhbGlkYXRpb24sIHZlcmJvc2UsIHdhbGsgfSA9IGNvbnRleHQ7XG4gIGxldCBub2RlID0gY3JlYXRlQnlHcm91cEtpbmQodG9rZW4pO1xuICBjb25zdCBpc0Fic2VudEZ1bmN0aW9uID0gbm9kZS50eXBlID09PSBBc3RUeXBlcy5BYnNlbnRGdW5jdGlvbjtcbiAgY29uc3QgaXNMb29rYmVoaW5kID0gbm9kZS5raW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy5sb29rYmVoaW5kO1xuICBjb25zdCBpc05lZ0xvb2tiZWhpbmQgPSBpc0xvb2tiZWhpbmQgJiYgbm9kZS5uZWdhdGU7XG4gIGlmIChub2RlLnR5cGUgPT09IEFzdFR5cGVzLkNhcHR1cmluZ0dyb3VwKSB7XG4gICAgY2FwdHVyaW5nR3JvdXBzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUubmFtZSkge1xuICAgICAgZ2V0T3JJbnNlcnQobmFtZWRHcm91cHNCeU5hbWUsIG5vZGUubmFtZSwgW10pLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG4gIGlmIChpc0Fic2VudEZ1bmN0aW9uICYmIHN0YXRlLmlzSW5BYnNlbnRGdW5jdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5lc3RlZCBhYnNlbnQgZnVuY3Rpb24gbm90IHN1cHBvcnRlZCBieSBPbmlndXJ1bWFcIik7XG4gIH1cbiAgbGV0IG5leHRUb2tlbiA9IHRocm93SWZVbmNsb3NlZEdyb3VwKHRva2Vuc1tjb250ZXh0LmN1cnJlbnRdKTtcbiAgd2hpbGUgKG5leHRUb2tlbi50eXBlICE9PSBUb2tlblR5cGVzLkdyb3VwQ2xvc2UpIHtcbiAgICBpZiAobmV4dFRva2VuLnR5cGUgPT09IFRva2VuVHlwZXMuQWx0ZXJuYXRvcikge1xuICAgICAgbm9kZS5hbHRlcm5hdGl2ZXMucHVzaChjcmVhdGVBbHRlcm5hdGl2ZSgpKTtcbiAgICAgIGNvbnRleHQuY3VycmVudCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhbHQgPSBub2RlLmFsdGVybmF0aXZlcy5hdCgtMSk7XG4gICAgICBjb25zdCBjaGlsZCA9IHdhbGsoYWx0LCB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBpc0luQWJzZW50RnVuY3Rpb246IHN0YXRlLmlzSW5BYnNlbnRGdW5jdGlvbiB8fCBpc0Fic2VudEZ1bmN0aW9uLFxuICAgICAgICBpc0luTG9va2JlaGluZDogc3RhdGUuaXNJbkxvb2tiZWhpbmQgfHwgaXNMb29rYmVoaW5kLFxuICAgICAgICBpc0luTmVnTG9va2JlaGluZDogc3RhdGUuaXNJbk5lZ0xvb2tiZWhpbmQgfHwgaXNOZWdMb29rYmVoaW5kXG4gICAgICB9KTtcbiAgICAgIGFsdC5lbGVtZW50cy5wdXNoKGNoaWxkKTtcbiAgICAgIGlmICgoaXNMb29rYmVoaW5kIHx8IHN0YXRlLmlzSW5Mb29rYmVoaW5kKSAmJiAhc2tpcExvb2tiZWhpbmRWYWxpZGF0aW9uKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IFwiTG9va2JlaGluZCBpbmNsdWRlcyBhIHBhdHRlcm4gbm90IGFsbG93ZWQgYnkgT25pZ3VydW1hXCI7XG4gICAgICAgIGlmIChpc05lZ0xvb2tiZWhpbmQgfHwgc3RhdGUuaXNJbk5lZ0xvb2tiZWhpbmQpIHtcbiAgICAgICAgICBpZiAoY2hpbGQua2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMubG9va2FoZWFkIHx8IGNoaWxkLnR5cGUgPT09IEFzdFR5cGVzLkNhcHR1cmluZ0dyb3VwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNoaWxkLmtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLmxvb2thaGVhZCB8fCBjaGlsZC5raW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy5sb29rYmVoaW5kICYmIGNoaWxkLm5lZ2F0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG5leHRUb2tlbiA9IHRocm93SWZVbmNsb3NlZEdyb3VwKHRva2Vuc1tjb250ZXh0LmN1cnJlbnRdKTtcbiAgfVxuICBpZiAoIXZlcmJvc2UpIHtcbiAgICBub2RlID0gZ2V0T3B0aW1pemVkR3JvdXAobm9kZSk7XG4gIH1cbiAgY29udGV4dC5jdXJyZW50Kys7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcGFyc2VRdWFudGlmaWVyKHsgdG9rZW4sIHBhcmVudCB9KSB7XG4gIGNvbnN0IHsgbWluLCBtYXgsIGdyZWVkeSwgcG9zc2Vzc2l2ZTogcG9zc2Vzc2l2ZTIgfSA9IHRva2VuO1xuICBjb25zdCBxdWFudGlmaWVkTm9kZSA9IHBhcmVudC5lbGVtZW50cy5hdCgtMSk7XG4gIGlmICghcXVhbnRpZmllZE5vZGUgfHwgcXVhbnRpZmllZE5vZGUudHlwZSA9PT0gQXN0VHlwZXMuQXNzZXJ0aW9uIHx8IHF1YW50aWZpZWROb2RlLnR5cGUgPT09IEFzdFR5cGVzLkRpcmVjdGl2ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgUXVhbnRpZmllciByZXF1aXJlcyBhIHJlcGVhdGFibGUgdG9rZW5gKTtcbiAgfVxuICBjb25zdCBub2RlID0gY3JlYXRlUXVhbnRpZmllcihxdWFudGlmaWVkTm9kZSwgbWluLCBtYXgsIGdyZWVkeSwgcG9zc2Vzc2l2ZTIpO1xuICBwYXJlbnQuZWxlbWVudHMucG9wKCk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcGFyc2VTdWJyb3V0aW5lKGNvbnRleHQpIHtcbiAgY29uc3QgeyB0b2tlbiwgY2FwdHVyaW5nR3JvdXBzLCBzdWJyb3V0aW5lcyB9ID0gY29udGV4dDtcbiAgbGV0IHJlZiA9IHRva2VuLnJhdy5zbGljZSgzLCAtMSk7XG4gIGNvbnN0IG51bWJlcmVkUmVmID0gL14oPzxzaWduPlstK10/KTAqKD88bnVtPlsxLTldXFxkKikkLy5leGVjKHJlZik7XG4gIGlmIChudW1iZXJlZFJlZikge1xuICAgIGNvbnN0IG51bSA9ICtudW1iZXJlZFJlZi5ncm91cHMubnVtO1xuICAgIGNvbnN0IG51bUNhcHR1cmVzVG9MZWZ0ID0gY2FwdHVyaW5nR3JvdXBzLmxlbmd0aDtcbiAgICBjb250ZXh0Lmhhc051bWJlcmVkUmVmID0gdHJ1ZTtcbiAgICByZWYgPSB7XG4gICAgICBcIlwiOiBudW0sXG4gICAgICBcIitcIjogbnVtQ2FwdHVyZXNUb0xlZnQgKyBudW0sXG4gICAgICBcIi1cIjogbnVtQ2FwdHVyZXNUb0xlZnQgKyAxIC0gbnVtXG4gICAgfVtudW1iZXJlZFJlZi5ncm91cHMuc2lnbl07XG4gICAgaWYgKHJlZiA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3Vicm91dGluZSBudW1iZXJcIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJlZiA9PT0gXCIwXCIpIHtcbiAgICByZWYgPSAwO1xuICB9XG4gIGNvbnN0IG5vZGUgPSBjcmVhdGVTdWJyb3V0aW5lKHJlZik7XG4gIHN1YnJvdXRpbmVzLnB1c2gobm9kZSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY3JlYXRlQWJzZW50RnVuY3Rpb24oa2luZCkge1xuICBpZiAoa2luZCAhPT0gQXN0QWJzZW50RnVuY3Rpb25LaW5kcy5yZXBlYXRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBhYnNlbnQgZnVuY3Rpb24ga2luZCBcIiR7a2luZH1cImApO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuQWJzZW50RnVuY3Rpb24sXG4gICAga2luZCxcbiAgICBhbHRlcm5hdGl2ZXM6IFtjcmVhdGVBbHRlcm5hdGl2ZSgpXVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQWx0ZXJuYXRpdmUoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuQWx0ZXJuYXRpdmUsXG4gICAgZWxlbWVudHM6IFtdXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVBc3NlcnRpb24oa2luZCwgb3B0aW9ucykge1xuICBjb25zdCBuZWdhdGUgPSAhIW9wdGlvbnM/Lm5lZ2F0ZTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBc3RUeXBlcy5Bc3NlcnRpb24sXG4gICAga2luZCxcbiAgICAuLi5raW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy53b3JkX2JvdW5kYXJ5ICYmIHsgbmVnYXRlIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFzc2VydGlvbkZyb21Ub2tlbih7IGtpbmQgfSkge1xuICByZXR1cm4gY3JlYXRlQXNzZXJ0aW9uKFxuICAgIHRocm93SWZOb3Qoe1xuICAgICAgXCJeXCI6IEFzdEFzc2VydGlvbktpbmRzLmxpbmVfc3RhcnQsXG4gICAgICBcIiRcIjogQXN0QXNzZXJ0aW9uS2luZHMubGluZV9lbmQsXG4gICAgICBcIlxcXFxBXCI6IEFzdEFzc2VydGlvbktpbmRzLnN0cmluZ19zdGFydCxcbiAgICAgIFwiXFxcXGJcIjogQXN0QXNzZXJ0aW9uS2luZHMud29yZF9ib3VuZGFyeSxcbiAgICAgIFwiXFxcXEJcIjogQXN0QXNzZXJ0aW9uS2luZHMud29yZF9ib3VuZGFyeSxcbiAgICAgIFwiXFxcXEdcIjogQXN0QXNzZXJ0aW9uS2luZHMuc2VhcmNoX3N0YXJ0LFxuICAgICAgXCJcXFxcelwiOiBBc3RBc3NlcnRpb25LaW5kcy5zdHJpbmdfZW5kLFxuICAgICAgXCJcXFxcWlwiOiBBc3RBc3NlcnRpb25LaW5kcy5zdHJpbmdfZW5kX25ld2xpbmVcbiAgICB9W2tpbmRdLCBgVW5leHBlY3RlZCBhc3NlcnRpb24ga2luZCBcIiR7a2luZH1cImApLFxuICAgIHsgbmVnYXRlOiBraW5kID09PSByYFxcQmAgfVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlQmFja3JlZmVyZW5jZShyZWYsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3JwaGFuID0gISFvcHRpb25zPy5vcnBoYW47XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuQmFja3JlZmVyZW5jZSxcbiAgICAuLi5vcnBoYW4gJiYgeyBvcnBoYW4gfSxcbiAgICByZWZcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJ5R3JvdXBLaW5kKHsgZmxhZ3MsIGtpbmQsIG5hbWUsIG5lZ2F0ZSwgbnVtYmVyIH0pIHtcbiAgc3dpdGNoIChraW5kKSB7XG4gICAgY2FzZSBUb2tlbkdyb3VwS2luZHMuYWJzZW50X3JlcGVhdGVyOlxuICAgICAgcmV0dXJuIGNyZWF0ZUFic2VudEZ1bmN0aW9uKEFzdEFic2VudEZ1bmN0aW9uS2luZHMucmVwZWF0ZXIpO1xuICAgIGNhc2UgVG9rZW5Hcm91cEtpbmRzLmF0b21pYzpcbiAgICAgIHJldHVybiBjcmVhdGVHcm91cCh7IGF0b21pYzogdHJ1ZSB9KTtcbiAgICBjYXNlIFRva2VuR3JvdXBLaW5kcy5jYXB0dXJpbmc6XG4gICAgICByZXR1cm4gY3JlYXRlQ2FwdHVyaW5nR3JvdXAobnVtYmVyLCBuYW1lKTtcbiAgICBjYXNlIFRva2VuR3JvdXBLaW5kcy5ncm91cDpcbiAgICAgIHJldHVybiBjcmVhdGVHcm91cCh7IGZsYWdzIH0pO1xuICAgIGNhc2UgVG9rZW5Hcm91cEtpbmRzLmxvb2thaGVhZDpcbiAgICBjYXNlIFRva2VuR3JvdXBLaW5kcy5sb29rYmVoaW5kOlxuICAgICAgcmV0dXJuIGNyZWF0ZUxvb2thcm91bmQoe1xuICAgICAgICBiZWhpbmQ6IGtpbmQgPT09IFRva2VuR3JvdXBLaW5kcy5sb29rYmVoaW5kLFxuICAgICAgICBuZWdhdGVcbiAgICAgIH0pO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZ3JvdXAga2luZCBcIiR7a2luZH1cImApO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDYXB0dXJpbmdHcm91cChudW1iZXIsIG5hbWUpIHtcbiAgY29uc3QgaGFzTmFtZSA9IG5hbWUgIT09IHZvaWQgMDtcbiAgaWYgKGhhc05hbWUgJiYgIWlzVmFsaWRHcm91cE5hbWVPbmlndXJ1bWEobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEdyb3VwIG5hbWUgXCIke25hbWV9XCIgaW52YWxpZCBpbiBPbmlndXJ1bWFgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdFR5cGVzLkNhcHR1cmluZ0dyb3VwLFxuICAgIG51bWJlcixcbiAgICAuLi5oYXNOYW1lICYmIHsgbmFtZSB9LFxuICAgIGFsdGVybmF0aXZlczogW2NyZWF0ZUFsdGVybmF0aXZlKCldXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDaGFyYWN0ZXIoY2hhckNvZGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICB1c2VMYXN0VmFsaWQ6IGZhbHNlLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgaWYgKGNoYXJDb2RlID4gMTExNDExMSkge1xuICAgIGNvbnN0IGhleCA9IGNoYXJDb2RlLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAob3B0cy51c2VMYXN0VmFsaWQpIHtcbiAgICAgIGNoYXJDb2RlID0gMTExNDExMTtcbiAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID4gMTMxMDcxOSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvZGUgcG9pbnQgb3V0IG9mIHJhbmdlIFwiXFxcXHh7JHtoZXh9fVwiYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb2RlIHBvaW50IG91dCBvZiByYW5nZSBpbiBKUyBcIlxcXFx4eyR7aGV4fX1cImApO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdFR5cGVzLkNoYXJhY3RlcixcbiAgICB2YWx1ZTogY2hhckNvZGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNoYXJhY3RlckNsYXNzKG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBiYXNlT25seTogZmFsc2UsXG4gICAgbmVnYXRlOiBmYWxzZSxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuQ2hhcmFjdGVyQ2xhc3MsXG4gICAgbmVnYXRlOiBvcHRzLm5lZ2F0ZSxcbiAgICBlbGVtZW50czogb3B0cy5iYXNlT25seSA/IFtdIDogW2NyZWF0ZUNoYXJhY3RlckNsYXNzSW50ZXJzZWN0aW9uKCldXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDaGFyYWN0ZXJDbGFzc0ludGVyc2VjdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzc0ludGVyc2VjdGlvbixcbiAgICBjbGFzc2VzOiBbY3JlYXRlQ2hhcmFjdGVyQ2xhc3MoeyBuZWdhdGU6IGZhbHNlLCBiYXNlT25seTogdHJ1ZSB9KV1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNoYXJhY3RlckNsYXNzUmFuZ2UobWluLCBtYXgpIHtcbiAgaWYgKG1heC52YWx1ZSA8IG1pbi52YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNoYXJhY3RlciBjbGFzcyByYW5nZSBvdXQgb2Ygb3JkZXJcIik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzc1JhbmdlLFxuICAgIG1pbixcbiAgICBtYXhcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNoYXJhY3RlclNldChraW5kLCB7IG5lZ2F0ZSB9KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogQXN0VHlwZXMuQ2hhcmFjdGVyU2V0LFxuICAgIGtpbmQ6IHRocm93SWZOb3QoQXN0Q2hhcmFjdGVyU2V0S2luZHNba2luZF0sIGBVbmV4cGVjdGVkIGNoYXJhY3RlciBzZXQga2luZCBcIiR7a2luZH1cImApXG4gIH07XG4gIGlmIChraW5kID09PSBUb2tlbkNoYXJhY3RlclNldEtpbmRzLmRpZ2l0IHx8IGtpbmQgPT09IFRva2VuQ2hhcmFjdGVyU2V0S2luZHMuaGV4IHx8IGtpbmQgPT09IFRva2VuQ2hhcmFjdGVyU2V0S2luZHMuc3BhY2UgfHwga2luZCA9PT0gVG9rZW5DaGFyYWN0ZXJTZXRLaW5kcy53b3JkKSB7XG4gICAgbm9kZS5uZWdhdGUgPSBuZWdhdGU7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjcmVhdGVEaXJlY3RpdmVGcm9tVG9rZW4oeyBraW5kLCBmbGFncyB9KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogQXN0VHlwZXMuRGlyZWN0aXZlLFxuICAgIGtpbmQ6IHRocm93SWZOb3QoQXN0RGlyZWN0aXZlS2luZHNba2luZF0sIGBVbmV4cGVjdGVkIGRpcmVjdGl2ZSBraW5kIFwiJHtraW5kfVwiYClcbiAgfTtcbiAgaWYgKGtpbmQgPT09IFRva2VuRGlyZWN0aXZlS2luZHMuZmxhZ3MpIHtcbiAgICBub2RlLmZsYWdzID0gZmxhZ3M7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjcmVhdGVGbGFncyh7IGlnbm9yZUNhc2UsIGRvdEFsbCwgZXh0ZW5kZWQsIGRpZ2l0SXNBc2NpaSwgc3BhY2VJc0FzY2lpLCB3b3JkSXNBc2NpaSB9KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuRmxhZ3MsXG4gICAgaWdub3JlQ2FzZSxcbiAgICBkb3RBbGwsXG4gICAgZXh0ZW5kZWQsXG4gICAgZGlnaXRJc0FzY2lpLFxuICAgIHNwYWNlSXNBc2NpaSxcbiAgICB3b3JkSXNBc2NpaVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlR3JvdXAob3B0aW9ucykge1xuICBjb25zdCBhdG9taWMyID0gb3B0aW9ucz8uYXRvbWljO1xuICBjb25zdCBmbGFncyA9IG9wdGlvbnM/LmZsYWdzO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdFR5cGVzLkdyb3VwLFxuICAgIC4uLmF0b21pYzIgJiYgeyBhdG9taWM6IGF0b21pYzIgfSxcbiAgICAuLi5mbGFncyAmJiB7IGZsYWdzIH0sXG4gICAgYWx0ZXJuYXRpdmVzOiBbY3JlYXRlQWx0ZXJuYXRpdmUoKV1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvb2thcm91bmQob3B0aW9ucykge1xuICBjb25zdCBvcHRzID0ge1xuICAgIGJlaGluZDogZmFsc2UsXG4gICAgbmVnYXRlOiBmYWxzZSxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuQXNzZXJ0aW9uLFxuICAgIGtpbmQ6IG9wdHMuYmVoaW5kID8gQXN0QXNzZXJ0aW9uS2luZHMubG9va2JlaGluZCA6IEFzdEFzc2VydGlvbktpbmRzLmxvb2thaGVhZCxcbiAgICBuZWdhdGU6IG9wdHMubmVnYXRlLFxuICAgIGFsdGVybmF0aXZlczogW2NyZWF0ZUFsdGVybmF0aXZlKCldXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVQYXR0ZXJuKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdFR5cGVzLlBhdHRlcm4sXG4gICAgYWx0ZXJuYXRpdmVzOiBbY3JlYXRlQWx0ZXJuYXRpdmUoKV1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVF1YW50aWZpZXIoZWxlbWVudCwgbWluLCBtYXgsIGdyZWVkeSA9IHRydWUsIHBvc3Nlc3NpdmUyID0gZmFsc2UpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBBc3RUeXBlcy5RdWFudGlmaWVyLFxuICAgIG1pbixcbiAgICBtYXgsXG4gICAgZ3JlZWR5LFxuICAgIHBvc3Nlc3NpdmU6IHBvc3Nlc3NpdmUyLFxuICAgIGVsZW1lbnRcbiAgfTtcbiAgaWYgKG1heCA8IG1pbikge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5ub2RlLFxuICAgICAgbWluOiBtYXgsXG4gICAgICBtYXg6IG1pbixcbiAgICAgIHBvc3Nlc3NpdmU6IHRydWVcbiAgICB9O1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVnZXgocGF0dGVybiwgZmxhZ3MpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBc3RUeXBlcy5SZWdleCxcbiAgICBwYXR0ZXJuLFxuICAgIGZsYWdzXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdWJyb3V0aW5lKHJlZikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdFR5cGVzLlN1YnJvdXRpbmUsXG4gICAgcmVmXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVVbmljb2RlUHJvcGVydHkodmFsdWUsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBuZWdhdGU6IGZhbHNlLFxuICAgIHNraXBQcm9wZXJ0eU5hbWVWYWxpZGF0aW9uOiBmYWxzZSxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIHJldHVybiB7XG4gICAgdHlwZTogQXN0VHlwZXMuQ2hhcmFjdGVyU2V0LFxuICAgIGtpbmQ6IEFzdENoYXJhY3RlclNldEtpbmRzLnByb3BlcnR5LFxuICAgIHZhbHVlOiBvcHRzLnNraXBQcm9wZXJ0eU5hbWVWYWxpZGF0aW9uID8gdmFsdWUgOiBnZXRKc1VuaWNvZGVQcm9wZXJ0eU5hbWUodmFsdWUpLFxuICAgIG5lZ2F0ZTogb3B0cy5uZWdhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0KGtpbmQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBBc3RUeXBlcy5WYXJpYWJsZUxlbmd0aENoYXJhY3RlclNldCxcbiAgICBraW5kOiB0aHJvd0lmTm90KHtcbiAgICAgIFwiXFxcXFJcIjogQXN0VmFyaWFibGVMZW5ndGhDaGFyYWN0ZXJTZXRLaW5kcy5uZXdsaW5lLFxuICAgICAgXCJcXFxcWFwiOiBBc3RWYXJpYWJsZUxlbmd0aENoYXJhY3RlclNldEtpbmRzLmdyYXBoZW1lXG4gICAgfVtraW5kXSwgYFVuZXhwZWN0ZWQgdmFyY2hhcnNldCBraW5kIFwiJHtraW5kfVwiYClcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEpzVW5pY29kZVByb3BlcnR5TmFtZSh2YWx1ZSkge1xuICBjb25zdCBzbHVnZ2VkID0gc2x1Zyh2YWx1ZSk7XG4gIGlmIChKc1VuaWNvZGVQcm9wZXJ0aWVzT2ZTdHJpbmdzTWFwLmhhcyhzbHVnZ2VkKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihyYFVuaWNvZGUgcHJvcGVydHkgXCJcXHB7JHt2YWx1ZX19XCIgdW5zdXBwb3J0ZWQgaW4gT25pZ3VydW1hYCk7XG4gIH1cbiAgY29uc3QganNOYW1lID0gSnNVbmljb2RlUHJvcGVydGllc01hcC5nZXQoc2x1Z2dlZCk7XG4gIGlmIChqc05hbWUpIHtcbiAgICByZXR1cm4ganNOYW1lO1xuICB9XG4gIHJldHVybiB2YWx1ZS50cmltKCkucmVwbGFjZSgvWy0gX10rL2csIFwiX1wiKS5yZXBsYWNlKC9bQS1aXVthLXpdKyg/PVtBLVpdKS9nLCBcIiQmX1wiKS5yZXBsYWNlKC9bQS1aYS16XSsvZywgKG0pID0+IG1bMF0udG9VcHBlckNhc2UoKSArIG0uc2xpY2UoMSkudG9Mb3dlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBnZXRPcHRpbWl6ZWRHcm91cChub2RlKSB7XG4gIGNvbnN0IGZpcnN0QWx0Rmlyc3RFbCA9IG5vZGUuYWx0ZXJuYXRpdmVzWzBdLmVsZW1lbnRzWzBdO1xuICBpZiAobm9kZS50eXBlID09PSBBc3RUeXBlcy5Hcm91cCAmJiBoYXNPbmx5Q2hpbGQobm9kZSwgKGtpZCkgPT4ga2lkLnR5cGUgPT09IEFzdFR5cGVzLkdyb3VwKSAmJiAhKG5vZGUuYXRvbWljICYmIGZpcnN0QWx0Rmlyc3RFbC5mbGFncykgJiYgIShub2RlLmZsYWdzICYmIChmaXJzdEFsdEZpcnN0RWwuYXRvbWljIHx8IGZpcnN0QWx0Rmlyc3RFbC5mbGFncykpKSB7XG4gICAgaWYgKG5vZGUuYXRvbWljKSB7XG4gICAgICBmaXJzdEFsdEZpcnN0RWwuYXRvbWljID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuZmxhZ3MpIHtcbiAgICAgIGZpcnN0QWx0Rmlyc3RFbC5mbGFncyA9IG5vZGUuZmxhZ3M7XG4gICAgfVxuICAgIHJldHVybiBmaXJzdEFsdEZpcnN0RWw7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBpc1ZhbGlkR3JvdXBOYW1lT25pZ3VydW1hKG5hbWUpIHtcbiAgcmV0dXJuIC9eW1xccHtBbHBoYX1cXHB7UGN9XVteKV0qJC91LnRlc3QobmFtZSk7XG59XG5mdW5jdGlvbiBvcHRpbWl6ZUNoYXJhY3RlckNsYXNzSW50ZXJzZWN0aW9uKGludGVyc2VjdGlvbikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGludGVyc2VjdGlvbi5jbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2MgPSBpbnRlcnNlY3Rpb24uY2xhc3Nlc1tpXTtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gY2MuZWxlbWVudHNbMF07XG4gICAgaWYgKGNjLmVsZW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBmaXJzdENoaWxkLnR5cGUgPT09IEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzKSB7XG4gICAgICBpbnRlcnNlY3Rpb24uY2xhc3Nlc1tpXSA9IGZpcnN0Q2hpbGQ7XG4gICAgICBmaXJzdENoaWxkLm5lZ2F0ZSA9IGNjLm5lZ2F0ZSAhPT0gZmlyc3RDaGlsZC5uZWdhdGU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0aHJvd0lmVW5jbG9zZWRDaGFyYWN0ZXJDbGFzcyh0b2tlbiwgZmlyc3RDbGFzc1Rva2VuKSB7XG4gIHJldHVybiB0aHJvd0lmTm90KFxuICAgIHRva2VuLFxuICAgIC8vIEVhc2llciB0byB1bmRlcnN0YW5kIGVycm9yIHdoZW4gYXBwbGljYWJsZVxuICAgIGAke2ZpcnN0Q2xhc3NUb2tlbj8udmFsdWUgPT09IDkzID8gXCJFbXB0eVwiIDogXCJVbmNsb3NlZFwifSBjaGFyYWN0ZXIgY2xhc3NgXG4gICk7XG59XG5mdW5jdGlvbiB0aHJvd0lmVW5jbG9zZWRHcm91cCh0b2tlbikge1xuICByZXR1cm4gdGhyb3dJZk5vdCh0b2tlbiwgXCJVbmNsb3NlZCBncm91cFwiKTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybS5qc1xuaW1wb3J0IGVtb2ppUmVnZXggZnJvbSBcImVtb2ppLXJlZ2V4LXhzXCI7XG5mdW5jdGlvbiB0cmFuc2Zvcm0oYXN0LCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgLy8gQSBjb3VwbGUgZWRnZSBjYXNlcyBleGlzdCB3aGVyZSBvcHRpb25zIGBhY2N1cmFjeWAgYW5kIGBiZXN0RWZmb3J0VGFyZ2V0YCBhcmUgdXNlZDpcbiAgICAvLyAtIGBWYXJpYWJsZUxlbmd0aENoYXJhY3RlclNldGAga2luZCBgZ3JhcGhlbWVgIChgXFxYYCk6IEFuIGV4YWN0IHJlcHJlc2VudGF0aW9uIHdvdWxkIHJlcXVpcmVcbiAgICAvLyAgIGhlYXZ5IFVuaWNvZGUgZGF0YTsgYSBiZXN0LWVmZm9ydCBhcHByb3hpbWF0aW9uIHJlcXVpcmVzIGtub3dpbmcgdGhlIHRhcmdldC5cbiAgICAvLyAtIGBDaGFyYWN0ZXJTZXRgIGtpbmQgYHBvc2l4YCB3aXRoIHZhbHVlcyBgZ3JhcGhgIGFuZCBgcHJpbnRgOiBUaGVpciBjb21wbGV4IFVuaWNvZGUtYmFzZWRcbiAgICAvLyAgIHJlcHJlc2VudGF0aW9ucyB3b3VsZCBiZSBoYXJkIHRvIGNoYW5nZSB0byBBU0NJSS1iYXNlZCBhZnRlciB0aGUgZmFjdCBpbiB0aGUgZ2VuZXJhdG9yXG4gICAgLy8gICBiYXNlZCBvbiBgdGFyZ2V0YC9gYWNjdXJhY3lgLCBzbyBwcm9kdWNlIHRoZSBhcHByb3ByaWF0ZSBzdHJ1Y3R1cmUgaGVyZS5cbiAgICBhY2N1cmFjeTogXCJkZWZhdWx0XCIsXG4gICAgYXNjaWlXb3JkQm91bmRhcmllczogZmFsc2UsXG4gICAgYXZvaWRTdWJjbGFzczogZmFsc2UsXG4gICAgYmVzdEVmZm9ydFRhcmdldDogXCJFUzIwMjVcIixcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IGZpcnN0UGFzc1N0YXRlID0ge1xuICAgIGFjY3VyYWN5OiBvcHRzLmFjY3VyYWN5LFxuICAgIGFzY2lpV29yZEJvdW5kYXJpZXM6IG9wdHMuYXNjaWlXb3JkQm91bmRhcmllcyxcbiAgICBhdm9pZFN1YmNsYXNzOiBvcHRzLmF2b2lkU3ViY2xhc3MsXG4gICAgZmxhZ0RpcmVjdGl2ZXNCeUFsdDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBqc0dyb3VwTmFtZU1hcDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBtaW5UYXJnZXRFczIwMjQ6IGlzTWluVGFyZ2V0KG9wdHMuYmVzdEVmZm9ydFRhcmdldCwgXCJFUzIwMjRcIiksXG4gICAgcGFzc2VkTG9va2JlaGluZDogZmFsc2UsXG4gICAgc3RyYXRlZ3k6IG51bGwsXG4gICAgLy8gU3Vicm91dGluZXMgY2FuIGFwcGVhciBiZWZvcmUgdGhlIGdyb3VwcyB0aGV5IHJlZiwgc28gY29sbGVjdCByZWZmZWQgbm9kZXMgZm9yIGEgc2Vjb25kIHBhc3MgXG4gICAgc3Vicm91dGluZVJlZk1hcDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBzdXBwb3J0ZWRHTm9kZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgZGlnaXRJc0FzY2lpOiBhc3QuZmxhZ3MuZGlnaXRJc0FzY2lpLFxuICAgIHNwYWNlSXNBc2NpaTogYXN0LmZsYWdzLnNwYWNlSXNBc2NpaSxcbiAgICB3b3JkSXNBc2NpaTogYXN0LmZsYWdzLndvcmRJc0FzY2lpXG4gIH07XG4gIHRyYXZlcnNlKHsgbm9kZTogYXN0IH0sIGZpcnN0UGFzc1N0YXRlLCBGaXJzdFBhc3NWaXNpdG9yKTtcbiAgY29uc3QgZ2xvYmFsRmxhZ3MgPSB7XG4gICAgZG90QWxsOiBhc3QuZmxhZ3MuZG90QWxsLFxuICAgIGlnbm9yZUNhc2U6IGFzdC5mbGFncy5pZ25vcmVDYXNlXG4gIH07XG4gIGNvbnN0IHNlY29uZFBhc3NTdGF0ZSA9IHtcbiAgICBjdXJyZW50RmxhZ3M6IGdsb2JhbEZsYWdzLFxuICAgIHByZXZGbGFnczogbnVsbCxcbiAgICBnbG9iYWxGbGFncyxcbiAgICBncm91cE9yaWdpbkJ5Q29weTogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBncm91cHNCeU5hbWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgbXVsdGlwbGV4Q2FwdHVyZXNUb0xlZnRCeVJlZjogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBvcGVuUmVmczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICByZWZmZWROb2Rlc0J5UmVmZXJlbmNlcjogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBzdWJyb3V0aW5lUmVmTWFwOiBmaXJzdFBhc3NTdGF0ZS5zdWJyb3V0aW5lUmVmTWFwXG4gIH07XG4gIHRyYXZlcnNlKHsgbm9kZTogYXN0IH0sIHNlY29uZFBhc3NTdGF0ZSwgU2Vjb25kUGFzc1Zpc2l0b3IpO1xuICBjb25zdCB0aGlyZFBhc3NTdGF0ZSA9IHtcbiAgICBncm91cHNCeU5hbWU6IHNlY29uZFBhc3NTdGF0ZS5ncm91cHNCeU5hbWUsXG4gICAgaGlnaGVzdE9ycGhhbkJhY2tyZWY6IDAsXG4gICAgbnVtQ2FwdHVyZXNUb0xlZnQ6IDAsXG4gICAgcmVmZmVkTm9kZXNCeVJlZmVyZW5jZXI6IHNlY29uZFBhc3NTdGF0ZS5yZWZmZWROb2Rlc0J5UmVmZXJlbmNlclxuICB9O1xuICB0cmF2ZXJzZSh7IG5vZGU6IGFzdCB9LCB0aGlyZFBhc3NTdGF0ZSwgVGhpcmRQYXNzVmlzaXRvcik7XG4gIGFzdC5fb3JpZ2luTWFwID0gc2Vjb25kUGFzc1N0YXRlLmdyb3VwT3JpZ2luQnlDb3B5O1xuICBhc3QuX3N0cmF0ZWd5ID0gZmlyc3RQYXNzU3RhdGUuc3RyYXRlZ3k7XG4gIHJldHVybiBhc3Q7XG59XG52YXIgRmlyc3RQYXNzVmlzaXRvciA9IHtcbiAgQWJzZW50RnVuY3Rpb24oeyBub2RlLCByZXBsYWNlV2l0aCB9KSB7XG4gICAgY29uc3QgZ3JvdXAgPSBwcmVwQ29udGFpbmVyKGNyZWF0ZUdyb3VwKCksIFtcbiAgICAgIGFkb3B0QW5kU3dhcEtpZHMoY3JlYXRlTG9va2Fyb3VuZCh7IG5lZ2F0ZTogdHJ1ZSB9KSwgbm9kZS5hbHRlcm5hdGl2ZXMpLFxuICAgICAgY3JlYXRlVW5pY29kZVByb3BlcnR5KFwiQW55XCIpXG4gICAgXSk7XG4gICAgY29uc3QgcXVhbnRpZmllciA9IGNyZWF0ZVF1YW50aWZpZXIoZ3JvdXAsIDAsIEluZmluaXR5KTtcbiAgICBncm91cC5wYXJlbnQgPSBxdWFudGlmaWVyO1xuICAgIHJlcGxhY2VXaXRoKHByZXBDb250YWluZXIoY3JlYXRlR3JvdXAoKSwgW3F1YW50aWZpZXJdKSk7XG4gIH0sXG4gIEFsdGVybmF0aXZlOiB7XG4gICAgZW50ZXIoeyBub2RlLCBwYXJlbnQsIGtleSB9LCB7IGZsYWdEaXJlY3RpdmVzQnlBbHQgfSkge1xuICAgICAgY29uc3QgZmxhZ0RpcmVjdGl2ZXMgPSBub2RlLmVsZW1lbnRzLmZpbHRlcigoZWwpID0+IGVsLmtpbmQgPT09IEFzdERpcmVjdGl2ZUtpbmRzLmZsYWdzKTtcbiAgICAgIGZvciAobGV0IGkgPSBrZXkgKyAxOyBpIDwgcGFyZW50LmFsdGVybmF0aXZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmb3J3YXJkU2libGluZ0FsdCA9IHBhcmVudC5hbHRlcm5hdGl2ZXNbaV07XG4gICAgICAgIGdldE9ySW5zZXJ0KGZsYWdEaXJlY3RpdmVzQnlBbHQsIGZvcndhcmRTaWJsaW5nQWx0LCBbXSkucHVzaCguLi5mbGFnRGlyZWN0aXZlcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBleGl0KHsgbm9kZSB9LCB7IGZsYWdEaXJlY3RpdmVzQnlBbHQgfSkge1xuICAgICAgaWYgKGZsYWdEaXJlY3RpdmVzQnlBbHQuZ2V0KG5vZGUpPy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBnZXRDb21iaW5lZEZsYWdNb2RzRnJvbUZsYWdOb2RlcyhmbGFnRGlyZWN0aXZlc0J5QWx0LmdldChub2RlKSk7XG4gICAgICAgIGlmIChmbGFncykge1xuICAgICAgICAgIGNvbnN0IGZsYWdHcm91cCA9IHByZXBDb250YWluZXIoY3JlYXRlR3JvdXAoeyBmbGFncyB9KSwgbm9kZS5lbGVtZW50cyk7XG4gICAgICAgICAgZmxhZ0dyb3VwLnBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgbm9kZS5lbGVtZW50cyA9IFtmbGFnR3JvdXBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBBc3NlcnRpb24oeyBub2RlLCBrZXksIGNvbnRhaW5lciwgYXN0LCByZW1vdmUsIHJlcGxhY2VXaXRoIH0sIHN0YXRlKSB7XG4gICAgY29uc3QgeyBraW5kLCBuZWdhdGUgfSA9IG5vZGU7XG4gICAgY29uc3QgeyBhc2NpaVdvcmRCb3VuZGFyaWVzLCBhdm9pZFN1YmNsYXNzLCBzdXBwb3J0ZWRHTm9kZXMsIHdvcmRJc0FzY2lpIH0gPSBzdGF0ZTtcbiAgICBpZiAoa2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMubGluZV9lbmQpIHtcbiAgICAgIHJlcGxhY2VXaXRoKHBhcnNlRnJhZ21lbnQocmAoPz1cXHp8XFxuKWApKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLmxpbmVfc3RhcnQpIHtcbiAgICAgIHJlcGxhY2VXaXRoKHBhcnNlRnJhZ21lbnQocmAoPzw9XFxBfFxcbig/IVxceikpYCwgeyBza2lwTG9va2JlaGluZFZhbGlkYXRpb246IHRydWUgfSkpO1xuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMubG9va2JlaGluZCkge1xuICAgICAgc3RhdGUucGFzc2VkTG9va2JlaGluZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy5zZWFyY2hfc3RhcnQpIHtcbiAgICAgIGlmIChzdXBwb3J0ZWRHTm9kZXMuaGFzKG5vZGUpKSB7XG4gICAgICAgIGFzdC5mbGFncy5zdGlja3kgPSB0cnVlO1xuICAgICAgICByZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBjb250YWluZXJba2V5IC0gMV07XG4gICAgICAgIGlmIChwcmV2ICYmIGlzQWx3YXlzTm9uWmVyb0xlbmd0aChwcmV2KSkge1xuICAgICAgICAgIHJlcGxhY2VXaXRoKHByZXBDb250YWluZXIoY3JlYXRlTG9va2Fyb3VuZCh7IG5lZ2F0ZTogdHJ1ZSB9KSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGF2b2lkU3ViY2xhc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmBVc2VzIFwiXFxHXCIgaW4gYSB3YXkgdGhhdCByZXF1aXJlcyBhIHN1YmNsYXNzYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVwbGFjZVdpdGgoY3JlYXRlQXNzZXJ0aW9uKEFzdEFzc2VydGlvbktpbmRzLnN0cmluZ19zdGFydCkpO1xuICAgICAgICAgIHN0YXRlLnN0cmF0ZWd5ID0gXCJjbGlwX3NlYXJjaFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy5zdHJpbmdfZW5kX25ld2xpbmUpIHtcbiAgICAgIHJlcGxhY2VXaXRoKHBhcnNlRnJhZ21lbnQocmAoPz1cXG4/XFx6KWApKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLndvcmRfYm91bmRhcnkgJiYgIXdvcmRJc0FzY2lpICYmICFhc2NpaVdvcmRCb3VuZGFyaWVzKSB7XG4gICAgICBjb25zdCBiID0gYCg/Oig/PD0ke2RlZmF1bHRXb3JkQ2hhcn0pKD8hJHtkZWZhdWx0V29yZENoYXJ9KXwoPzwhJHtkZWZhdWx0V29yZENoYXJ9KSg/PSR7ZGVmYXVsdFdvcmRDaGFyfSkpYDtcbiAgICAgIGNvbnN0IEIgPSBgKD86KD88PSR7ZGVmYXVsdFdvcmRDaGFyfSkoPz0ke2RlZmF1bHRXb3JkQ2hhcn0pfCg/PCEke2RlZmF1bHRXb3JkQ2hhcn0pKD8hJHtkZWZhdWx0V29yZENoYXJ9KSlgO1xuICAgICAgcmVwbGFjZVdpdGgocGFyc2VGcmFnbWVudChuZWdhdGUgPyBCIDogYikpO1xuICAgIH1cbiAgfSxcbiAgQmFja3JlZmVyZW5jZSh7IG5vZGUgfSwgeyBqc0dyb3VwTmFtZU1hcCB9KSB7XG4gICAgbGV0IHsgcmVmIH0gPSBub2RlO1xuICAgIGlmICh0eXBlb2YgcmVmID09PSBcInN0cmluZ1wiICYmICFpc1ZhbGlkR3JvdXBOYW1lSnMocmVmKSkge1xuICAgICAgcmVmID0gZ2V0QW5kU3RvcmVKc0dyb3VwTmFtZShyZWYsIGpzR3JvdXBOYW1lTWFwKTtcbiAgICAgIG5vZGUucmVmID0gcmVmO1xuICAgIH1cbiAgfSxcbiAgQ2FwdHVyaW5nR3JvdXAoeyBub2RlIH0sIHsganNHcm91cE5hbWVNYXAsIHN1YnJvdXRpbmVSZWZNYXAgfSkge1xuICAgIGxldCB7IG5hbWUgfSA9IG5vZGU7XG4gICAgaWYgKG5hbWUgJiYgIWlzVmFsaWRHcm91cE5hbWVKcyhuYW1lKSkge1xuICAgICAgbmFtZSA9IGdldEFuZFN0b3JlSnNHcm91cE5hbWUobmFtZSwganNHcm91cE5hbWVNYXApO1xuICAgICAgbm9kZS5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgc3Vicm91dGluZVJlZk1hcC5zZXQobm9kZS5udW1iZXIsIG5vZGUpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICBzdWJyb3V0aW5lUmVmTWFwLnNldChuYW1lLCBub2RlKTtcbiAgICB9XG4gIH0sXG4gIENoYXJhY3RlclNldCh7IG5vZGUsIHJlcGxhY2VXaXRoIH0sIHsgYWNjdXJhY3ksIG1pblRhcmdldEVzMjAyNCwgZGlnaXRJc0FzY2lpLCBzcGFjZUlzQXNjaWksIHdvcmRJc0FzY2lpIH0pIHtcbiAgICBjb25zdCB7IGtpbmQsIG5lZ2F0ZSwgdmFsdWUgfSA9IG5vZGU7XG4gICAgaWYgKGRpZ2l0SXNBc2NpaSAmJiAoa2luZCA9PT0gQXN0Q2hhcmFjdGVyU2V0S2luZHMuZGlnaXQgfHwgdmFsdWUgPT09IFwiZGlnaXRcIikpIHtcbiAgICAgIHJlcGxhY2VXaXRoKGNyZWF0ZUNoYXJhY3RlclNldChBc3RDaGFyYWN0ZXJTZXRLaW5kcy5kaWdpdCwgeyBuZWdhdGUgfSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3BhY2VJc0FzY2lpICYmIChraW5kID09PSBBc3RDaGFyYWN0ZXJTZXRLaW5kcy5zcGFjZSB8fCB2YWx1ZSA9PT0gXCJzcGFjZVwiKSkge1xuICAgICAgcmVwbGFjZVdpdGgoc2V0TmVnYXRlKHBhcnNlRnJhZ21lbnQoYXNjaWlTcGFjZUNoYXIpLCBuZWdhdGUpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHdvcmRJc0FzY2lpICYmIChraW5kID09PSBBc3RDaGFyYWN0ZXJTZXRLaW5kcy53b3JkIHx8IHZhbHVlID09PSBcIndvcmRcIikpIHtcbiAgICAgIHJlcGxhY2VXaXRoKGNyZWF0ZUNoYXJhY3RlclNldChBc3RDaGFyYWN0ZXJTZXRLaW5kcy53b3JkLCB7IG5lZ2F0ZSB9KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChraW5kID09PSBBc3RDaGFyYWN0ZXJTZXRLaW5kcy5hbnkpIHtcbiAgICAgIHJlcGxhY2VXaXRoKGNyZWF0ZVVuaWNvZGVQcm9wZXJ0eShcIkFueVwiKSk7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBBc3RDaGFyYWN0ZXJTZXRLaW5kcy5kaWdpdCkge1xuICAgICAgcmVwbGFjZVdpdGgoY3JlYXRlVW5pY29kZVByb3BlcnR5KFwiTmRcIiwgeyBuZWdhdGUgfSkpO1xuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gQXN0Q2hhcmFjdGVyU2V0S2luZHMuaGV4KSB7XG4gICAgICByZXBsYWNlV2l0aChjcmVhdGVVbmljb2RlUHJvcGVydHkoXCJBSGV4XCIsIHsgbmVnYXRlIH0pKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IEFzdENoYXJhY3RlclNldEtpbmRzLm5vbl9uZXdsaW5lKSB7XG4gICAgICByZXBsYWNlV2l0aChwYXJzZUZyYWdtZW50KHJgW15cXG5dYCkpO1xuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gQXN0Q2hhcmFjdGVyU2V0S2luZHMuc3BhY2UpIHtcbiAgICAgIHJlcGxhY2VXaXRoKGNyZWF0ZVVuaWNvZGVQcm9wZXJ0eShcInNwYWNlXCIsIHsgbmVnYXRlIH0pKTtcbiAgICB9IGVsc2UgaWYgKGtpbmQgPT09IEFzdENoYXJhY3RlclNldEtpbmRzLndvcmQpIHtcbiAgICAgIHJlcGxhY2VXaXRoKHNldE5lZ2F0ZShwYXJzZUZyYWdtZW50KGRlZmF1bHRXb3JkQ2hhciksIG5lZ2F0ZSkpO1xuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gQXN0Q2hhcmFjdGVyU2V0S2luZHMucHJvcGVydHkpIHtcbiAgICAgIGlmICghSnNVbmljb2RlUHJvcGVydGllcy5oYXModmFsdWUpKSB7XG4gICAgICAgIG5vZGUua2V5ID0gXCJzY1wiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gQXN0Q2hhcmFjdGVyU2V0S2luZHMucG9zaXgpIHtcbiAgICAgIGlmICghbWluVGFyZ2V0RXMyMDI0ICYmICh2YWx1ZSA9PT0gXCJncmFwaFwiIHx8IHZhbHVlID09PSBcInByaW50XCIpKSB7XG4gICAgICAgIGlmIChhY2N1cmFjeSA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUE9TSVggY2xhc3MgXCIke3ZhbHVlfVwiIHJlcXVpcmVzIG1pbiB0YXJnZXQgRVMyMDI0IG9yIG5vbi1zdHJpY3QgYWNjdXJhY3lgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXNjaWkgPSB7XG4gICAgICAgICAgZ3JhcGg6IFwiIS1+XCIsXG4gICAgICAgICAgcHJpbnQ6IFwiIC1+XCJcbiAgICAgICAgfVt2YWx1ZV07XG4gICAgICAgIGlmIChuZWdhdGUpIHtcbiAgICAgICAgICBhc2NpaSA9IGBcXDAtJHtjcChhc2NpaS5jb2RlUG9pbnRBdCgwKSAtIDEpfSR7Y3AoYXNjaWkuY29kZVBvaW50QXQoMikgKyAxKX0tXFx1ezEwRkZGRn1gO1xuICAgICAgICB9XG4gICAgICAgIHJlcGxhY2VXaXRoKHBhcnNlRnJhZ21lbnQoYFske2FzY2lpfV1gKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXBsYWNlV2l0aChzZXROZWdhdGUocGFyc2VGcmFnbWVudChQb3NpeENsYXNzZXNNYXAuZ2V0KHZhbHVlKSksIG5lZ2F0ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgRGlyZWN0aXZlKHBhdGgsIHN0YXRlKSB7XG4gICAgY29uc3QgeyBub2RlLCBwYXJlbnQsIGFzdCwgcmVtb3ZlLCByZXBsYWNlV2l0aCwgcmVtb3ZlQWxsUHJldlNpYmxpbmdzLCByZW1vdmVBbGxOZXh0U2libGluZ3MgfSA9IHBhdGg7XG4gICAgY29uc3QgeyBraW5kLCBmbGFncyB9ID0gbm9kZTtcbiAgICBpZiAoa2luZCA9PT0gQXN0RGlyZWN0aXZlS2luZHMuZmxhZ3MpIHtcbiAgICAgIGlmICghZmxhZ3MuZW5hYmxlICYmICFmbGFncy5kaXNhYmxlKSB7XG4gICAgICAgIHJlbW92ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmxhZ0dyb3VwID0gcHJlcENvbnRhaW5lcihjcmVhdGVHcm91cCh7IGZsYWdzIH0pLCByZW1vdmVBbGxOZXh0U2libGluZ3MoKSk7XG4gICAgICAgIHJlcGxhY2VXaXRoKGZsYWdHcm91cCk7XG4gICAgICAgIHRyYXZlcnNlUmVwbGFjZW1lbnQoZmxhZ0dyb3VwLCBwYXRoLCBzdGF0ZSwgRmlyc3RQYXNzVmlzaXRvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBBc3REaXJlY3RpdmVLaW5kcy5rZWVwKSB7XG4gICAgICBjb25zdCBmaXJzdEFsdEZpcnN0RWwgPSBhc3QucGF0dGVybi5hbHRlcm5hdGl2ZXNbMF0uZWxlbWVudHNbMF07XG4gICAgICBjb25zdCBoYXNXcmFwcGVyR3JvdXAgPSAoXG4gICAgICAgIC8vIE5vdCBlbXVsYXRhYmxlIGlmIHdpdGhpbiBhIGBDYXB0dXJpbmdHcm91cGBcbiAgICAgICAgaGFzT25seUNoaWxkKGFzdC5wYXR0ZXJuLCAoa2lkKSA9PiBraWQudHlwZSA9PT0gQXN0VHlwZXMuR3JvdXApICYmIGZpcnN0QWx0Rmlyc3RFbC5hbHRlcm5hdGl2ZXMubGVuZ3RoID09PSAxXG4gICAgICApO1xuICAgICAgY29uc3QgdG9wTGV2ZWwgPSBoYXNXcmFwcGVyR3JvdXAgPyBmaXJzdEFsdEZpcnN0RWwgOiBhc3QucGF0dGVybjtcbiAgICAgIGlmIChwYXJlbnQucGFyZW50ICE9PSB0b3BMZXZlbCB8fCB0b3BMZXZlbC5hbHRlcm5hdGl2ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmBVc2VzIFwiXFxLXCIgaW4gYSB3YXkgdGhhdCdzIHVuc3VwcG9ydGVkYCk7XG4gICAgICB9XG4gICAgICByZXBsYWNlV2l0aChwcmVwQ29udGFpbmVyKGNyZWF0ZUxvb2thcm91bmQoeyBiZWhpbmQ6IHRydWUgfSksIHJlbW92ZUFsbFByZXZTaWJsaW5ncygpKSk7XG4gICAgfVxuICB9LFxuICBGbGFncyh7IG5vZGUsIHBhcmVudCB9KSB7XG4gICAgW1xuICAgICAgXCJkaWdpdElzQXNjaWlcIixcbiAgICAgIC8vIEZsYWcgRFxuICAgICAgXCJleHRlbmRlZFwiLFxuICAgICAgLy8gRmxhZyB4XG4gICAgICBcInNwYWNlSXNBc2NpaVwiLFxuICAgICAgLy8gRmxhZyBTXG4gICAgICBcIndvcmRJc0FzY2lpXCJcbiAgICAgIC8vIEZsYWcgV1xuICAgIF0uZm9yRWFjaCgoZikgPT4gZGVsZXRlIG5vZGVbZl0pO1xuICAgIE9iamVjdC5hc3NpZ24obm9kZSwge1xuICAgICAgLy8gSlMgZmxhZyBnOyBubyBPbmlnIGVxdWl2XG4gICAgICBnbG9iYWw6IGZhbHNlLFxuICAgICAgLy8gSlMgZmxhZyBkOyBubyBPbmlnIGVxdWl2XG4gICAgICBoYXNJbmRpY2VzOiBmYWxzZSxcbiAgICAgIC8vIEpTIGZsYWcgbTsgbm8gT25pZyBlcXVpdiBidXQgaXRzIGJlaGF2aW9yIGlzIGFsd2F5cyBvbiBpbiBPbmlnLiBPbmlnJ3Mgb25seSBsaW5lIGJyZWFrXG4gICAgICAvLyBjaGFyIGlzIGxpbmUgZmVlZCwgdW5saWtlIEpTLCBzbyB0aGlzIGZsYWcgaXNuJ3QgdXNlZCBzaW5jZSBpdCB3b3VsZCBwcm9kdWNlIGluYWNjdXJhdGVcbiAgICAgIC8vIHJlc3VsdHMgKGFsc28gYWxsb3dzIGBeYCBhbmQgYCRgIHRvIGJlIHVzZWQgaW4gdGhlIGdlbmVyYXRvciBmb3Igc3RyaW5nIHN0YXJ0IGFuZCBlbmQpXG4gICAgICBtdWx0aWxpbmU6IGZhbHNlLFxuICAgICAgLy8gSlMgZmxhZyB5OyBubyBPbmlnIGVxdWl2LCBidXQgdXNlZCBmb3IgYFxcR2AgZW11bGF0aW9uXG4gICAgICBzdGlja3k6IG5vZGUuc3RpY2t5ID8/IGZhbHNlXG4gICAgICAvLyBOb3RlOiBSZWdleCsgZG9lc24ndCBhbGxvdyBleHBsaWNpdGx5IGFkZGluZyBmbGFncyBpdCBoYW5kbGVzIGltcGxpY2l0bHksIHNvIGxlYXZlIG91dFxuICAgICAgLy8gcHJvcGVydGllcyBgdW5pY29kZWAgKEpTIGZsYWcgdSkgYW5kIGB1bmljb2RlU2V0c2AgKEpTIGZsYWcgdikuIEtlZXAgdGhlIGV4aXN0aW5nIHZhbHVlc1xuICAgICAgLy8gZm9yIGBpZ25vcmVDYXNlYCAoZmxhZyBpKSBhbmQgYGRvdEFsbGAgKEpTIGZsYWcgcywgYnV0IE9uaWcgZmxhZyBtKVxuICAgIH0pO1xuICAgIHBhcmVudC5vcHRpb25zID0ge1xuICAgICAgZGlzYWJsZToge1xuICAgICAgICAvLyBPbmlnIHVzZXMgZGlmZmVyZW50IHJ1bGVzIGZvciBmbGFnIHggdGhhbiBSZWdleCssIHNvIGRpc2FibGUgdGhlIGltcGxpY2l0IGZsYWdcbiAgICAgICAgeDogdHJ1ZSxcbiAgICAgICAgLy8gT25pZyBoYXMgbm8gZmxhZyB0byBjb250cm9sIFwibmFtZWQgY2FwdHVyZSBvbmx5XCIgbW9kZSBidXQgY29udGV4dHVhbGx5IGFwcGxpZXMgaXRzXG4gICAgICAgIC8vIGJlaGF2aW9yIHdoZW4gbmFtZWQgY2FwdHVyaW5nIGlzIHVzZWQsIHNvIGRpc2FibGUgUmVnZXgrJ3MgaW1wbGljaXQgZmxhZyBmb3IgaXRcbiAgICAgICAgbjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGZvcmNlOiB7XG4gICAgICAgIC8vIEFsd2F5cyBhZGQgZmxhZyB2IGJlY2F1c2Ugd2UncmUgZ2VuZXJhdGluZyBhbiBBU1QgdGhhdCByZWxpZXMgb24gaXQgKGl0IGVuYWJsZXMgSlNcbiAgICAgICAgLy8gc3VwcG9ydCBmb3IgT25pZyBmZWF0dXJlcyBuZXN0ZWQgY2xhc3Nlcywgc2V0IGludGVyc2VjdGlvbiwgVW5pY29kZSBwcm9wZXJ0aWVzLCBldGMuKS5cbiAgICAgICAgLy8gSG93ZXZlciwgdGhlIGdlbmVyYXRvciBtaWdodCBkaXNhYmxlIGZsYWcgdiBiYXNlZCBvbiBpdHMgYHRhcmdldGAgb3B0aW9uXG4gICAgICAgIHY6IHRydWVcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBHcm91cCh7IG5vZGUgfSkge1xuICAgIGlmICghbm9kZS5mbGFncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGVuYWJsZSwgZGlzYWJsZSB9ID0gbm9kZS5mbGFncztcbiAgICBlbmFibGU/LmV4dGVuZGVkICYmIGRlbGV0ZSBlbmFibGUuZXh0ZW5kZWQ7XG4gICAgZGlzYWJsZT8uZXh0ZW5kZWQgJiYgZGVsZXRlIGRpc2FibGUuZXh0ZW5kZWQ7XG4gICAgZW5hYmxlPy5kb3RBbGwgJiYgZGlzYWJsZT8uZG90QWxsICYmIGRlbGV0ZSBlbmFibGUuZG90QWxsO1xuICAgIGVuYWJsZT8uaWdub3JlQ2FzZSAmJiBkaXNhYmxlPy5pZ25vcmVDYXNlICYmIGRlbGV0ZSBlbmFibGUuaWdub3JlQ2FzZTtcbiAgICBlbmFibGUgJiYgIU9iamVjdC5rZXlzKGVuYWJsZSkubGVuZ3RoICYmIGRlbGV0ZSBub2RlLmZsYWdzLmVuYWJsZTtcbiAgICBkaXNhYmxlICYmICFPYmplY3Qua2V5cyhkaXNhYmxlKS5sZW5ndGggJiYgZGVsZXRlIG5vZGUuZmxhZ3MuZGlzYWJsZTtcbiAgICAhbm9kZS5mbGFncy5lbmFibGUgJiYgIW5vZGUuZmxhZ3MuZGlzYWJsZSAmJiBkZWxldGUgbm9kZS5mbGFncztcbiAgfSxcbiAgUGF0dGVybjoge1xuICAgIGVudGVyKHsgbm9kZSB9LCB7IHN1cHBvcnRlZEdOb2RlcyB9KSB7XG4gICAgICBjb25zdCBsZWFkaW5nR3MgPSBbXTtcbiAgICAgIGxldCBoYXNBbHRXaXRoTGVhZEcgPSBmYWxzZTtcbiAgICAgIGxldCBoYXNBbHRXaXRob3V0TGVhZEcgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgYWx0IG9mIG5vZGUuYWx0ZXJuYXRpdmVzKSB7XG4gICAgICAgIGlmIChhbHQuZWxlbWVudHMubGVuZ3RoID09PSAxICYmIGFsdC5lbGVtZW50c1swXS5raW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy5zZWFyY2hfc3RhcnQpIHtcbiAgICAgICAgICBhbHQuZWxlbWVudHMucG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbGVhZGluZ0cgPSBnZXRMZWFkaW5nRyhhbHQuZWxlbWVudHMpO1xuICAgICAgICAgIGlmIChsZWFkaW5nRykge1xuICAgICAgICAgICAgaGFzQWx0V2l0aExlYWRHID0gdHJ1ZTtcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkobGVhZGluZ0cpID8gbGVhZGluZ0dzLnB1c2goLi4ubGVhZGluZ0cpIDogbGVhZGluZ0dzLnB1c2gobGVhZGluZ0cpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoYXNBbHRXaXRob3V0TGVhZEcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhhc0FsdFdpdGhMZWFkRyAmJiAhaGFzQWx0V2l0aG91dExlYWRHKSB7XG4gICAgICAgIGxlYWRpbmdHcy5mb3JFYWNoKChnKSA9PiBzdXBwb3J0ZWRHTm9kZXMuYWRkKGcpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4aXQoXywgeyBhY2N1cmFjeSwgcGFzc2VkTG9va2JlaGluZCwgc3RyYXRlZ3kgfSkge1xuICAgICAgaWYgKGFjY3VyYWN5ID09PSBcInN0cmljdFwiICYmIHBhc3NlZExvb2tiZWhpbmQgJiYgc3RyYXRlZ3kpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJgVXNlcyBcIlxcR1wiIGluIGEgd2F5IHRoYXQgcmVxdWlyZXMgbm9uLXN0cmljdCBhY2N1cmFjeWApO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgUXVhbnRpZmllcih7IG5vZGUgfSkge1xuICAgIGlmIChub2RlLmVsZW1lbnQudHlwZSA9PT0gQXN0VHlwZXMuUXVhbnRpZmllcikge1xuICAgICAgY29uc3QgZ3JvdXAgPSBwcmVwQ29udGFpbmVyKGNyZWF0ZUdyb3VwKCksIFtub2RlLmVsZW1lbnRdKTtcbiAgICAgIGdyb3VwLnBhcmVudCA9IG5vZGU7XG4gICAgICBub2RlLmVsZW1lbnQgPSBncm91cDtcbiAgICB9XG4gIH0sXG4gIFN1YnJvdXRpbmUoeyBub2RlIH0sIHsganNHcm91cE5hbWVNYXAgfSkge1xuICAgIGxldCB7IHJlZiB9ID0gbm9kZTtcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJzdHJpbmdcIiAmJiAhaXNWYWxpZEdyb3VwTmFtZUpzKHJlZikpIHtcbiAgICAgIHJlZiA9IGdldEFuZFN0b3JlSnNHcm91cE5hbWUocmVmLCBqc0dyb3VwTmFtZU1hcCk7XG4gICAgICBub2RlLnJlZiA9IHJlZjtcbiAgICB9XG4gIH0sXG4gIFZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0KHsgbm9kZSwgcmVwbGFjZVdpdGggfSwgeyBhY2N1cmFjeSwgbWluVGFyZ2V0RXMyMDI0IH0pIHtcbiAgICBjb25zdCB7IGtpbmQgfSA9IG5vZGU7XG4gICAgaWYgKGtpbmQgPT09IEFzdFZhcmlhYmxlTGVuZ3RoQ2hhcmFjdGVyU2V0S2luZHMubmV3bGluZSkge1xuICAgICAgcmVwbGFjZVdpdGgocGFyc2VGcmFnbWVudChcIig/Plxcclxcbj98W1xcblxcdlxcZlxceDg1XFx1MjAyOFxcdTIwMjldKVwiKSk7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBBc3RWYXJpYWJsZUxlbmd0aENoYXJhY3RlclNldEtpbmRzLmdyYXBoZW1lKSB7XG4gICAgICBpZiAoYWNjdXJhY3kgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJgVXNlIG9mIFwiXFxYXCIgcmVxdWlyZXMgbm9uLXN0cmljdCBhY2N1cmFjeWApO1xuICAgICAgfVxuICAgICAgY29uc3QgZW1vamkgPSBtaW5UYXJnZXRFczIwMjQgPyByYFxccHtSR0lfRW1vaml9YCA6IGVtb2ppUmVnZXgoKS5zb3VyY2UucmVwbGFjZSgvXFxcXHVcXHsvZywgYFxcXFx4e2ApO1xuICAgICAgcmVwbGFjZVdpdGgocGFyc2VGcmFnbWVudChyYCg/Plxcclxcbnwke2Vtb2ppfXxcXFB7TX1cXHB7TX0qKWAsIHsgc2tpcFByb3BlcnR5TmFtZVZhbGlkYXRpb246IHRydWUgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdmFyY2hhcnNldCBraW5kIFwiJHtraW5kfVwiYCk7XG4gICAgfVxuICB9XG59O1xudmFyIFNlY29uZFBhc3NWaXNpdG9yID0ge1xuICBCYWNrcmVmZXJlbmNlKHsgbm9kZSB9LCB7IG11bHRpcGxleENhcHR1cmVzVG9MZWZ0QnlSZWYsIHJlZmZlZE5vZGVzQnlSZWZlcmVuY2VyIH0pIHtcbiAgICBjb25zdCB7IG9ycGhhbiwgcmVmIH0gPSBub2RlO1xuICAgIGlmICghb3JwaGFuKSB7XG4gICAgICByZWZmZWROb2Rlc0J5UmVmZXJlbmNlci5zZXQobm9kZSwgWy4uLm11bHRpcGxleENhcHR1cmVzVG9MZWZ0QnlSZWYuZ2V0KHJlZikubWFwKCh7IG5vZGU6IG5vZGUyIH0pID0+IG5vZGUyKV0pO1xuICAgIH1cbiAgfSxcbiAgQ2FwdHVyaW5nR3JvdXA6IHtcbiAgICBlbnRlcih7XG4gICAgICBub2RlLFxuICAgICAgcmVwbGFjZVdpdGgsXG4gICAgICBza2lwXG4gICAgfSwge1xuICAgICAgZ3JvdXBPcmlnaW5CeUNvcHksXG4gICAgICBncm91cHNCeU5hbWUsXG4gICAgICBtdWx0aXBsZXhDYXB0dXJlc1RvTGVmdEJ5UmVmLFxuICAgICAgb3BlblJlZnMsXG4gICAgICByZWZmZWROb2Rlc0J5UmVmZXJlbmNlclxuICAgIH0pIHtcbiAgICAgIGNvbnN0IG9yaWdpbiA9IGdyb3VwT3JpZ2luQnlDb3B5LmdldChub2RlKTtcbiAgICAgIGlmIChvcmlnaW4gJiYgb3BlblJlZnMuaGFzKG5vZGUubnVtYmVyKSkge1xuICAgICAgICBjb25zdCByZWN1cnNpb24yID0gY3JlYXRlUmVjdXJzaW9uKG5vZGUubnVtYmVyKTtcbiAgICAgICAgcmVmZmVkTm9kZXNCeVJlZmVyZW5jZXIuc2V0KHJlY3Vyc2lvbjIsIG9wZW5SZWZzLmdldChub2RlLm51bWJlcikpO1xuICAgICAgICByZXBsYWNlV2l0aChyZWN1cnNpb24yKTtcbiAgICAgICAgc2tpcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvcGVuUmVmcy5zZXQobm9kZS5udW1iZXIsIG5vZGUpO1xuICAgICAgbXVsdGlwbGV4Q2FwdHVyZXNUb0xlZnRCeVJlZi5zZXQobm9kZS5udW1iZXIsIFtdKTtcbiAgICAgIGlmIChub2RlLm5hbWUpIHtcbiAgICAgICAgZ2V0T3JJbnNlcnQobXVsdGlwbGV4Q2FwdHVyZXNUb0xlZnRCeVJlZiwgbm9kZS5uYW1lLCBbXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBtdWx0aXBsZXhOb2RlcyA9IG11bHRpcGxleENhcHR1cmVzVG9MZWZ0QnlSZWYuZ2V0KG5vZGUubmFtZSA/PyBub2RlLm51bWJlcik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11bHRpcGxleE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG11bHRpcGxleCA9IG11bHRpcGxleE5vZGVzW2ldO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgLy8gVGhpcyBncm91cCBpcyBmcm9tIHN1YnJvdXRpbmUgZXhwYW5zaW9uLCBhbmQgdGhlcmUncyBhIG11bHRpcGxleCB2YWx1ZSBmcm9tIGVpdGhlciB0aGVcbiAgICAgICAgICAvLyBvcmlnaW4gbm9kZSBvciBhIHByaW9yIHN1YnJvdXRpbmUgZXhwYW5zaW9uIGdyb3VwIHdpdGggdGhlIHNhbWUgb3JpZ2luXG4gICAgICAgICAgb3JpZ2luID09PSBtdWx0aXBsZXgubm9kZSB8fCBvcmlnaW4gJiYgb3JpZ2luID09PSBtdWx0aXBsZXgub3JpZ2luIHx8IC8vIFRoaXMgZ3JvdXAgaXMgbm90IGZyb20gc3Vicm91dGluZSBleHBhbnNpb24sIGFuZCBpdCBjb21lcyBhZnRlciBhIHN1YnJvdXRpbmUgZXhwYW5zaW9uXG4gICAgICAgICAgLy8gZ3JvdXAgdGhhdCByZWZlcnMgdG8gdGhpcyBncm91cFxuICAgICAgICAgIG5vZGUgPT09IG11bHRpcGxleC5vcmlnaW5cbiAgICAgICAgKSB7XG4gICAgICAgICAgbXVsdGlwbGV4Tm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtdWx0aXBsZXhDYXB0dXJlc1RvTGVmdEJ5UmVmLmdldChub2RlLm51bWJlcikucHVzaCh7IG5vZGUsIG9yaWdpbiB9KTtcbiAgICAgIGlmIChub2RlLm5hbWUpIHtcbiAgICAgICAgbXVsdGlwbGV4Q2FwdHVyZXNUb0xlZnRCeVJlZi5nZXQobm9kZS5uYW1lKS5wdXNoKHsgbm9kZSwgb3JpZ2luIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUubmFtZSkge1xuICAgICAgICBjb25zdCBncm91cHNXaXRoU2FtZU5hbWUgPSBnZXRPckluc2VydChncm91cHNCeU5hbWUsIG5vZGUubmFtZSwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgICAgIGxldCBoYXNEdXBsaWNhdGVOYW1lVG9SZW1vdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgIGhhc0R1cGxpY2F0ZU5hbWVUb1JlbW92ZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBncm91cEluZm8gb2YgZ3JvdXBzV2l0aFNhbWVOYW1lLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoIWdyb3VwSW5mby5oYXNEdXBsaWNhdGVOYW1lVG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgaGFzRHVwbGljYXRlTmFtZVRvUmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdyb3Vwc0J5TmFtZS5nZXQobm9kZS5uYW1lKS5zZXQobm9kZSwgeyBub2RlLCBoYXNEdXBsaWNhdGVOYW1lVG9SZW1vdmUgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBleGl0KHsgbm9kZSB9LCB7IG9wZW5SZWZzIH0pIHtcbiAgICAgIG9wZW5SZWZzLmRlbGV0ZShub2RlLm51bWJlcik7XG4gICAgfVxuICB9LFxuICBHcm91cDoge1xuICAgIGVudGVyKHsgbm9kZSB9LCBzdGF0ZSkge1xuICAgICAgc3RhdGUucHJldkZsYWdzID0gc3RhdGUuY3VycmVudEZsYWdzO1xuICAgICAgaWYgKG5vZGUuZmxhZ3MpIHtcbiAgICAgICAgc3RhdGUuY3VycmVudEZsYWdzID0gZ2V0TmV3Q3VycmVudEZsYWdzKHN0YXRlLmN1cnJlbnRGbGFncywgbm9kZS5mbGFncyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBleGl0KF8sIHN0YXRlKSB7XG4gICAgICBzdGF0ZS5jdXJyZW50RmxhZ3MgPSBzdGF0ZS5wcmV2RmxhZ3M7XG4gICAgfVxuICB9LFxuICBSZWN1cnNpb24oeyBub2RlLCBwYXJlbnQgfSwgeyByZWZmZWROb2Rlc0J5UmVmZXJlbmNlciB9KSB7XG4gICAgY29uc3QgeyByZWYgfSA9IG5vZGU7XG4gICAgbGV0IHJlZmZlZCA9IHBhcmVudDtcbiAgICB3aGlsZSAocmVmZmVkID0gcmVmZmVkLnBhcmVudCkge1xuICAgICAgaWYgKHJlZmZlZC50eXBlID09PSBBc3RUeXBlcy5DYXB0dXJpbmdHcm91cCAmJiAocmVmZmVkLm5hbWUgPT09IHJlZiB8fCByZWZmZWQubnVtYmVyID09PSByZWYpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZWZmZWROb2Rlc0J5UmVmZXJlbmNlci5zZXQobm9kZSwgcmVmZmVkKTtcbiAgfSxcbiAgU3Vicm91dGluZShwYXRoLCBzdGF0ZSkge1xuICAgIGNvbnN0IHsgbm9kZSwgcmVwbGFjZVdpdGggfSA9IHBhdGg7XG4gICAgY29uc3QgeyByZWYgfSA9IG5vZGU7XG4gICAgY29uc3QgcmVmZmVkR3JvdXBOb2RlID0gc3RhdGUuc3Vicm91dGluZVJlZk1hcC5nZXQocmVmKTtcbiAgICBjb25zdCBpc0dsb2JhbFJlY3Vyc2lvbiA9IHJlZiA9PT0gMDtcbiAgICBjb25zdCBleHBhbmRlZFN1YnJvdXRpbmUgPSBpc0dsb2JhbFJlY3Vyc2lvbiA/IGNyZWF0ZVJlY3Vyc2lvbigwKSA6IChcbiAgICAgIC8vIFRoZSByZWZmZWQgZ3JvdXAgbWlnaHQgaXRzZWxmIGNvbnRhaW4gc3Vicm91dGluZXMsIHdoaWNoIGFyZSBleHBhbmRlZCBkdXJpbmcgc3ViLXRyYXZlcnNhbFxuICAgICAgY2xvbmVDYXB0dXJpbmdHcm91cChyZWZmZWRHcm91cE5vZGUsIHN0YXRlLmdyb3VwT3JpZ2luQnlDb3B5LCBudWxsKVxuICAgICk7XG4gICAgbGV0IHJlcGxhY2VtZW50ID0gZXhwYW5kZWRTdWJyb3V0aW5lO1xuICAgIGlmICghaXNHbG9iYWxSZWN1cnNpb24pIHtcbiAgICAgIGNvbnN0IHJlZmZlZEdyb3VwRmxhZ01vZHMgPSBnZXRDb21iaW5lZEZsYWdNb2RzRnJvbUZsYWdOb2RlcyhnZXRBbGxQYXJlbnRzKHJlZmZlZEdyb3VwTm9kZSwgKG5vZGUyKSA9PiB7XG4gICAgICAgIHJldHVybiBub2RlMi50eXBlID09PSBBc3RUeXBlcy5Hcm91cCAmJiAhIW5vZGUyLmZsYWdzO1xuICAgICAgfSkpO1xuICAgICAgY29uc3QgcmVmZmVkR3JvdXBGbGFncyA9IHJlZmZlZEdyb3VwRmxhZ01vZHMgPyBnZXROZXdDdXJyZW50RmxhZ3Moc3RhdGUuZ2xvYmFsRmxhZ3MsIHJlZmZlZEdyb3VwRmxhZ01vZHMpIDogc3RhdGUuZ2xvYmFsRmxhZ3M7XG4gICAgICBpZiAoIWFyZUZsYWdzRXF1YWwocmVmZmVkR3JvdXBGbGFncywgc3RhdGUuY3VycmVudEZsYWdzKSkge1xuICAgICAgICByZXBsYWNlbWVudCA9IHByZXBDb250YWluZXIoY3JlYXRlR3JvdXAoe1xuICAgICAgICAgIGZsYWdzOiBnZXRGbGFnTW9kc0Zyb21GbGFncyhyZWZmZWRHcm91cEZsYWdzKVxuICAgICAgICB9KSwgW2V4cGFuZGVkU3Vicm91dGluZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXBsYWNlV2l0aChyZXBsYWNlbWVudCk7XG4gICAgaWYgKCFpc0dsb2JhbFJlY3Vyc2lvbikge1xuICAgICAgdHJhdmVyc2VSZXBsYWNlbWVudChyZXBsYWNlbWVudCwgcGF0aCwgc3RhdGUsIFNlY29uZFBhc3NWaXNpdG9yKTtcbiAgICB9XG4gIH1cbn07XG52YXIgVGhpcmRQYXNzVmlzaXRvciA9IHtcbiAgQmFja3JlZmVyZW5jZSh7IG5vZGUsIHJlcGxhY2VXaXRoIH0sIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUub3JwaGFuKSB7XG4gICAgICBzdGF0ZS5oaWdoZXN0T3JwaGFuQmFja3JlZiA9IE1hdGgubWF4KHN0YXRlLmhpZ2hlc3RPcnBoYW5CYWNrcmVmLCBub2RlLnJlZik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlZmZlZE5vZGVzID0gc3RhdGUucmVmZmVkTm9kZXNCeVJlZmVyZW5jZXIuZ2V0KG5vZGUpO1xuICAgIGNvbnN0IHBhcnRpY2lwYW50cyA9IHJlZmZlZE5vZGVzLmZpbHRlcigocmVmZmVkKSA9PiBjYW5QYXJ0aWNpcGF0ZVdpdGhOb2RlKHJlZmZlZCwgbm9kZSkpO1xuICAgIGlmICghcGFydGljaXBhbnRzLmxlbmd0aCkge1xuICAgICAgcmVwbGFjZVdpdGgocHJlcENvbnRhaW5lcihjcmVhdGVMb29rYXJvdW5kKHsgbmVnYXRlOiB0cnVlIH0pKSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0aWNpcGFudHMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgYWx0cyA9IHBhcnRpY2lwYW50cy5tYXAoKHJlZmZlZCkgPT4gYWRvcHRBbmRTd2FwS2lkcyhcbiAgICAgICAgY3JlYXRlQWx0ZXJuYXRpdmUoKSxcbiAgICAgICAgW2NyZWF0ZUJhY2tyZWZlcmVuY2UocmVmZmVkLm51bWJlcildXG4gICAgICApKTtcbiAgICAgIHJlcGxhY2VXaXRoKGFkb3B0QW5kU3dhcEtpZHMoY3JlYXRlR3JvdXAoKSwgYWx0cykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnJlZiA9IHBhcnRpY2lwYW50c1swXS5udW1iZXI7XG4gICAgfVxuICB9LFxuICBDYXB0dXJpbmdHcm91cCh7IG5vZGUgfSwgc3RhdGUpIHtcbiAgICBub2RlLm51bWJlciA9ICsrc3RhdGUubnVtQ2FwdHVyZXNUb0xlZnQ7XG4gICAgaWYgKG5vZGUubmFtZSkge1xuICAgICAgaWYgKHN0YXRlLmdyb3Vwc0J5TmFtZS5nZXQobm9kZS5uYW1lKS5nZXQobm9kZSkuaGFzRHVwbGljYXRlTmFtZVRvUmVtb3ZlKSB7XG4gICAgICAgIGRlbGV0ZSBub2RlLm5hbWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBSZWN1cnNpb24oeyBub2RlIH0sIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUucmVmID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG5vZGUucmVmID0gc3RhdGUucmVmZmVkTm9kZXNCeVJlZmVyZW5jZXIuZ2V0KG5vZGUpLm51bWJlcjtcbiAgfSxcbiAgUmVnZXg6IHtcbiAgICBleGl0KHsgbm9kZSB9LCBzdGF0ZSkge1xuICAgICAgY29uc3QgbnVtQ2Fwc05lZWRlZCA9IE1hdGgubWF4KHN0YXRlLmhpZ2hlc3RPcnBoYW5CYWNrcmVmIC0gc3RhdGUubnVtQ2FwdHVyZXNUb0xlZnQsIDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DYXBzTmVlZGVkOyBpKyspIHtcbiAgICAgICAgY29uc3QgZW1wdHlDYXB0dXJlID0gY3JlYXRlQ2FwdHVyaW5nR3JvdXAoKTtcbiAgICAgICAgbm9kZS5wYXR0ZXJuLmFsdGVybmF0aXZlcy5hdCgtMSkuZWxlbWVudHMucHVzaChlbXB0eUNhcHR1cmUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBhc2NpaVNwYWNlQ2hhciA9IFwiW1x0LVxcciBdXCI7XG52YXIgZGVmYXVsdFdvcmRDaGFyID0gcmBbXFxwe0x9XFxwe019XFxwe059XFxwe1BjfV1gO1xuZnVuY3Rpb24gYWRvcHRBbmRTd2FwS2lkcyhwYXJlbnQsIGtpZHMpIHtcbiAga2lkcy5mb3JFYWNoKChraWQpID0+IGtpZC5wYXJlbnQgPSBwYXJlbnQpO1xuICBwYXJlbnRbZ2V0Q29udGFpbmVyQWNjZXNzb3IocGFyZW50KV0gPSBraWRzO1xuICByZXR1cm4gcGFyZW50O1xufVxuZnVuY3Rpb24gYXJlRmxhZ3NFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLmRvdEFsbCA9PT0gYi5kb3RBbGwgJiYgYS5pZ25vcmVDYXNlID09PSBiLmlnbm9yZUNhc2U7XG59XG5mdW5jdGlvbiBjYW5QYXJ0aWNpcGF0ZVdpdGhOb2RlKGNhcHR1cmUsIG5vZGUpIHtcbiAgbGV0IHJpZ2h0bW9zdFBvaW50ID0gbm9kZTtcbiAgZG8ge1xuICAgIGlmIChyaWdodG1vc3RQb2ludC50eXBlID09PSBBc3RUeXBlcy5QYXR0ZXJuKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChyaWdodG1vc3RQb2ludC50eXBlID09PSBBc3RUeXBlcy5BbHRlcm5hdGl2ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChyaWdodG1vc3RQb2ludCA9PT0gY2FwdHVyZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBraWRzT2ZQYXJlbnQgPSBnZXRLaWRzKHJpZ2h0bW9zdFBvaW50LnBhcmVudCk7XG4gICAgZm9yIChjb25zdCBraWQgb2Yga2lkc09mUGFyZW50KSB7XG4gICAgICBpZiAoa2lkID09PSByaWdodG1vc3RQb2ludCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChraWQgPT09IGNhcHR1cmUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaGFzRGVzY2VuZGFudChraWQsIGNhcHR1cmUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAocmlnaHRtb3N0UG9pbnQgPSByaWdodG1vc3RQb2ludC5wYXJlbnQpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHBhdGhcIik7XG59XG5mdW5jdGlvbiBjbG9uZUNhcHR1cmluZ0dyb3VwKG9iaiwgb3JpZ2luTWFwLCB1cCwgdXAyKSB7XG4gIGNvbnN0IHN0b3JlID0gQXJyYXkuaXNBcnJheShvYmopID8gW10gOiB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgIGlmIChrZXkgPT09IFwicGFyZW50XCIpIHtcbiAgICAgIHN0b3JlLnBhcmVudCA9IEFycmF5LmlzQXJyYXkodXApID8gdXAyIDogdXA7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHN0b3JlW2tleV0gPSBjbG9uZUNhcHR1cmluZ0dyb3VwKHZhbHVlLCBvcmlnaW5NYXAsIHN0b3JlLCB1cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChrZXkgPT09IFwidHlwZVwiICYmIHZhbHVlID09PSBBc3RUeXBlcy5DYXB0dXJpbmdHcm91cCkge1xuICAgICAgICBvcmlnaW5NYXAuc2V0KHN0b3JlLCBvcmlnaW5NYXAuZ2V0KG9iaikgPz8gb2JqKTtcbiAgICAgIH1cbiAgICAgIHN0b3JlW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0b3JlO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVjdXJzaW9uKHJlZikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFzdFR5cGVzLlJlY3Vyc2lvbixcbiAgICByZWZcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEFsbFBhcmVudHMobm9kZSwgZmlsdGVyRm4pIHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICB3aGlsZSAobm9kZSA9IG5vZGUucGFyZW50KSB7XG4gICAgaWYgKCFmaWx0ZXJGbiB8fCBmaWx0ZXJGbihub2RlKSkge1xuICAgICAgcmVzdWx0cy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cbmZ1bmN0aW9uIGdldEFuZFN0b3JlSnNHcm91cE5hbWUobmFtZSwgbWFwKSB7XG4gIGlmIChtYXAuaGFzKG5hbWUpKSB7XG4gICAgcmV0dXJuIG1hcC5nZXQobmFtZSk7XG4gIH1cbiAgY29uc3QganNOYW1lID0gYCQke21hcC5zaXplfV8ke25hbWUucmVwbGFjZSgvXlteJF9cXHB7SURTfV18W14kXFx1MjAwQ1xcdTIwMERcXHB7SURDfV0vdWcsIFwiX1wiKX1gO1xuICBtYXAuc2V0KG5hbWUsIGpzTmFtZSk7XG4gIHJldHVybiBqc05hbWU7XG59XG5mdW5jdGlvbiBnZXRDb250YWluZXJBY2Nlc3Nvcihub2RlKSB7XG4gIGZvciAoY29uc3QgYWNjZXNzb3Igb2YgW1wiYWx0ZXJuYXRpdmVzXCIsIFwiY2xhc3Nlc1wiLCBcImVsZW1lbnRzXCJdKSB7XG4gICAgaWYgKG5vZGVbYWNjZXNzb3JdKSB7XG4gICAgICByZXR1cm4gYWNjZXNzb3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0Q29tYmluZWRGbGFnTW9kc0Zyb21GbGFnTm9kZXMoZmxhZ05vZGVzKSB7XG4gIGNvbnN0IGZsYWdQcm9wcyA9IFtcImRvdEFsbFwiLCBcImlnbm9yZUNhc2VcIl07XG4gIGNvbnN0IGNvbWJpbmVkRmxhZ3MgPSB7IGVuYWJsZToge30sIGRpc2FibGU6IHt9IH07XG4gIGZsYWdOb2Rlcy5mb3JFYWNoKCh7IGZsYWdzIH0pID0+IHtcbiAgICBmbGFnUHJvcHMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgaWYgKGZsYWdzLmVuYWJsZT8uW3Byb3BdKSB7XG4gICAgICAgIGRlbGV0ZSBjb21iaW5lZEZsYWdzLmRpc2FibGVbcHJvcF07XG4gICAgICAgIGNvbWJpbmVkRmxhZ3MuZW5hYmxlW3Byb3BdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChmbGFncy5kaXNhYmxlPy5bcHJvcF0pIHtcbiAgICAgICAgY29tYmluZWRGbGFncy5kaXNhYmxlW3Byb3BdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIGlmICghT2JqZWN0LmtleXMoY29tYmluZWRGbGFncy5lbmFibGUpLmxlbmd0aCkge1xuICAgIGRlbGV0ZSBjb21iaW5lZEZsYWdzLmVuYWJsZTtcbiAgfVxuICBpZiAoIU9iamVjdC5rZXlzKGNvbWJpbmVkRmxhZ3MuZGlzYWJsZSkubGVuZ3RoKSB7XG4gICAgZGVsZXRlIGNvbWJpbmVkRmxhZ3MuZGlzYWJsZTtcbiAgfVxuICBpZiAoY29tYmluZWRGbGFncy5lbmFibGUgfHwgY29tYmluZWRGbGFncy5kaXNhYmxlKSB7XG4gICAgcmV0dXJuIGNvbWJpbmVkRmxhZ3M7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRGbGFnTW9kc0Zyb21GbGFncyh7IGRvdEFsbCwgaWdub3JlQ2FzZSB9KSB7XG4gIGNvbnN0IG1vZHMgPSB7fTtcbiAgaWYgKGRvdEFsbCB8fCBpZ25vcmVDYXNlKSB7XG4gICAgbW9kcy5lbmFibGUgPSB7fTtcbiAgICBkb3RBbGwgJiYgKG1vZHMuZW5hYmxlLmRvdEFsbCA9IHRydWUpO1xuICAgIGlnbm9yZUNhc2UgJiYgKG1vZHMuZW5hYmxlLmlnbm9yZUNhc2UgPSB0cnVlKTtcbiAgfVxuICBpZiAoIWRvdEFsbCB8fCAhaWdub3JlQ2FzZSkge1xuICAgIG1vZHMuZGlzYWJsZSA9IHt9O1xuICAgICFkb3RBbGwgJiYgKG1vZHMuZGlzYWJsZS5kb3RBbGwgPSB0cnVlKTtcbiAgICAhaWdub3JlQ2FzZSAmJiAobW9kcy5kaXNhYmxlLmlnbm9yZUNhc2UgPSB0cnVlKTtcbiAgfVxuICByZXR1cm4gbW9kcztcbn1cbmZ1bmN0aW9uIGdldEtpZHMobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlIGV4cGVjdGVkXCIpO1xuICB9XG4gIGlmIChub2RlLnR5cGUgPT09IEFzdFR5cGVzLlF1YW50aWZpZXIpIHtcbiAgICByZXR1cm4gW25vZGUuZWxlbWVudF07XG4gIH1cbiAgY29uc3QgYWNjZXNzb3IgPSBnZXRDb250YWluZXJBY2Nlc3Nvcihub2RlKTtcbiAgcmV0dXJuIGFjY2Vzc29yICYmIG5vZGVbYWNjZXNzb3JdO1xufVxuZnVuY3Rpb24gZ2V0TGVhZGluZ0coZWxzKSB7XG4gIGNvbnN0IGZpcnN0VG9Db25zaWRlciA9IGVscy5maW5kKChlbCkgPT4gZWwua2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMuc2VhcmNoX3N0YXJ0IHx8IGlzTG9uZUdMb29rYXJvdW5kKGVsLCB7IG5lZ2F0ZTogZmFsc2UgfSkgfHwgIWlzQWx3YXlzWmVyb0xlbmd0aChlbCkpO1xuICBpZiAoIWZpcnN0VG9Db25zaWRlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChmaXJzdFRvQ29uc2lkZXIua2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMuc2VhcmNoX3N0YXJ0KSB7XG4gICAgcmV0dXJuIGZpcnN0VG9Db25zaWRlcjtcbiAgfVxuICBpZiAoaXNMb29rYXJvdW5kKGZpcnN0VG9Db25zaWRlcikpIHtcbiAgICByZXR1cm4gZmlyc3RUb0NvbnNpZGVyLmFsdGVybmF0aXZlc1swXS5lbGVtZW50c1swXTtcbiAgfVxuICBpZiAoaXNDb25zdW1wdGl2ZUdyb3VwKGZpcnN0VG9Db25zaWRlcikpIHtcbiAgICBjb25zdCBnTm9kZXNGb3JHcm91cCA9IFtdO1xuICAgIGZvciAoY29uc3QgYWx0IG9mIGZpcnN0VG9Db25zaWRlci5hbHRlcm5hdGl2ZXMpIHtcbiAgICAgIGNvbnN0IGxlYWRpbmdHID0gZ2V0TGVhZGluZ0coYWx0LmVsZW1lbnRzKTtcbiAgICAgIGlmICghbGVhZGluZ0cpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBBcnJheS5pc0FycmF5KGxlYWRpbmdHKSA/IGdOb2Rlc0Zvckdyb3VwLnB1c2goLi4ubGVhZGluZ0cpIDogZ05vZGVzRm9yR3JvdXAucHVzaChsZWFkaW5nRyk7XG4gICAgfVxuICAgIHJldHVybiBnTm9kZXNGb3JHcm91cDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGhhc0Rlc2NlbmRhbnQobm9kZSwgZGVzY2VuZGFudCkge1xuICBjb25zdCBraWRzID0gZ2V0S2lkcyhub2RlKSA/PyBbXTtcbiAgZm9yIChjb25zdCBraWQgb2Yga2lkcykge1xuICAgIGlmIChraWQgPT09IGRlc2NlbmRhbnQgfHwgaGFzRGVzY2VuZGFudChraWQsIGRlc2NlbmRhbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNMb25lR0xvb2thcm91bmQobm9kZSwgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0ge1xuICAgIG5lZ2F0ZTogbnVsbCxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIHJldHVybiBpc0xvb2thcm91bmQobm9kZSkgJiYgKG9wdHMubmVnYXRlID09PSBudWxsIHx8IG5vZGUubmVnYXRlID09PSBvcHRzLm5lZ2F0ZSkgJiYgaGFzT25seUNoaWxkKG5vZGUsIChraWQpID0+IGtpZC5raW5kID09PSBBc3RBc3NlcnRpb25LaW5kcy5zZWFyY2hfc3RhcnQpO1xufVxuZnVuY3Rpb24gaXNWYWxpZEdyb3VwTmFtZUpzKG5hbWUpIHtcbiAgcmV0dXJuIC9eWyRfXFxwe0lEU31dWyRcXHUyMDBDXFx1MjAwRFxccHtJREN9XSokL3UudGVzdChuYW1lKTtcbn1cbmZ1bmN0aW9uIHBhcnNlRnJhZ21lbnQocGF0dGVybiwgb3B0aW9ucykge1xuICBjb25zdCBhc3QgPSBwYXJzZSh0b2tlbml6ZShwYXR0ZXJuKSwgb3B0aW9ucyk7XG4gIGNvbnN0IGFsdHMgPSBhc3QucGF0dGVybi5hbHRlcm5hdGl2ZXM7XG4gIGlmIChhbHRzLmxlbmd0aCA+IDEgfHwgYWx0c1swXS5lbGVtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGFkb3B0QW5kU3dhcEtpZHMoY3JlYXRlR3JvdXAoKSwgYWx0cyk7XG4gIH1cbiAgcmV0dXJuIGFsdHNbMF0uZWxlbWVudHNbMF07XG59XG5mdW5jdGlvbiBwcmVwQ29udGFpbmVyKG5vZGUsIGtpZHMpIHtcbiAgY29uc3QgYWNjZXNzb3IgPSBnZXRDb250YWluZXJBY2Nlc3Nvcihub2RlKTtcbiAgbm9kZVthY2Nlc3Nvcl1bMF0ucGFyZW50ID0gbm9kZTtcbiAgaWYgKGtpZHMpIHtcbiAgICBhZG9wdEFuZFN3YXBLaWRzKG5vZGVbYWNjZXNzb3JdWzBdLCBraWRzKTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHNldE5lZ2F0ZShub2RlLCBuZWdhdGUpIHtcbiAgbm9kZS5uZWdhdGUgPSBuZWdhdGU7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VSZXBsYWNlbWVudChyZXBsYWNlbWVudCwgeyBwYXJlbnQsIGtleSwgY29udGFpbmVyIH0sIHN0YXRlLCB2aXNpdG9yKSB7XG4gIHRyYXZlcnNlKHtcbiAgICAvLyBEb24ndCB1c2UgdGhlIGBub2RlYCBmcm9tIGBwYXRoYFxuICAgIG5vZGU6IHJlcGxhY2VtZW50LFxuICAgIHBhcmVudCxcbiAgICBrZXksXG4gICAgY29udGFpbmVyXG4gIH0sIHN0YXRlLCB2aXNpdG9yKTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLmpzXG5mdW5jdGlvbiBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IGdldE9wdGlvbnMob3B0aW9ucyk7XG4gIGNvbnN0IG1pblRhcmdldEVzMjAyNCA9IGlzTWluVGFyZ2V0KG9wdHMudGFyZ2V0LCBcIkVTMjAyNFwiKTtcbiAgY29uc3QgbWluVGFyZ2V0RXMyMDI1ID0gaXNNaW5UYXJnZXQob3B0cy50YXJnZXQsIFwiRVMyMDI1XCIpO1xuICBjb25zdCByZWN1cnNpb25MaW1pdCA9IG9wdHMucnVsZXMucmVjdXJzaW9uTGltaXQ7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihyZWN1cnNpb25MaW1pdCkgfHwgcmVjdXJzaW9uTGltaXQgPCAyIHx8IHJlY3Vyc2lvbkxpbWl0ID4gMjApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlY3Vyc2lvbkxpbWl0OyB1c2UgMi0yMFwiKTtcbiAgfVxuICBsZXQgaGFzQ2FzZUluc2Vuc2l0aXZlTm9kZSA9IG51bGw7XG4gIGxldCBoYXNDYXNlU2Vuc2l0aXZlTm9kZSA9IG51bGw7XG4gIGlmICghbWluVGFyZ2V0RXMyMDI1KSB7XG4gICAgY29uc3QgaVN0YWNrID0gW2FzdC5mbGFncy5pZ25vcmVDYXNlXTtcbiAgICB0cmF2ZXJzZSh7IG5vZGU6IGFzdCB9LCB7XG4gICAgICBnZXRDdXJyZW50TW9kSTogKCkgPT4gaVN0YWNrLmF0KC0xKSxcbiAgICAgIHBvcE1vZEkoKSB7XG4gICAgICAgIGlTdGFjay5wb3AoKTtcbiAgICAgIH0sXG4gICAgICBwdXNoTW9kSShpc0lPbikge1xuICAgICAgICBpU3RhY2sucHVzaChpc0lPbik7XG4gICAgICB9LFxuICAgICAgc2V0SGFzQ2FzZWRDaGFyKCkge1xuICAgICAgICBpZiAoaVN0YWNrLmF0KC0xKSkge1xuICAgICAgICAgIGhhc0Nhc2VJbnNlbnNpdGl2ZU5vZGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhc0Nhc2VTZW5zaXRpdmVOb2RlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIEZsYWdNb2RpZmllclZpc2l0b3IpO1xuICB9XG4gIGNvbnN0IGFwcGxpZWRHbG9iYWxGbGFncyA9IHtcbiAgICBkb3RBbGw6IGFzdC5mbGFncy5kb3RBbGwsXG4gICAgLy8gLSBUdXJuIGdsb2JhbCBmbGFnIGkgb24gaWYgYSBjYXNlIGluc2Vuc2l0aXZlIG5vZGUgd2FzIHVzZWQgYW5kIG5vIGNhc2Ugc2Vuc2l0aXZlIG5vZGVzIHdlcmVcbiAgICAvLyAgIHVzZWQgKHRvIGF2b2lkIHVubmVjZXNzYXJ5IG5vZGUgZXhwYW5zaW9uKS5cbiAgICAvLyAtIFR1cm4gZ2xvYmFsIGZsYWcgaSBvZmYgaWYgYSBjYXNlIHNlbnNpdGl2ZSBub2RlIHdhcyB1c2VkIChzaW5jZSBjYXNlIHNlbnNpdGl2aXR5IGNhbid0IGJlXG4gICAgLy8gICBmb3JjZWQgd2l0aG91dCB0aGUgdXNlIG9mIEVTMjAyNSBmbGFnIGdyb3VwcylcbiAgICBpZ25vcmVDYXNlOiAhISgoYXN0LmZsYWdzLmlnbm9yZUNhc2UgfHwgaGFzQ2FzZUluc2Vuc2l0aXZlTm9kZSkgJiYgIWhhc0Nhc2VTZW5zaXRpdmVOb2RlKVxuICB9O1xuICBsZXQgbGFzdE5vZGUgPSBudWxsO1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBhY2N1cmFjeTogb3B0cy5hY2N1cmFjeSxcbiAgICBhcHBsaWVkR2xvYmFsRmxhZ3MsXG4gICAgY2FwdHVyZU1hcDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBjdXJyZW50RmxhZ3M6IHtcbiAgICAgIGRvdEFsbDogYXN0LmZsYWdzLmRvdEFsbCxcbiAgICAgIGlnbm9yZUNhc2U6IGFzdC5mbGFncy5pZ25vcmVDYXNlXG4gICAgfSxcbiAgICBpbkNoYXJDbGFzczogZmFsc2UsXG4gICAgbGFzdE5vZGUsXG4gICAgb3JpZ2luTWFwOiBhc3QuX29yaWdpbk1hcCxcbiAgICByZWN1cnNpb25MaW1pdCxcbiAgICB1c2VBcHBsaWVkSWdub3JlQ2FzZTogISEoIW1pblRhcmdldEVzMjAyNSAmJiBoYXNDYXNlSW5zZW5zaXRpdmVOb2RlICYmIGhhc0Nhc2VTZW5zaXRpdmVOb2RlKSxcbiAgICB1c2VGbGFnTW9kczogbWluVGFyZ2V0RXMyMDI1LFxuICAgIHVzZUZsYWdWOiBtaW5UYXJnZXRFczIwMjQsXG4gICAgdmVyYm9zZTogb3B0cy52ZXJib3NlXG4gIH07XG4gIGZ1bmN0aW9uIGdlbihub2RlKSB7XG4gICAgc3RhdGUubGFzdE5vZGUgPSBsYXN0Tm9kZTtcbiAgICBsYXN0Tm9kZSA9IG5vZGU7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgQXN0VHlwZXMuUmVnZXg6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF0dGVybjogZ2VuKG5vZGUucGF0dGVybiksXG4gICAgICAgICAgZmxhZ3M6IGdlbihub2RlLmZsYWdzKSxcbiAgICAgICAgICBvcHRpb25zOiB7IC4uLm5vZGUub3B0aW9ucyB9XG4gICAgICAgIH07XG4gICAgICBjYXNlIEFzdFR5cGVzLkFsdGVybmF0aXZlOlxuICAgICAgICByZXR1cm4gbm9kZS5lbGVtZW50cy5tYXAoZ2VuKS5qb2luKFwiXCIpO1xuICAgICAgY2FzZSBBc3RUeXBlcy5Bc3NlcnRpb246XG4gICAgICAgIHJldHVybiBnZW5Bc3NlcnRpb24obm9kZSwgc3RhdGUsIGdlbik7XG4gICAgICBjYXNlIEFzdFR5cGVzLkJhY2tyZWZlcmVuY2U6XG4gICAgICAgIHJldHVybiBnZW5CYWNrcmVmZXJlbmNlKG5vZGUsIHN0YXRlKTtcbiAgICAgIGNhc2UgQXN0VHlwZXMuQ2FwdHVyaW5nR3JvdXA6XG4gICAgICAgIHJldHVybiBnZW5DYXB0dXJpbmdHcm91cChub2RlLCBzdGF0ZSwgZ2VuKTtcbiAgICAgIGNhc2UgQXN0VHlwZXMuQ2hhcmFjdGVyOlxuICAgICAgICByZXR1cm4gZ2VuQ2hhcmFjdGVyKG5vZGUsIHN0YXRlKTtcbiAgICAgIGNhc2UgQXN0VHlwZXMuQ2hhcmFjdGVyQ2xhc3M6XG4gICAgICAgIHJldHVybiBnZW5DaGFyYWN0ZXJDbGFzcyhub2RlLCBzdGF0ZSwgZ2VuKTtcbiAgICAgIGNhc2UgQXN0VHlwZXMuQ2hhcmFjdGVyQ2xhc3NJbnRlcnNlY3Rpb246XG4gICAgICAgIGlmICghc3RhdGUudXNlRmxhZ1YpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2Ugb2YgY2xhc3MgaW50ZXJzZWN0aW9uIHJlcXVpcmVzIG1pbiB0YXJnZXQgRVMyMDI0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLmNsYXNzZXMubWFwKGdlbikuam9pbihcIiYmXCIpO1xuICAgICAgY2FzZSBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzc1JhbmdlOlxuICAgICAgICByZXR1cm4gZ2VuQ2hhcmFjdGVyQ2xhc3NSYW5nZShub2RlLCBzdGF0ZSk7XG4gICAgICBjYXNlIEFzdFR5cGVzLkNoYXJhY3RlclNldDpcbiAgICAgICAgcmV0dXJuIGdlbkNoYXJhY3RlclNldChub2RlLCBzdGF0ZSk7XG4gICAgICBjYXNlIEFzdFR5cGVzLkZsYWdzOlxuICAgICAgICByZXR1cm4gZ2VuRmxhZ3Mobm9kZSwgc3RhdGUpO1xuICAgICAgY2FzZSBBc3RUeXBlcy5Hcm91cDpcbiAgICAgICAgcmV0dXJuIGdlbkdyb3VwKG5vZGUsIHN0YXRlLCBnZW4pO1xuICAgICAgY2FzZSBBc3RUeXBlcy5QYXR0ZXJuOlxuICAgICAgICByZXR1cm4gbm9kZS5hbHRlcm5hdGl2ZXMubWFwKGdlbikuam9pbihcInxcIik7XG4gICAgICBjYXNlIEFzdFR5cGVzLlF1YW50aWZpZXI6XG4gICAgICAgIHJldHVybiBnZW4obm9kZS5lbGVtZW50KSArIGdldFF1YW50aWZpZXJTdHIobm9kZSk7XG4gICAgICBjYXNlIEFzdFR5cGVzLlJlY3Vyc2lvbjpcbiAgICAgICAgcmV0dXJuIGdlblJlY3Vyc2lvbihub2RlLCBzdGF0ZSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgbm9kZSB0eXBlIFwiJHtub2RlLnR5cGV9XCJgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gZ2VuKGFzdCk7XG4gIGlmICghbWluVGFyZ2V0RXMyMDI0KSB7XG4gICAgZGVsZXRlIHJlc3VsdC5vcHRpb25zLmZvcmNlLnY7XG4gICAgcmVzdWx0Lm9wdGlvbnMuZGlzYWJsZS52ID0gdHJ1ZTtcbiAgICByZXN1bHQub3B0aW9ucy51bmljb2RlU2V0c1BsdWdpbiA9IG51bGw7XG4gIH1cbiAgcmVzdWx0Ll9jYXB0dXJlVHJhbnNmZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgcmVzdWx0Ll9oaWRkZW5DYXB0dXJlcyA9IFtdO1xuICBzdGF0ZS5jYXB0dXJlTWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAodmFsdWUuaGlkZGVuKSB7XG4gICAgICByZXN1bHQuX2hpZGRlbkNhcHR1cmVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLnRyYW5zZmVyVG8pIHtcbiAgICAgIGdldE9ySW5zZXJ0KHJlc3VsdC5fY2FwdHVyZVRyYW5zZmVycywgdmFsdWUudHJhbnNmZXJUbywgW10pLnB1c2goa2V5KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIEZsYWdNb2RpZmllclZpc2l0b3IgPSB7XG4gIEFueUdyb3VwOiB7XG4gICAgZW50ZXIoeyBub2RlIH0sIHN0YXRlKSB7XG4gICAgICBjb25zdCBjdXJyZW50TW9kSSA9IHN0YXRlLmdldEN1cnJlbnRNb2RJKCk7XG4gICAgICBzdGF0ZS5wdXNoTW9kSShcbiAgICAgICAgbm9kZS5mbGFncyA/IGdldE5ld0N1cnJlbnRGbGFncyh7IGlnbm9yZUNhc2U6IGN1cnJlbnRNb2RJIH0sIG5vZGUuZmxhZ3MpLmlnbm9yZUNhc2UgOiBjdXJyZW50TW9kSVxuICAgICAgKTtcbiAgICB9LFxuICAgIGV4aXQoXywgc3RhdGUpIHtcbiAgICAgIHN0YXRlLnBvcE1vZEkoKTtcbiAgICB9XG4gIH0sXG4gIEJhY2tyZWZlcmVuY2UoXywgc3RhdGUpIHtcbiAgICBzdGF0ZS5zZXRIYXNDYXNlZENoYXIoKTtcbiAgfSxcbiAgQ2hhcmFjdGVyKHsgbm9kZSB9LCBzdGF0ZSkge1xuICAgIGlmIChjaGFySGFzQ2FzZShjcChub2RlLnZhbHVlKSkpIHtcbiAgICAgIHN0YXRlLnNldEhhc0Nhc2VkQ2hhcigpO1xuICAgIH1cbiAgfSxcbiAgQ2hhcmFjdGVyQ2xhc3NSYW5nZSh7IG5vZGUsIHNraXAgfSwgc3RhdGUpIHtcbiAgICBza2lwKCk7XG4gICAgaWYgKGdldENhc2VzT3V0c2lkZUNoYXJDbGFzc1JhbmdlKG5vZGUsIHsgZmlyc3RPbmx5OiB0cnVlIH0pLmxlbmd0aCkge1xuICAgICAgc3RhdGUuc2V0SGFzQ2FzZWRDaGFyKCk7XG4gICAgfVxuICB9LFxuICBDaGFyYWN0ZXJTZXQoeyBub2RlIH0sIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUua2luZCA9PT0gQXN0Q2hhcmFjdGVyU2V0S2luZHMucHJvcGVydHkgJiYgVW5pY29kZVByb3BlcnRpZXNXaXRoU3BlY2lmaWNDYXNlLmhhcyhub2RlLnZhbHVlKSkge1xuICAgICAgc3RhdGUuc2V0SGFzQ2FzZWRDaGFyKCk7XG4gICAgfVxuICB9XG59O1xudmFyIEJhc2VFc2NhcGVDaGFycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCIkXCIsXG4gIFwiKFwiLFxuICBcIilcIixcbiAgXCIqXCIsXG4gIFwiK1wiLFxuICBcIi5cIixcbiAgXCI/XCIsXG4gIFwiW1wiLFxuICBcIlxcXFxcIixcbiAgXCJdXCIsXG4gIFwiXlwiLFxuICBcIntcIixcbiAgXCJ8XCIsXG4gIFwifVwiXG5dKTtcbnZhciBDaGFyQ2xhc3NFc2NhcGVDaGFycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCItXCIsXG4gIFwiXFxcXFwiLFxuICBcIl1cIixcbiAgXCJeXCIsXG4gIC8vIExpdGVyYWwgYFtgIGRvZXNuJ3QgcmVxdWlyZSBlc2NhcGluZyB3aXRoIGZsYWcgdSwgYnV0IHRoaXMgY2FuIGhlbHAgd29yayBhcm91bmQgcmVnZXggc291cmNlXG4gIC8vIGxpbnRlcnMgYW5kIHJlZ2V4IHN5bnRheCBwcm9jZXNzb3JzIHRoYXQgZXhwZWN0IHVuZXNjYXBlZCBgW2AgdG8gY3JlYXRlIGEgbmVzdGVkIGNsYXNzXG4gIFwiW1wiXG5dKTtcbnZhciBDaGFyQ2xhc3NFc2NhcGVDaGFyc0ZsYWdWID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcIihcIixcbiAgXCIpXCIsXG4gIFwiLVwiLFxuICBcIi9cIixcbiAgXCJbXCIsXG4gIFwiXFxcXFwiLFxuICBcIl1cIixcbiAgXCJeXCIsXG4gIFwie1wiLFxuICBcInxcIixcbiAgXCJ9XCIsXG4gIC8vIERvdWJsZSBwdW5jdHVhdG9yczsgYWxzbyBpbmNsdWRlcyBhbHJlYWR5LWxpc3RlZCBgLWAgYW5kIGBeYFxuICBcIiFcIixcbiAgXCIjXCIsXG4gIFwiJFwiLFxuICBcIiVcIixcbiAgXCImXCIsXG4gIFwiKlwiLFxuICBcIitcIixcbiAgXCIsXCIsXG4gIFwiLlwiLFxuICBcIjpcIixcbiAgXCI7XCIsXG4gIFwiPFwiLFxuICBcIj1cIixcbiAgXCI+XCIsXG4gIFwiP1wiLFxuICBcIkBcIixcbiAgXCJgXCIsXG4gIFwiflwiXG5dKTtcbnZhciBDaGFyQ29kZUVzY2FwZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKFtcbiAgWzksIHJgXFx0YF0sXG4gIC8vIGhvcml6b250YWwgdGFiXG4gIFsxMCwgcmBcXG5gXSxcbiAgLy8gbGluZSBmZWVkXG4gIFsxMSwgcmBcXHZgXSxcbiAgLy8gdmVydGljYWwgdGFiXG4gIFsxMiwgcmBcXGZgXSxcbiAgLy8gZm9ybSBmZWVkXG4gIFsxMywgcmBcXHJgXSxcbiAgLy8gY2FycmlhZ2UgcmV0dXJuXG4gIFs4MjMyLCByYFxcdTIwMjhgXSxcbiAgLy8gbGluZSBzZXBhcmF0b3JcbiAgWzgyMzMsIHJgXFx1MjAyOWBdLFxuICAvLyBwYXJhZ3JhcGggc2VwYXJhdG9yXG4gIFs2NTI3OSwgcmBcXHVGRUZGYF1cbiAgLy8gWldOQlNQL0JPTVxuXSk7XG52YXIgY2FzZWRSZSA9IC9eXFxwe0Nhc2VkfSQvdTtcbmZ1bmN0aW9uIGNoYXJIYXNDYXNlKGNoYXIpIHtcbiAgcmV0dXJuIGNhc2VkUmUudGVzdChjaGFyKTtcbn1cbmZ1bmN0aW9uIGdlbkFzc2VydGlvbihub2RlLCBfLCBnZW4pIHtcbiAgY29uc3QgeyBraW5kLCBuZWdhdGUsIGFsdGVybmF0aXZlcyB9ID0gbm9kZTtcbiAgaWYgKGlzTG9va2Fyb3VuZChub2RlKSkge1xuICAgIGNvbnN0IHByZWZpeCA9IGAke2tpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLmxvb2thaGVhZCA/IFwiXCIgOiBcIjxcIn0ke25lZ2F0ZSA/IFwiIVwiIDogXCI9XCJ9YDtcbiAgICByZXR1cm4gYCg/JHtwcmVmaXh9JHthbHRlcm5hdGl2ZXMubWFwKGdlbikuam9pbihcInxcIil9KWA7XG4gIH1cbiAgaWYgKGtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLnN0cmluZ19lbmQpIHtcbiAgICByZXR1cm4gXCIkXCI7XG4gIH1cbiAgaWYgKGtpbmQgPT09IEFzdEFzc2VydGlvbktpbmRzLnN0cmluZ19zdGFydCkge1xuICAgIHJldHVybiBcIl5cIjtcbiAgfVxuICBpZiAoa2luZCA9PT0gQXN0QXNzZXJ0aW9uS2luZHMud29yZF9ib3VuZGFyeSkge1xuICAgIHJldHVybiBuZWdhdGUgPyByYFxcQmAgOiByYFxcYmA7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGFzc2VydGlvbiBraW5kIFwiJHtraW5kfVwiYCk7XG59XG5mdW5jdGlvbiBnZW5CYWNrcmVmZXJlbmNlKHsgcmVmIH0sIHN0YXRlKSB7XG4gIGlmICh0eXBlb2YgcmVmICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBuYW1lZCBiYWNrcmVmIGluIHRyYW5zZm9ybWVkIEFTVFwiKTtcbiAgfVxuICBpZiAoIXN0YXRlLnVzZUZsYWdNb2RzICYmIHN0YXRlLmFjY3VyYWN5ID09PSBcInN0cmljdFwiICYmIHN0YXRlLmN1cnJlbnRGbGFncy5pZ25vcmVDYXNlICYmICFzdGF0ZS5jYXB0dXJlTWFwLmdldChyZWYpLmlnbm9yZUNhc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2Ugb2YgY2FzZS1pbnNlbnNpdGl2ZSBiYWNrcmVmIHRvIGNhc2Utc2Vuc2l0aXZlIGdyb3VwIHJlcXVpcmVzIHRhcmdldCBFUzIwMjUgb3Igbm9uLXN0cmljdCBhY2N1cmFjeVwiKTtcbiAgfVxuICByZXR1cm4gXCJcXFxcXCIgKyByZWY7XG59XG5mdW5jdGlvbiBnZW5DYXB0dXJpbmdHcm91cChub2RlLCBzdGF0ZSwgZ2VuKSB7XG4gIGNvbnN0IHsgbmFtZSwgbnVtYmVyLCBhbHRlcm5hdGl2ZXMgfSA9IG5vZGU7XG4gIGNvbnN0IGRhdGEgPSB7IGlnbm9yZUNhc2U6IHN0YXRlLmN1cnJlbnRGbGFncy5pZ25vcmVDYXNlIH07XG4gIGNvbnN0IG9yaWdpbiA9IHN0YXRlLm9yaWdpbk1hcC5nZXQobm9kZSk7XG4gIGlmIChvcmlnaW4pIHtcbiAgICBkYXRhLmhpZGRlbiA9IHRydWU7XG4gICAgaWYgKG51bWJlciA+IG9yaWdpbi5udW1iZXIpIHtcbiAgICAgIGRhdGEudHJhbnNmZXJUbyA9IG9yaWdpbi5udW1iZXI7XG4gICAgfVxuICB9XG4gIHN0YXRlLmNhcHR1cmVNYXAuc2V0KG51bWJlciwgZGF0YSk7XG4gIHJldHVybiBgKCR7bmFtZSA/IGA/PCR7bmFtZX0+YCA6IFwiXCJ9JHthbHRlcm5hdGl2ZXMubWFwKGdlbikuam9pbihcInxcIil9KWA7XG59XG5mdW5jdGlvbiBnZW5DaGFyYWN0ZXIoeyB2YWx1ZSB9LCBzdGF0ZSkge1xuICBjb25zdCBjaGFyID0gY3AodmFsdWUpO1xuICBjb25zdCBlc2NhcGVkID0gZ2V0Q2hhckVzY2FwZSh2YWx1ZSwge1xuICAgIGlzQWZ0ZXJCYWNrcmVmOiBzdGF0ZS5sYXN0Tm9kZS50eXBlID09PSBBc3RUeXBlcy5CYWNrcmVmZXJlbmNlLFxuICAgIGluQ2hhckNsYXNzOiBzdGF0ZS5pbkNoYXJDbGFzcyxcbiAgICB1c2VGbGFnVjogc3RhdGUudXNlRmxhZ1ZcbiAgfSk7XG4gIGlmIChlc2NhcGVkICE9PSBjaGFyKSB7XG4gICAgcmV0dXJuIGVzY2FwZWQ7XG4gIH1cbiAgaWYgKHN0YXRlLnVzZUFwcGxpZWRJZ25vcmVDYXNlICYmIHN0YXRlLmN1cnJlbnRGbGFncy5pZ25vcmVDYXNlICYmIGNoYXJIYXNDYXNlKGNoYXIpKSB7XG4gICAgY29uc3QgY2FzZXMgPSBnZXRJZ25vcmVDYXNlTWF0Y2hDaGFycyhjaGFyKTtcbiAgICByZXR1cm4gc3RhdGUuaW5DaGFyQ2xhc3MgPyBjYXNlcy5qb2luKFwiXCIpIDogY2FzZXMubGVuZ3RoID4gMSA/IGBbJHtjYXNlcy5qb2luKFwiXCIpfV1gIDogY2FzZXNbMF07XG4gIH1cbiAgcmV0dXJuIGNoYXI7XG59XG5mdW5jdGlvbiBnZW5DaGFyYWN0ZXJDbGFzcyh7IG5lZ2F0ZSwgcGFyZW50LCBlbGVtZW50cyB9LCBzdGF0ZSwgZ2VuKSB7XG4gIGlmIChlbnZGbGFncy5saXRlcmFsSHlwaGVuSW5jb3JyZWN0bHlDcmVhdGVzUmFuZ2UgJiYgc3RhdGUudXNlRmxhZ1YgJiYgZWxlbWVudHMuc29tZShpc0xpdGVyYWxIeXBoZW4pKSB7XG4gICAgZWxlbWVudHMgPSBlbGVtZW50cy5maWx0ZXIoKG5vZGUpID0+ICFpc0xpdGVyYWxIeXBoZW4obm9kZSkpO1xuICAgIGVsZW1lbnRzLnB1c2goY3JlYXRlQ2hhcmFjdGVyKDQ1KSk7XG4gIH1cbiAgY29uc3QgZ2VuQ2xhc3MgPSAoKSA9PiBgWyR7bmVnYXRlID8gXCJeXCIgOiBcIlwifSR7ZWxlbWVudHMubWFwKGdlbikuam9pbihcIlwiKX1dYDtcbiAgaWYgKCFzdGF0ZS5pbkNoYXJDbGFzcykge1xuICAgIHN0YXRlLmluQ2hhckNsYXNzID0gdHJ1ZTtcbiAgICBjb25zdCByZXN1bHQgPSBnZW5DbGFzcygpO1xuICAgIHN0YXRlLmluQ2hhckNsYXNzID0gZmFsc2U7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjb25zdCBmaXJzdFR5cGUgPSBlbGVtZW50c1swXT8udHlwZTtcbiAgaWYgKCFuZWdhdGUgJiYgZmlyc3RUeXBlICYmIC8vIEFsbG93cyBtYW55IG5lc3RlZCBjbGFzc2VzIHRvIHdvcmsgd2l0aCBgdGFyZ2V0YCBFUzIwMTggd2hpY2ggZG9lc24ndCBzdXBwb3J0IG5lc3RpbmdcbiAgKCghc3RhdGUudXNlRmxhZ1YgfHwgIXN0YXRlLnZlcmJvc2UpICYmIHBhcmVudC50eXBlID09PSBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzcyAmJiBmaXJzdFR5cGUgIT09IEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzSW50ZXJzZWN0aW9uICYmICEoZW52RmxhZ3MubGl0ZXJhbEh5cGhlbkluY29ycmVjdGx5Q3JlYXRlc1JhbmdlICYmIHN0YXRlLnVzZUZsYWdWKSB8fCAhc3RhdGUudmVyYm9zZSAmJiBwYXJlbnQudHlwZSA9PT0gQXN0VHlwZXMuQ2hhcmFjdGVyQ2xhc3NJbnRlcnNlY3Rpb24gJiYgLy8gSlMgZG9lc24ndCBhbGxvdyBpbnRlcnNlY3Rpb24gd2l0aCB1bmlvbiBvciByYW5nZXNcbiAgZWxlbWVudHMubGVuZ3RoID09PSAxICYmIGZpcnN0VHlwZSAhPT0gQXN0VHlwZXMuQ2hhcmFjdGVyQ2xhc3MgJiYgZmlyc3RUeXBlICE9PSBBc3RUeXBlcy5DaGFyYWN0ZXJDbGFzc1JhbmdlKSkge1xuICAgIHJldHVybiBlbGVtZW50cy5tYXAoZ2VuKS5qb2luKFwiXCIpO1xuICB9XG4gIGlmICghc3RhdGUudXNlRmxhZ1YgJiYgcGFyZW50LnR5cGUgPT09IEFzdFR5cGVzLkNoYXJhY3RlckNsYXNzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlIG9mIG5lc3RlZCBjaGFyYWN0ZXIgY2xhc3MgcmVxdWlyZXMgbWluIHRhcmdldCBFUzIwMjRcIik7XG4gIH1cbiAgcmV0dXJuIGdlbkNsYXNzKCk7XG59XG5mdW5jdGlvbiBnZW5DaGFyYWN0ZXJDbGFzc1JhbmdlKG5vZGUsIHN0YXRlKSB7XG4gIGNvbnN0IG1pbiA9IG5vZGUubWluLnZhbHVlO1xuICBjb25zdCBtYXggPSBub2RlLm1heC52YWx1ZTtcbiAgY29uc3QgZXNjT3B0cyA9IHtcbiAgICBpc0FmdGVyQmFja3JlZjogZmFsc2UsXG4gICAgaW5DaGFyQ2xhc3M6IHRydWUsXG4gICAgdXNlRmxhZ1Y6IHN0YXRlLnVzZUZsYWdWXG4gIH07XG4gIGNvbnN0IG1pblN0ciA9IGdldENoYXJFc2NhcGUobWluLCBlc2NPcHRzKTtcbiAgY29uc3QgbWF4U3RyID0gZ2V0Q2hhckVzY2FwZShtYXgsIGVzY09wdHMpO1xuICBjb25zdCBleHRyYUNoYXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgaWYgKHN0YXRlLnVzZUFwcGxpZWRJZ25vcmVDYXNlICYmIHN0YXRlLmN1cnJlbnRGbGFncy5pZ25vcmVDYXNlKSB7XG4gICAgY29uc3QgY2hhcnNPdXRzaWRlUmFuZ2UgPSBnZXRDYXNlc091dHNpZGVDaGFyQ2xhc3NSYW5nZShub2RlKTtcbiAgICBjb25zdCByYW5nZXMgPSBnZXRDb2RlUG9pbnRSYW5nZXNGcm9tQ2hhcnMoY2hhcnNPdXRzaWRlUmFuZ2UpO1xuICAgIHJhbmdlcy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgZXh0cmFDaGFycy5hZGQoXG4gICAgICAgIEFycmF5LmlzQXJyYXkodmFsdWUpID8gYCR7Z2V0Q2hhckVzY2FwZSh2YWx1ZVswXSwgZXNjT3B0cyl9LSR7Z2V0Q2hhckVzY2FwZSh2YWx1ZVsxXSwgZXNjT3B0cyl9YCA6IGdldENoYXJFc2NhcGUodmFsdWUsIGVzY09wdHMpXG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBgJHttaW5TdHJ9LSR7bWF4U3RyfSR7Wy4uLmV4dHJhQ2hhcnNdLmpvaW4oXCJcIil9YDtcbn1cbmZ1bmN0aW9uIGdlbkNoYXJhY3RlclNldCh7IGtpbmQsIG5lZ2F0ZSwgdmFsdWUsIGtleSB9LCBzdGF0ZSkge1xuICBpZiAoa2luZCA9PT0gQXN0Q2hhcmFjdGVyU2V0S2luZHMuZG90KSB7XG4gICAgcmV0dXJuIHN0YXRlLmN1cnJlbnRGbGFncy5kb3RBbGwgPyBzdGF0ZS5hcHBsaWVkR2xvYmFsRmxhZ3MuZG90QWxsIHx8IHN0YXRlLnVzZUZsYWdNb2RzID8gXCIuXCIgOiBcIlteXVwiIDogKFxuICAgICAgLy8gT25pZydzIG9ubHkgbGluZSBicmVhayBjaGFyIGlzIGxpbmUgZmVlZCwgdW5saWtlIEpTXG4gICAgICByYFteXFxuXWBcbiAgICApO1xuICB9XG4gIGlmIChraW5kID09PSBBc3RDaGFyYWN0ZXJTZXRLaW5kcy5kaWdpdCkge1xuICAgIHJldHVybiBuZWdhdGUgPyByYFxcRGAgOiByYFxcZGA7XG4gIH1cbiAgaWYgKGtpbmQgPT09IEFzdENoYXJhY3RlclNldEtpbmRzLnByb3BlcnR5KSB7XG4gICAgaWYgKHN0YXRlLnVzZUFwcGxpZWRJZ25vcmVDYXNlICYmIHN0YXRlLmN1cnJlbnRGbGFncy5pZ25vcmVDYXNlICYmIFVuaWNvZGVQcm9wZXJ0aWVzV2l0aFNwZWNpZmljQ2FzZS5oYXModmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaWNvZGUgcHJvcGVydHkgXCIke3ZhbHVlfVwiIGNhbid0IGJlIGNhc2UtaW5zZW5zaXRpdmUgd2hlbiBvdGhlciBjaGFycyBoYXZlIHNwZWNpZmljIGNhc2VgKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke25lZ2F0ZSA/IHJgXFxQYCA6IHJgXFxwYH17JHtrZXkgPyBgJHtrZXl9PWAgOiBcIlwifSR7dmFsdWV9fWA7XG4gIH1cbiAgaWYgKGtpbmQgPT09IEFzdENoYXJhY3RlclNldEtpbmRzLndvcmQpIHtcbiAgICByZXR1cm4gbmVnYXRlID8gcmBcXFdgIDogcmBcXHdgO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgc2V0IGtpbmQgXCIke2tpbmR9XCJgKTtcbn1cbmZ1bmN0aW9uIGdlbkZsYWdzKG5vZGUsIHN0YXRlKSB7XG4gIHJldHVybiAoXG4gICAgLy8gVGhlIHRyYW5zZm9ybWVyIHNob3VsZCBuZXZlciB0dXJuIG9uIHRoZSBwcm9wZXJ0aWVzIGZvciBmbGFncyBkLCBnLCBhbmQgbSBzaW5jZSBPbmlnIGRvZXNuJ3RcbiAgICAvLyBoYXZlIGVxdWl2cy4gRmxhZyBtIGlzIG5ldmVyIHJlbGllZCBvbiBzaW5jZSBPbmlnIHVzZXMgZGlmZmVyZW50IGxpbmUgYnJlYWsgY2hhcnMgdGhhbiBKU1xuICAgIC8vIChub2RlLmhhc0luZGljZXMgPyAnZCcgOiAnJykgK1xuICAgIC8vIChub2RlLmdsb2JhbCA/ICdnJyA6ICcnKSArXG4gICAgLy8gKG5vZGUubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAoc3RhdGUuYXBwbGllZEdsb2JhbEZsYWdzLmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCIpICsgKG5vZGUuZG90QWxsID8gXCJzXCIgOiBcIlwiKSArIChub2RlLnN0aWNreSA/IFwieVwiIDogXCJcIilcbiAgKTtcbn1cbmZ1bmN0aW9uIGdlbkdyb3VwKHsgYXRvbWljOiBhdG9taWMyLCBmbGFncywgcGFyZW50LCBhbHRlcm5hdGl2ZXMgfSwgc3RhdGUsIGdlbikge1xuICBjb25zdCBjdXJyZW50RmxhZ3MgPSBzdGF0ZS5jdXJyZW50RmxhZ3M7XG4gIGlmIChmbGFncykge1xuICAgIHN0YXRlLmN1cnJlbnRGbGFncyA9IGdldE5ld0N1cnJlbnRGbGFncyhjdXJyZW50RmxhZ3MsIGZsYWdzKTtcbiAgfVxuICBjb25zdCBjb250ZW50cyA9IGFsdGVybmF0aXZlcy5tYXAoZ2VuKS5qb2luKFwifFwiKTtcbiAgY29uc3QgcmVzdWx0ID0gIXN0YXRlLnZlcmJvc2UgJiYgYWx0ZXJuYXRpdmVzLmxlbmd0aCA9PT0gMSAmJiBwYXJlbnQudHlwZSAhPT0gQXN0VHlwZXMuUXVhbnRpZmllciAmJiAhYXRvbWljMiAmJiAoIXN0YXRlLnVzZUZsYWdNb2RzIHx8ICFmbGFncykgPyBjb250ZW50cyA6IGAoPyR7Z2V0R3JvdXBQcmVmaXgoYXRvbWljMiwgZmxhZ3MsIHN0YXRlLnVzZUZsYWdNb2RzKX0ke2NvbnRlbnRzfSlgO1xuICBzdGF0ZS5jdXJyZW50RmxhZ3MgPSBjdXJyZW50RmxhZ3M7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZW5SZWN1cnNpb24oeyByZWYgfSwgc3RhdGUpIHtcbiAgY29uc3QgbGltaXQgPSBzdGF0ZS5yZWN1cnNpb25MaW1pdDtcbiAgcmV0dXJuIHJlZiA9PT0gMCA/IGAoP1I9JHtsaW1pdH0pYCA6IHJgXFxnPCR7cmVmfSZSPSR7bGltaXR9PmA7XG59XG5mdW5jdGlvbiBnZXRDYXNlc091dHNpZGVDaGFyQ2xhc3NSYW5nZShub2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGZpcnN0T25seSA9ICEhb3B0aW9ucz8uZmlyc3RPbmx5O1xuICBjb25zdCBtaW4gPSBub2RlLm1pbi52YWx1ZTtcbiAgY29uc3QgbWF4ID0gbm9kZS5tYXgudmFsdWU7XG4gIGNvbnN0IGZvdW5kID0gW107XG4gIGlmIChtaW4gPCA2NSAmJiAobWF4ID09PSA2NTUzNSB8fCBtYXggPj0gMTMxMDcxKSB8fCBtaW4gPT09IDY1NTM2ICYmIG1heCA+PSAxMzEwNzEpIHtcbiAgICByZXR1cm4gZm91bmQ7XG4gIH1cbiAgZm9yIChsZXQgaSA9IG1pbjsgaSA8PSBtYXg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBjcChpKTtcbiAgICBpZiAoIWNoYXJIYXNDYXNlKGNoYXIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgY2hhcnNPdXRzaWRlUmFuZ2UgPSBnZXRJZ25vcmVDYXNlTWF0Y2hDaGFycyhjaGFyKS5maWx0ZXIoKGNhc2VPZkNoYXIpID0+IHtcbiAgICAgIGNvbnN0IG51bSA9IGNhc2VPZkNoYXIuY29kZVBvaW50QXQoMCk7XG4gICAgICByZXR1cm4gbnVtIDwgbWluIHx8IG51bSA+IG1heDtcbiAgICB9KTtcbiAgICBpZiAoY2hhcnNPdXRzaWRlUmFuZ2UubGVuZ3RoKSB7XG4gICAgICBmb3VuZC5wdXNoKC4uLmNoYXJzT3V0c2lkZVJhbmdlKTtcbiAgICAgIGlmIChmaXJzdE9ubHkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGdldENoYXJFc2NhcGUoY29kZVBvaW50LCB7IGlzQWZ0ZXJCYWNrcmVmLCBpbkNoYXJDbGFzcywgdXNlRmxhZ1YgfSkge1xuICBpZiAoQ2hhckNvZGVFc2NhcGVNYXAuaGFzKGNvZGVQb2ludCkpIHtcbiAgICByZXR1cm4gQ2hhckNvZGVFc2NhcGVNYXAuZ2V0KGNvZGVQb2ludCk7XG4gIH1cbiAgaWYgKFxuICAgIC8vIENvbnRyb2wgY2hhcnMsIGV0Yy47IGNvbmRpdGlvbiBtb2RlbGVkIG9uIHRoZSBDaHJvbWUgZGV2ZWxvcGVyIGNvbnNvbGUncyBkaXNwbGF5IGZvciBzdHJpbmdzXG4gICAgY29kZVBvaW50IDwgMzIgfHwgY29kZVBvaW50ID4gMTI2ICYmIGNvZGVQb2ludCA8IDE2MCB8fCAvLyBVbmljb2RlIHBsYW5lcyA0LTE2OyB1bmFzc2lnbmVkLCBzcGVjaWFsIHB1cnBvc2UsIGFuZCBwcml2YXRlIHVzZSBhcmVhXG4gICAgY29kZVBvaW50ID4gMjYyMTQzIHx8IC8vIEF2b2lkIGNvcnJ1cHRpbmcgYSBwcmVjZWRpbmcgYmFja3JlZiBieSBpbW1lZGlhdGVseSBmb2xsb3dpbmcgaXQgd2l0aCBhIGxpdGVyYWwgZGlnaXRcbiAgICBpc0FmdGVyQmFja3JlZiAmJiBpc0RpZ2l0Q2hhckNvZGUoY29kZVBvaW50KVxuICApIHtcbiAgICByZXR1cm4gY29kZVBvaW50ID4gMjU1ID8gYFxcXFx1eyR7Y29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpfX1gIDogYFxcXFx4JHtjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkucGFkU3RhcnQoMiwgXCIwXCIpfWA7XG4gIH1cbiAgY29uc3QgZXNjYXBlQ2hhcnMgPSBpbkNoYXJDbGFzcyA/IHVzZUZsYWdWID8gQ2hhckNsYXNzRXNjYXBlQ2hhcnNGbGFnViA6IENoYXJDbGFzc0VzY2FwZUNoYXJzIDogQmFzZUVzY2FwZUNoYXJzO1xuICBjb25zdCBjaGFyID0gY3AoY29kZVBvaW50KTtcbiAgcmV0dXJuIChlc2NhcGVDaGFycy5oYXMoY2hhcikgPyBcIlxcXFxcIiA6IFwiXCIpICsgY2hhcjtcbn1cbmZ1bmN0aW9uIGdldENvZGVQb2ludFJhbmdlc0Zyb21DaGFycyhjaGFycykge1xuICBjb25zdCBjb2RlUG9pbnRzID0gY2hhcnMubWFwKChjaGFyKSA9PiBjaGFyLmNvZGVQb2ludEF0KDApKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIGNvbnN0IHZhbHVlcyA9IFtdO1xuICBsZXQgc3RhcnQgPSBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvZGVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY29kZVBvaW50c1tpICsgMV0gPT09IGNvZGVQb2ludHNbaV0gKyAxKSB7XG4gICAgICBzdGFydCA/Pz0gY29kZVBvaW50c1tpXTtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICB2YWx1ZXMucHVzaChjb2RlUG9pbnRzW2ldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzLnB1c2goW3N0YXJ0LCBjb2RlUG9pbnRzW2ldXSk7XG4gICAgICBzdGFydCA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZXM7XG59XG5mdW5jdGlvbiBnZXRHcm91cFByZWZpeChhdG9taWMyLCBmbGFnTW9kcywgdXNlRmxhZ01vZHMpIHtcbiAgaWYgKGF0b21pYzIpIHtcbiAgICByZXR1cm4gXCI+XCI7XG4gIH1cbiAgbGV0IG1vZHMgPSBcIlwiO1xuICBpZiAoZmxhZ01vZHMgJiYgdXNlRmxhZ01vZHMpIHtcbiAgICBjb25zdCB7IGVuYWJsZSwgZGlzYWJsZSB9ID0gZmxhZ01vZHM7XG4gICAgbW9kcyA9IChlbmFibGU/Lmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCIpICsgKGVuYWJsZT8uZG90QWxsID8gXCJzXCIgOiBcIlwiKSArIChkaXNhYmxlID8gXCItXCIgOiBcIlwiKSArIChkaXNhYmxlPy5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKSArIChkaXNhYmxlPy5kb3RBbGwgPyBcInNcIiA6IFwiXCIpO1xuICB9XG4gIHJldHVybiBgJHttb2RzfTpgO1xufVxuZnVuY3Rpb24gZ2V0UXVhbnRpZmllclN0cih7IG1pbiwgbWF4LCBncmVlZHksIHBvc3Nlc3NpdmU6IHBvc3Nlc3NpdmUyIH0pIHtcbiAgbGV0IGJhc2U7XG4gIGlmICghbWluICYmIG1heCA9PT0gMSkge1xuICAgIGJhc2UgPSBcIj9cIjtcbiAgfSBlbHNlIGlmICghbWluICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICBiYXNlID0gXCIqXCI7XG4gIH0gZWxzZSBpZiAobWluID09PSAxICYmIG1heCA9PT0gSW5maW5pdHkpIHtcbiAgICBiYXNlID0gXCIrXCI7XG4gIH0gZWxzZSBpZiAobWluID09PSBtYXgpIHtcbiAgICBiYXNlID0gYHske21pbn19YDtcbiAgfSBlbHNlIHtcbiAgICBiYXNlID0gYHske21pbn0sJHttYXggPT09IEluZmluaXR5ID8gXCJcIiA6IG1heH19YDtcbiAgfVxuICByZXR1cm4gYmFzZSArIChwb3NzZXNzaXZlMiA/IFwiK1wiIDogZ3JlZWR5ID8gXCJcIiA6IFwiP1wiKTtcbn1cbmZ1bmN0aW9uIGlzRGlnaXRDaGFyQ29kZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPiA0NyAmJiB2YWx1ZSA8IDU4O1xufVxuZnVuY3Rpb24gaXNMaXRlcmFsSHlwaGVuKHsgdHlwZSwgdmFsdWUgfSkge1xuICByZXR1cm4gdHlwZSA9PT0gQXN0VHlwZXMuQ2hhcmFjdGVyICYmIHZhbHVlID09PSA0NTtcbn1cblxuLy8gc3JjL3N1YmNsYXNzLmpzXG52YXIgRW11bGF0ZWRSZWdFeHAgPSBjbGFzcyBfRW11bGF0ZWRSZWdFeHAgZXh0ZW5kcyBSZWdFeHAge1xuICAvKipcbiAgQHR5cGUge01hcDxudW1iZXIsIHtcbiAgICBoaWRkZW4/OiB0cnVlO1xuICAgIHRyYW5zZmVyVG8/OiBudW1iZXI7XG4gIH0+fVxuICAqL1xuICAjY2FwdHVyZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8qKlxuICBAdHlwZSB7UmVnRXhwIHwgRW11bGF0ZWRSZWdFeHAgfCBudWxsfVxuICAqL1xuICAjY29tcGlsZWQgPSBudWxsO1xuICAvKipcbiAgQHR5cGUge3N0cmluZ31cbiAgKi9cbiAgI3BhdHRlcm47XG4gIC8qKlxuICBAdHlwZSB7TWFwPG51bWJlciwgc3RyaW5nPj99XG4gICovXG4gICNuYW1lTWFwID0gbnVsbDtcbiAgLyoqXG4gIEB0eXBlIHtzdHJpbmc/fVxuICAqL1xuICAjc3RyYXRlZ3kgPSBudWxsO1xuICAvKipcbiAgQ2FuIGJlIHVzZWQgdG8gc2VyaWFsaXplIHRoZSBpbnN0YW5jZS5cbiAgQHR5cGUge0VtdWxhdGVkUmVnRXhwT3B0aW9uc31cbiAgKi9cbiAgcmF3T3B0aW9ucyA9IHt9O1xuICAvLyBPdmVycmlkZSB0aGUgZ2V0dGVyIHdpdGggb25lIHRoYXQgd29ya3Mgd2l0aCBsYXp5LWNvbXBpbGVkIHJlZ2V4ZXNcbiAgZ2V0IHNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcGF0dGVybiB8fCBcIig/OilcIjtcbiAgfVxuICAvKipcbiAgQG92ZXJsb2FkXG4gIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuXG4gIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3NdXG4gIEBwYXJhbSB7RW11bGF0ZWRSZWdFeHBPcHRpb25zfSBbb3B0aW9uc11cbiAgKi9cbiAgLyoqXG4gIEBvdmVybG9hZFxuICBAcGFyYW0ge0VtdWxhdGVkUmVnRXhwfSBwYXR0ZXJuXG4gIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3NdXG4gICovXG4gIGNvbnN0cnVjdG9yKHBhdHRlcm4sIGZsYWdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGF6eUNvbXBpbGUgPSAhIW9wdGlvbnM/LmxhenlDb21waWxlO1xuICAgIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcHJvdmlkZSBvcHRpb25zIHdoZW4gY29weWluZyBhIHJlZ2V4cFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlID0gcGF0dGVybjtcbiAgICAgIHN1cGVyKHJlLCBmbGFncyk7XG4gICAgICB0aGlzLiNwYXR0ZXJuID0gcmUuc291cmNlO1xuICAgICAgaWYgKHJlIGluc3RhbmNlb2YgX0VtdWxhdGVkUmVnRXhwKSB7XG4gICAgICAgIHRoaXMuI2NhcHR1cmVNYXAgPSByZS4jY2FwdHVyZU1hcDtcbiAgICAgICAgdGhpcy4jbmFtZU1hcCA9IHJlLiNuYW1lTWFwO1xuICAgICAgICB0aGlzLiNzdHJhdGVneSA9IHJlLiNzdHJhdGVneTtcbiAgICAgICAgdGhpcy5yYXdPcHRpb25zID0gcmUucmF3T3B0aW9ucztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgaGlkZGVuQ2FwdHVyZXM6IFtdLFxuICAgICAgICBzdHJhdGVneTogbnVsbCxcbiAgICAgICAgdHJhbnNmZXJzOiBbXSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICAgIHN1cGVyKGxhenlDb21waWxlID8gXCJcIiA6IHBhdHRlcm4sIGZsYWdzKTtcbiAgICAgIHRoaXMuI3BhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgdGhpcy4jY2FwdHVyZU1hcCA9IGNyZWF0ZUNhcHR1cmVNYXAob3B0cy5oaWRkZW5DYXB0dXJlcywgb3B0cy50cmFuc2ZlcnMpO1xuICAgICAgdGhpcy4jc3RyYXRlZ3kgPSBvcHRzLnN0cmF0ZWd5O1xuICAgICAgdGhpcy5yYXdPcHRpb25zID0gb3B0aW9ucyA/PyB7fTtcbiAgICB9XG4gICAgaWYgKCFsYXp5Q29tcGlsZSkge1xuICAgICAgdGhpcy4jY29tcGlsZWQgPSB0aGlzO1xuICAgIH1cbiAgfVxuICAvKipcbiAgQ2FsbGVkIGludGVybmFsbHkgYnkgYWxsIFN0cmluZy9SZWdFeHAgbWV0aG9kcyB0aGF0IHVzZSByZWdleGVzLlxuICBAb3ZlcnJpZGVcbiAgQHBhcmFtIHtzdHJpbmd9IHN0clxuICBAcmV0dXJucyB7UmVnRXhwRXhlY0FycmF5P31cbiAgKi9cbiAgZXhlYyhzdHIpIHtcbiAgICBpZiAoIXRoaXMuI2NvbXBpbGVkKSB7XG4gICAgICBjb25zdCB7IGxhenlDb21waWxlLCAuLi5yZXN0IH0gPSB0aGlzLnJhd09wdGlvbnM7XG4gICAgICB0aGlzLiNjb21waWxlZCA9IG5ldyBfRW11bGF0ZWRSZWdFeHAodGhpcy4jcGF0dGVybiwgdGhpcy5mbGFncywgcmVzdCk7XG4gICAgfVxuICAgIGNvbnN0IHVzZUxhc3RJbmRleCA9IHRoaXMuZ2xvYmFsIHx8IHRoaXMuc3RpY2t5O1xuICAgIGNvbnN0IHBvcyA9IHRoaXMubGFzdEluZGV4O1xuICAgIGlmICh0aGlzLiNzdHJhdGVneSA9PT0gXCJjbGlwX3NlYXJjaFwiICYmIHVzZUxhc3RJbmRleCAmJiBwb3MpIHtcbiAgICAgIHRoaXMubGFzdEluZGV4ID0gMDtcbiAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy4jZXhlY0NvcmUoc3RyLnNsaWNlKHBvcykpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGFkanVzdE1hdGNoRGV0YWlsc0Zvck9mZnNldChtYXRjaCwgcG9zLCBzdHIsIHRoaXMuaGFzSW5kaWNlcyk7XG4gICAgICAgIHRoaXMubGFzdEluZGV4ICs9IHBvcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2V4ZWNDb3JlKHN0cik7XG4gIH1cbiAgLyoqXG4gIEFkZHMgc3VwcG9ydCBmb3IgaGlkZGVuIGFuZCB0cmFuc2ZlciBjYXB0dXJlcy5cbiAgQHBhcmFtIHtzdHJpbmd9IHN0clxuICBAcmV0dXJuc1xuICAqL1xuICAjZXhlY0NvcmUoc3RyKSB7XG4gICAgdGhpcy4jY29tcGlsZWQubGFzdEluZGV4ID0gdGhpcy5sYXN0SW5kZXg7XG4gICAgY29uc3QgbWF0Y2ggPSBzdXBlci5leGVjLmNhbGwodGhpcy4jY29tcGlsZWQsIHN0cik7XG4gICAgdGhpcy5sYXN0SW5kZXggPSB0aGlzLiNjb21waWxlZC5sYXN0SW5kZXg7XG4gICAgaWYgKCFtYXRjaCB8fCAhdGhpcy4jY2FwdHVyZU1hcC5zaXplKSB7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoQ29weSA9IFsuLi5tYXRjaF07XG4gICAgbWF0Y2gubGVuZ3RoID0gMTtcbiAgICBsZXQgaW5kaWNlc0NvcHk7XG4gICAgaWYgKHRoaXMuaGFzSW5kaWNlcykge1xuICAgICAgaW5kaWNlc0NvcHkgPSBbLi4ubWF0Y2guaW5kaWNlc107XG4gICAgICBtYXRjaC5pbmRpY2VzLmxlbmd0aCA9IDE7XG4gICAgfVxuICAgIGNvbnN0IG1hcHBlZE51bXMgPSBbMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBtYXRjaENvcHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgaGlkZGVuLCB0cmFuc2ZlclRvIH0gPSB0aGlzLiNjYXB0dXJlTWFwLmdldChpKSA/PyB7fTtcbiAgICAgIGlmIChoaWRkZW4pIHtcbiAgICAgICAgbWFwcGVkTnVtcy5wdXNoKG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwcGVkTnVtcy5wdXNoKG1hdGNoLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLnB1c2gobWF0Y2hDb3B5W2ldKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzSW5kaWNlcykge1xuICAgICAgICAgIG1hdGNoLmluZGljZXMucHVzaChpbmRpY2VzQ29weVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2ZlclRvICYmIG1hdGNoQ29weVtpXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHRvID0gdGhyb3dJZk5vdChtYXBwZWROdW1zW3RyYW5zZmVyVG9dKTtcbiAgICAgICAgbWF0Y2hbdG9dID0gbWF0Y2hDb3B5W2ldO1xuICAgICAgICBpZiAodGhpcy5oYXNJbmRpY2VzKSB7XG4gICAgICAgICAgbWF0Y2guaW5kaWNlc1t0b10gPSBpbmRpY2VzQ29weVtpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2guZ3JvdXBzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNuYW1lTWFwKSB7XG4gICAgICAgICAgICB0aGlzLiNuYW1lTWFwID0gY3JlYXRlTmFtZU1hcCh0aGlzLnNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLiNuYW1lTWFwLmdldCh0cmFuc2ZlclRvKTtcbiAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgbWF0Y2guZ3JvdXBzW25hbWVdID0gbWF0Y2hDb3B5W2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzSW5kaWNlcykge1xuICAgICAgICAgICAgICBtYXRjaC5pbmRpY2VzLmdyb3Vwc1tuYW1lXSA9IGluZGljZXNDb3B5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH1cbn07XG5mdW5jdGlvbiBhZGp1c3RNYXRjaERldGFpbHNGb3JPZmZzZXQobWF0Y2gsIG9mZnNldCwgaW5wdXQsIGhhc0luZGljZXMpIHtcbiAgbWF0Y2guaW5kZXggKz0gb2Zmc2V0O1xuICBtYXRjaC5pbnB1dCA9IGlucHV0O1xuICBpZiAoaGFzSW5kaWNlcykge1xuICAgIGNvbnN0IGluZGljZXMgPSBtYXRjaC5pbmRpY2VzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXJyID0gaW5kaWNlc1tpXTtcbiAgICAgIGlmIChhcnIpIHtcbiAgICAgICAgaW5kaWNlc1tpXSA9IFthcnJbMF0gKyBvZmZzZXQsIGFyclsxXSArIG9mZnNldF07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGdyb3VwSW5kaWNlcyA9IGluZGljZXMuZ3JvdXBzO1xuICAgIGlmIChncm91cEluZGljZXMpIHtcbiAgICAgIE9iamVjdC5rZXlzKGdyb3VwSW5kaWNlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IGFyciA9IGdyb3VwSW5kaWNlc1trZXldO1xuICAgICAgICBpZiAoYXJyKSB7XG4gICAgICAgICAgZ3JvdXBJbmRpY2VzW2tleV0gPSBbYXJyWzBdICsgb2Zmc2V0LCBhcnJbMV0gKyBvZmZzZXRdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVNYXAoaGlkZGVuQ2FwdHVyZXMsIHRyYW5zZmVycykge1xuICBjb25zdCBjYXB0dXJlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBudW0gb2YgaGlkZGVuQ2FwdHVyZXMpIHtcbiAgICBjYXB0dXJlTWFwLnNldChudW0sIHtcbiAgICAgIGhpZGRlbjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGZvciAoY29uc3QgW3RvLCBmcm9tXSBvZiB0cmFuc2ZlcnMpIHtcbiAgICBmb3IgKGNvbnN0IG51bSBvZiBmcm9tKSB7XG4gICAgICBnZXRPckluc2VydChjYXB0dXJlTWFwLCBudW0sIHt9KS50cmFuc2ZlclRvID0gdG87XG4gICAgfVxuICB9XG4gIHJldHVybiBjYXB0dXJlTWFwO1xufVxuZnVuY3Rpb24gY3JlYXRlTmFtZU1hcChwYXR0ZXJuKSB7XG4gIGNvbnN0IHJlID0gLyg/PGNhcHR1cmU+XFwoKD86XFw/PCg/IVs9IV0pKD88bmFtZT5bXj5dKyk+fCg/IVxcPykpKXxcXFxcPy4vZ3N1O1xuICBjb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBsZXQgbnVtQ2hhckNsYXNzZXNPcGVuID0gMDtcbiAgbGV0IG51bUNhcHR1cmVzID0gMDtcbiAgbGV0IG1hdGNoO1xuICB3aGlsZSAobWF0Y2ggPSByZS5leGVjKHBhdHRlcm4pKSB7XG4gICAgY29uc3QgeyAwOiBtLCBncm91cHM6IHsgY2FwdHVyZSwgbmFtZSB9IH0gPSBtYXRjaDtcbiAgICBpZiAobSA9PT0gXCJbXCIpIHtcbiAgICAgIG51bUNoYXJDbGFzc2VzT3BlbisrO1xuICAgIH0gZWxzZSBpZiAoIW51bUNoYXJDbGFzc2VzT3Blbikge1xuICAgICAgaWYgKGNhcHR1cmUpIHtcbiAgICAgICAgbnVtQ2FwdHVyZXMrKztcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICBtYXAuc2V0KG51bUNhcHR1cmVzLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobSA9PT0gXCJdXCIpIHtcbiAgICAgIG51bUNoYXJDbGFzc2VzT3Blbi0tO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWFwO1xufVxuXG4vLyBzcmMvaW5kZXguanNcbmltcG9ydCB7IGF0b21pYywgcG9zc2Vzc2l2ZSB9IGZyb20gXCJyZWdleC9pbnRlcm5hbHNcIjtcbmltcG9ydCB7IHJlY3Vyc2lvbiB9IGZyb20gXCJyZWdleC1yZWN1cnNpb25cIjtcbmZ1bmN0aW9uIHRvT25pZ3VydW1hQXN0KHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBmbGFnczogb3B0aW9ucz8uZmxhZ3MgPz8gXCJcIixcbiAgICBydWxlczoge1xuICAgICAgY2FwdHVyZUdyb3VwOiBmYWxzZSxcbiAgICAgIHNpbmdsZWxpbmU6IGZhbHNlLFxuICAgICAgLi4ub3B0aW9ucz8ucnVsZXNcbiAgICB9XG4gIH07XG4gIHJldHVybiBwYXJzZSh0b2tlbml6ZShwYXR0ZXJuLCBvcHRzLmZsYWdzLCBvcHRzLnJ1bGVzKSk7XG59XG5mdW5jdGlvbiB0b1JlZ0V4cChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGNvbnN0IGQgPSB0b1JlZ0V4cERldGFpbHMocGF0dGVybiwgb3B0aW9ucyk7XG4gIGlmIChkLm9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEVtdWxhdGVkUmVnRXhwKGQucGF0dGVybiwgZC5mbGFncywgZC5vcHRpb25zKTtcbiAgfVxuICByZXR1cm4gbmV3IFJlZ0V4cChkLnBhdHRlcm4sIGQuZmxhZ3MpO1xufVxuZnVuY3Rpb24gdG9SZWdFeHBEZXRhaWxzKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IGdldE9wdGlvbnMob3B0aW9ucyk7XG4gIGNvbnN0IHRva2VuaXplZCA9IHRva2VuaXplKHBhdHRlcm4sIG9wdHMuZmxhZ3MsIHtcbiAgICBjYXB0dXJlR3JvdXA6IG9wdHMucnVsZXMuY2FwdHVyZUdyb3VwLFxuICAgIHNpbmdsZWxpbmU6IG9wdHMucnVsZXMuc2luZ2xlbGluZVxuICB9KTtcbiAgY29uc3Qgb25pZ3VydW1hQXN0ID0gcGFyc2UodG9rZW5pemVkLCB7XG4gICAgc2tpcEJhY2tyZWZWYWxpZGF0aW9uOiBvcHRzLnJ1bGVzLmFsbG93T3JwaGFuQmFja3JlZnMsXG4gICAgdmVyYm9zZTogb3B0cy52ZXJib3NlXG4gIH0pO1xuICBjb25zdCByZWdleEFzdCA9IHRyYW5zZm9ybShvbmlndXJ1bWFBc3QsIHtcbiAgICBhY2N1cmFjeTogb3B0cy5hY2N1cmFjeSxcbiAgICBhc2NpaVdvcmRCb3VuZGFyaWVzOiBvcHRzLnJ1bGVzLmFzY2lpV29yZEJvdW5kYXJpZXMsXG4gICAgYXZvaWRTdWJjbGFzczogb3B0cy5hdm9pZFN1YmNsYXNzLFxuICAgIGJlc3RFZmZvcnRUYXJnZXQ6IG9wdHMudGFyZ2V0XG4gIH0pO1xuICBjb25zdCBnZW5lcmF0ZWQgPSBnZW5lcmF0ZShyZWdleEFzdCwgb3B0cyk7XG4gIGNvbnN0IHJlY3Vyc2lvblJlc3VsdCA9IHJlY3Vyc2lvbihnZW5lcmF0ZWQucGF0dGVybiwge1xuICAgIGNhcHR1cmVUcmFuc2ZlcnM6IGdlbmVyYXRlZC5fY2FwdHVyZVRyYW5zZmVycyxcbiAgICBoaWRkZW5DYXB0dXJlczogZ2VuZXJhdGVkLl9oaWRkZW5DYXB0dXJlcyxcbiAgICBtb2RlOiBcImV4dGVybmFsXCJcbiAgfSk7XG4gIGNvbnN0IHBvc3Nlc3NpdmVSZXN1bHQgPSBwb3NzZXNzaXZlKHJlY3Vyc2lvblJlc3VsdC5wYXR0ZXJuKTtcbiAgY29uc3QgYXRvbWljUmVzdWx0ID0gYXRvbWljKHBvc3Nlc3NpdmVSZXN1bHQucGF0dGVybiwge1xuICAgIGNhcHR1cmVUcmFuc2ZlcnM6IHJlY3Vyc2lvblJlc3VsdC5jYXB0dXJlVHJhbnNmZXJzLFxuICAgIGhpZGRlbkNhcHR1cmVzOiByZWN1cnNpb25SZXN1bHQuaGlkZGVuQ2FwdHVyZXNcbiAgfSk7XG4gIGNvbnN0IGRldGFpbHMgPSB7XG4gICAgcGF0dGVybjogYXRvbWljUmVzdWx0LnBhdHRlcm4sXG4gICAgZmxhZ3M6IGAke29wdHMuaGFzSW5kaWNlcyA/IFwiZFwiIDogXCJcIn0ke29wdHMuZ2xvYmFsID8gXCJnXCIgOiBcIlwifSR7Z2VuZXJhdGVkLmZsYWdzfSR7Z2VuZXJhdGVkLm9wdGlvbnMuZGlzYWJsZS52ID8gXCJ1XCIgOiBcInZcIn1gXG4gIH07XG4gIGlmIChvcHRzLmF2b2lkU3ViY2xhc3MpIHtcbiAgICBpZiAob3B0cy5sYXp5Q29tcGlsZUxlbmd0aCAhPT0gSW5maW5pdHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxhenkgY29tcGlsYXRpb24gcmVxdWlyZXMgc3ViY2xhc3NcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGhpZGRlbkNhcHR1cmVzID0gYXRvbWljUmVzdWx0LmhpZGRlbkNhcHR1cmVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICBjb25zdCB0cmFuc2ZlcnMgPSBBcnJheS5mcm9tKGF0b21pY1Jlc3VsdC5jYXB0dXJlVHJhbnNmZXJzKTtcbiAgICBjb25zdCBzdHJhdGVneSA9IHJlZ2V4QXN0Ll9zdHJhdGVneTtcbiAgICBjb25zdCBsYXp5Q29tcGlsZSA9IGRldGFpbHMucGF0dGVybi5sZW5ndGggPj0gb3B0cy5sYXp5Q29tcGlsZUxlbmd0aDtcbiAgICBpZiAoaGlkZGVuQ2FwdHVyZXMubGVuZ3RoIHx8IHRyYW5zZmVycy5sZW5ndGggfHwgc3RyYXRlZ3kgfHwgbGF6eUNvbXBpbGUpIHtcbiAgICAgIGRldGFpbHMub3B0aW9ucyA9IHtcbiAgICAgICAgLi4uaGlkZGVuQ2FwdHVyZXMubGVuZ3RoICYmIHsgaGlkZGVuQ2FwdHVyZXMgfSxcbiAgICAgICAgLi4udHJhbnNmZXJzLmxlbmd0aCAmJiB7IHRyYW5zZmVycyB9LFxuICAgICAgICAuLi5zdHJhdGVneSAmJiB7IHN0cmF0ZWd5IH0sXG4gICAgICAgIC4uLmxhenlDb21waWxlICYmIHsgbGF6eUNvbXBpbGUgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRldGFpbHM7XG59XG5leHBvcnQge1xuICBFbXVsYXRlZFJlZ0V4cCxcbiAgdG9PbmlndXJ1bWFBc3QsXG4gIHRvUmVnRXhwLFxuICB0b1JlZ0V4cERldGFpbHNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/oniguruma-to-es@3.1.1/node_modules/oniguruma-to-es/dist/esm/index.js\n");

/***/ })

};
;