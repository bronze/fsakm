"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/retext-smartypants@6.2.0";
exports.ids = ["vendor-chunks/retext-smartypants@6.2.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/retext-smartypants@6.2.0/node_modules/retext-smartypants/lib/index.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/retext-smartypants@6.2.0/node_modules/retext-smartypants/lib/index.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ retextSmartypants)\n/* harmony export */ });\n/* harmony import */ var unist_util_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unist-util-visit */ \"(rsc)/./node_modules/.pnpm/unist-util-visit@5.0.0/node_modules/unist-util-visit/lib/index.js\");\n/* harmony import */ var nlcst_to_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! nlcst-to-string */ \"(rsc)/./node_modules/.pnpm/nlcst-to-string@4.0.0/node_modules/nlcst-to-string/lib/index.js\");\n/**\n * @import {Parents, Punctuation, Root, SentenceContent, Symbol} from 'nlcst'\n */\n\n/**\n * @callback Method\n *   Transform.\n * @param {State} state\n *   Info passed around.\n * @param {Punctuation | Symbol} node\n *   Node.\n * @param {number} index\n *   Position of `node` in `parent`.\n * @param {Parents} parent\n *   Parent of `node`.\n * @returns {boolean | undefined | void}\n *   Whether to remove the node (`true`); or not (otherwise).\n *\n * @typedef Options\n *   Configuration.\n * @property {'all' | boolean | null | undefined} [backticks=true]\n *   Transform backticks (default: `true`); when `true`, turns double\n *   backticks into an opening double quote and double straight single quotes\n *   into a closing double quote; when `'all'`, does that and turns single\n *   backticks into an opening single quote and a straight single quotes into\n *   a closing single smart quote; `quotes: false` must be used with\n *   `backticks: 'all'`.\n * @property {QuoteCharacterMap | null | undefined} [closingQuotes]\n *   Closing quotes to use (default: `{double: '”', single: '’'}`).\n * @property {'inverted' | 'oldschool' | boolean | null | undefined} [dashes=true]\n *   Transform dashes (default: `true`);\n *   when `true`, turns two dashes into an em dash character;\n *   when `'oldschool'`, turns three dashes into an em dash and two into an en\n *   dash;\n *   when `'inverted'`, turns three dashes into an en dash and two into an em\n *   dash.\n * @property {'spaced' | 'unspaced' | boolean | null | undefined} [ellipses=true]\n *   Transform triple dots (default: `true`).\n *   when `'spaced'`, turns triple dots with spaces into ellipses;\n *   when `'unspaced'`, turns triple dots without spaces into ellipses;\n *   when `true`, turns triple dots with or without spaces into ellipses.\n * @property {QuoteCharacterMap | null | undefined} [openingQuotes]\n *   Opening quotes to use (default: `{double: '“', single: '‘'}`).\n * @property {boolean | null | undefined} [quotes=true]\n *   Transform straight quotes into smart quotes (default: `true`).\n *\n * @typedef State\n *   Info passed around.\n * @property {Quotes} close\n *   Closing quotes.\n * @property {Quotes} open\n *   Opening quotes.\n *\n * @typedef QuoteCharacterMap\n *   Quote characters.\n * @property {string} double\n *   Character to use for double quotes.\n * @property {string} single\n *   Character to use for single quotes.\n *\n * @typedef {[string, string]} Quotes\n *   Quotes.\n */\n\n\n\n\n/** @type {Quotes} */\nconst defaultClosingQuotes = ['”', '’']\n/** @type {Quotes} */\nconst defaultOpeningQuotes = ['“', '‘']\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n\n/**\n * Replace straight punctuation marks with curly ones.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nfunction retextSmartypants(options) {\n  const settings = options || emptyOptions\n  /** @type {Array<Method>} */\n  const methods = []\n\n  if (settings.quotes !== false) {\n    methods.push(quotesDefault)\n  }\n\n  if (settings.ellipses === 'spaced') {\n    methods.push(ellipsesSpaced)\n  } else if (settings.ellipses === 'unspaced') {\n    methods.push(ellipsesUnspaced)\n  } else if (settings.ellipses !== false) {\n    methods.push(ellipsesDefault)\n  }\n\n  if (settings.backticks === 'all') {\n    if (settings.quotes !== false) {\n      throw new Error(\"Cannot accept `backticks: 'all'` with `quotes: true`\")\n    }\n\n    methods.push(backticksAll)\n  } else if (settings.backticks !== false) {\n    methods.push(backticksDefault)\n  }\n\n  if (settings.dashes === 'inverted') {\n    methods.push(dashesInverted)\n  } else if (settings.dashes === 'oldschool') {\n    methods.push(dashesOldschool)\n  } else if (settings.dashes !== false) {\n    methods.push(dashesDefault)\n  }\n\n  /** @type {State} */\n  const state = {\n    close: settings.closingQuotes\n      ? [settings.closingQuotes.double, settings.closingQuotes.single]\n      : defaultClosingQuotes,\n    open: settings.openingQuotes\n      ? [settings.openingQuotes.double, settings.openingQuotes.single]\n      : defaultOpeningQuotes\n  }\n\n  /**\n   * Transform.\n   *\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    ;(0,unist_util_visit__WEBPACK_IMPORTED_MODULE_0__.visit)(tree, function (node, position, parent) {\n      let index = -1\n\n      if (\n        parent &&\n        position !== undefined &&\n        (node.type === 'PunctuationNode' || node.type === 'SymbolNode')\n      ) {\n        while (++index < methods.length) {\n          const result = methods[index](state, node, position, parent)\n          if (result === true) {\n            console.log('drop', node)\n            parent.children.splice(position, 1)\n            return position\n          }\n        }\n      }\n    })\n  }\n}\n\n/**\n * Transform single and double backticks and single quotes into smart quotes.\n *\n * @type {Method}\n */\nfunction backticksAll(state, node, index, parent) {\n  backticksDefault(state, node, index, parent)\n\n  if (node.value === '`') {\n    node.value = '‘'\n  } else if (node.value === \"'\") {\n    node.value = '’'\n  }\n}\n\n/**\n * Transform double backticks and single quotes into smart quotes.\n *\n * @type {Method}\n */\nfunction backticksDefault(_, node) {\n  if (node.value === '``') {\n    node.value = '“'\n  } else if (node.value === \"''\") {\n    node.value = '”'\n  }\n}\n\n/**\n * Transform two dashes into an em dash.\n *\n * @type {Method}\n */\nfunction dashesDefault(_, node) {\n  if (node.value === '--') {\n    node.value = '—'\n  }\n}\n\n/**\n * Transform three dashes into an en dash, and two into an em dash.\n *\n * @type {Method}\n */\nfunction dashesInverted(_, node, index, parent) {\n  const next = parent.children[index + 1]\n\n  if (\n    node.value === '—' &&\n    next &&\n    next.type === 'PunctuationNode' &&\n    next.value === '-'\n  ) {\n    next.value = '–'\n    return true\n  }\n\n  if (node.value === '---') {\n    node.value = '–'\n  } else if (node.value === '--') {\n    node.value = '—'\n  }\n}\n\n/**\n * Transform three dashes into an em dash, and two into an en dash.\n *\n * @type {Method}\n */\nfunction dashesOldschool(_, node, index, parent) {\n  const next = parent.children[index + 1]\n\n  if (\n    node.value === '–' &&\n    next &&\n    next.type === 'PunctuationNode' &&\n    next.value === '-'\n  ) {\n    next.value = '—'\n    return true\n  }\n\n  if (node.value === '---') {\n    node.value = '—'\n  } else if (node.value === '--') {\n    node.value = '–'\n  }\n}\n\n/**\n * Transform multiple dots into unicode ellipses.\n *\n * @type {Method}\n */\nfunction ellipsesDefault(_, node, index, parent) {\n  ellipsesSpaced(_, node, index, parent)\n  ellipsesUnspaced(_, node, index, parent)\n}\n\n/**\n * Transform multiple dots with spaces into unicode ellipses.\n *\n * @type {Method}\n */\nfunction ellipsesSpaced(_, node, index, parent) {\n  const value = node.value\n  const siblings = parent.children\n\n  if (!/^\\.+$/.test(value)) {\n    return\n  }\n\n  // Search for dot-nodes with whitespace between.\n  /** @type {Array<SentenceContent>} */\n  const nodes = []\n  let position = index\n  let count = 1\n\n  // It’s possible that the node is merged with an adjacent word-node.  In that\n  // code, we cannot transform it because there’s no reference to the\n  // grandparent.\n  while (--position > 0) {\n    let sibling = siblings[position]\n\n    if (sibling.type !== 'WhiteSpaceNode') {\n      break\n    }\n\n    const queue = sibling\n    sibling = siblings[--position]\n\n    if (\n      sibling &&\n      (sibling.type === 'PunctuationNode' || sibling.type === 'SymbolNode') &&\n      /^\\.+$/.test(sibling.value)\n    ) {\n      nodes.push(queue, sibling)\n\n      count++\n\n      continue\n    }\n\n    break\n  }\n\n  if (count < 3) {\n    return\n  }\n\n  siblings.splice(index - nodes.length, nodes.length)\n\n  node.value = '…'\n}\n\n/**\n * Transform multiple dots without spaces into unicode ellipses.\n *\n * @type {Method}\n */\nfunction ellipsesUnspaced(_, node) {\n  // Simple node with three dots and without whitespace.\n  if (/^\\.{3,}$/.test(node.value)) {\n    node.value = '…'\n  }\n}\n\n/**\n * Transform straight single- and double quotes into smart quotes.\n *\n * @type {Method}\n */\n// eslint-disable-next-line complexity\nfunction quotesDefault(state, node, index, parent) {\n  const siblings = parent.children\n  const value = node.value\n\n  if (value !== '\"' && value !== \"'\") {\n    return\n  }\n\n  const quoteIndex = value === '\"' ? 0 : 1\n  const previous = siblings[index - 1]\n  const next = siblings[index + 1]\n  const nextNext = siblings[index + 2]\n  const nextValue = next ? (0,nlcst_to_string__WEBPACK_IMPORTED_MODULE_1__.toString)(next) : ''\n\n  if (\n    next &&\n    (next.type === 'PunctuationNode' || next.type === 'SymbolNode') &&\n    (!nextNext || nextNext.type !== 'WordNode')\n  ) {\n    // Special case if the very first character is a quote followed by\n    // punctuation at a non-word-break. Close the quotes by brute force.\n    node.value = state.close[quoteIndex]\n  } else if (\n    next &&\n    (next.type === 'PunctuationNode' || next.type === 'SymbolNode') &&\n    (nextValue === '\"' || nextValue === \"'\") &&\n    nextNext &&\n    nextNext.type === 'WordNode'\n  ) {\n    // Special case for double sets of quotes:\n    // `He said, \"'Quoted' words in a larger quote.\"`\n    node.value = state.open[quoteIndex]\n    next.value = state.open[nextValue === '\"' ? 0 : 1]\n  } else if (next && /^\\d\\ds$/.test(nextValue)) {\n    // Special case for decade abbreviations: `the '80s`\n    node.value = state.close[quoteIndex]\n  } else if (\n    previous &&\n    (previous.type === 'WhiteSpaceNode' ||\n      previous.type === 'PunctuationNode' ||\n      previous.type === 'SymbolNode') &&\n    next &&\n    next.type === 'WordNode'\n  ) {\n    // Get most opening single quotes.\n    node.value = state.open[quoteIndex]\n  } else if (\n    previous &&\n    previous.type !== 'WhiteSpaceNode' &&\n    previous.type !== 'SymbolNode' &&\n    previous.type !== 'PunctuationNode'\n  ) {\n    // Closing quotes.\n    node.value = state.close[quoteIndex]\n  } else if (\n    !next ||\n    next.type === 'WhiteSpaceNode' ||\n    (value === \"'\" && nextValue === 's')\n  ) {\n    node.value = state.close[quoteIndex]\n  } else {\n    node.value = state.open[quoteIndex]\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vcmV0ZXh0LXNtYXJ0eXBhbnRzQDYuMi4wL25vZGVfbW9kdWxlcy9yZXRleHQtc21hcnR5cGFudHMvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0EsWUFBWSxxREFBcUQ7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2IsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0NBQW9DO0FBQ2xELDRDQUE0QztBQUM1QztBQUNBLGtDQUFrQztBQUNsQztBQUNBLG1DQUFtQztBQUNuQztBQUNBLGNBQWMsc0NBQXNDO0FBQ3BELHVDQUF1Qyx5QkFBeUI7QUFDaEUsY0FBYyx1REFBdUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvREFBb0Q7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNDQUFzQztBQUNwRCx1Q0FBdUMseUJBQXlCO0FBQ2hFLGNBQWMsNEJBQTRCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBOztBQUVzQztBQUNFOztBQUV4QyxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7O0FBRUEsV0FBVyxtQkFBbUI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQ0FBc0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0EsYUFBYSxlQUFlO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLElBQUksd0RBQUs7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseURBQVE7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2Jyb256ZS9jb2RpbmcvZnNha20vbm9kZV9tb2R1bGVzLy5wbnBtL3JldGV4dC1zbWFydHlwYW50c0A2LjIuMC9ub2RlX21vZHVsZXMvcmV0ZXh0LXNtYXJ0eXBhbnRzL2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge1BhcmVudHMsIFB1bmN0dWF0aW9uLCBSb290LCBTZW50ZW5jZUNvbnRlbnQsIFN5bWJvbH0gZnJvbSAnbmxjc3QnXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgTWV0aG9kXG4gKiAgIFRyYW5zZm9ybS5cbiAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gKiAgIEluZm8gcGFzc2VkIGFyb3VuZC5cbiAqIEBwYXJhbSB7UHVuY3R1YXRpb24gfCBTeW1ib2x9IG5vZGVcbiAqICAgTm9kZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogICBQb3NpdGlvbiBvZiBgbm9kZWAgaW4gYHBhcmVudGAuXG4gKiBAcGFyYW0ge1BhcmVudHN9IHBhcmVudFxuICogICBQYXJlbnQgb2YgYG5vZGVgLlxuICogQHJldHVybnMge2Jvb2xlYW4gfCB1bmRlZmluZWQgfCB2b2lkfVxuICogICBXaGV0aGVyIHRvIHJlbW92ZSB0aGUgbm9kZSAoYHRydWVgKTsgb3Igbm90IChvdGhlcndpc2UpLlxuICpcbiAqIEB0eXBlZGVmIE9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7J2FsbCcgfCBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2JhY2t0aWNrcz10cnVlXVxuICogICBUcmFuc2Zvcm0gYmFja3RpY2tzIChkZWZhdWx0OiBgdHJ1ZWApOyB3aGVuIGB0cnVlYCwgdHVybnMgZG91YmxlXG4gKiAgIGJhY2t0aWNrcyBpbnRvIGFuIG9wZW5pbmcgZG91YmxlIHF1b3RlIGFuZCBkb3VibGUgc3RyYWlnaHQgc2luZ2xlIHF1b3Rlc1xuICogICBpbnRvIGEgY2xvc2luZyBkb3VibGUgcXVvdGU7IHdoZW4gYCdhbGwnYCwgZG9lcyB0aGF0IGFuZCB0dXJucyBzaW5nbGVcbiAqICAgYmFja3RpY2tzIGludG8gYW4gb3BlbmluZyBzaW5nbGUgcXVvdGUgYW5kIGEgc3RyYWlnaHQgc2luZ2xlIHF1b3RlcyBpbnRvXG4gKiAgIGEgY2xvc2luZyBzaW5nbGUgc21hcnQgcXVvdGU7IGBxdW90ZXM6IGZhbHNlYCBtdXN0IGJlIHVzZWQgd2l0aFxuICogICBgYmFja3RpY2tzOiAnYWxsJ2AuXG4gKiBAcHJvcGVydHkge1F1b3RlQ2hhcmFjdGVyTWFwIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2Nsb3NpbmdRdW90ZXNdXG4gKiAgIENsb3NpbmcgcXVvdGVzIHRvIHVzZSAoZGVmYXVsdDogYHtkb3VibGU6ICfigJ0nLCBzaW5nbGU6ICfigJknfWApLlxuICogQHByb3BlcnR5IHsnaW52ZXJ0ZWQnIHwgJ29sZHNjaG9vbCcgfCBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2Rhc2hlcz10cnVlXVxuICogICBUcmFuc2Zvcm0gZGFzaGVzIChkZWZhdWx0OiBgdHJ1ZWApO1xuICogICB3aGVuIGB0cnVlYCwgdHVybnMgdHdvIGRhc2hlcyBpbnRvIGFuIGVtIGRhc2ggY2hhcmFjdGVyO1xuICogICB3aGVuIGAnb2xkc2Nob29sJ2AsIHR1cm5zIHRocmVlIGRhc2hlcyBpbnRvIGFuIGVtIGRhc2ggYW5kIHR3byBpbnRvIGFuIGVuXG4gKiAgIGRhc2g7XG4gKiAgIHdoZW4gYCdpbnZlcnRlZCdgLCB0dXJucyB0aHJlZSBkYXNoZXMgaW50byBhbiBlbiBkYXNoIGFuZCB0d28gaW50byBhbiBlbVxuICogICBkYXNoLlxuICogQHByb3BlcnR5IHsnc3BhY2VkJyB8ICd1bnNwYWNlZCcgfCBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2VsbGlwc2VzPXRydWVdXG4gKiAgIFRyYW5zZm9ybSB0cmlwbGUgZG90cyAoZGVmYXVsdDogYHRydWVgKS5cbiAqICAgd2hlbiBgJ3NwYWNlZCdgLCB0dXJucyB0cmlwbGUgZG90cyB3aXRoIHNwYWNlcyBpbnRvIGVsbGlwc2VzO1xuICogICB3aGVuIGAndW5zcGFjZWQnYCwgdHVybnMgdHJpcGxlIGRvdHMgd2l0aG91dCBzcGFjZXMgaW50byBlbGxpcHNlcztcbiAqICAgd2hlbiBgdHJ1ZWAsIHR1cm5zIHRyaXBsZSBkb3RzIHdpdGggb3Igd2l0aG91dCBzcGFjZXMgaW50byBlbGxpcHNlcy5cbiAqIEBwcm9wZXJ0eSB7UXVvdGVDaGFyYWN0ZXJNYXAgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3BlbmluZ1F1b3Rlc11cbiAqICAgT3BlbmluZyBxdW90ZXMgdG8gdXNlIChkZWZhdWx0OiBge2RvdWJsZTogJ+KAnCcsIHNpbmdsZTogJ+KAmCd9YCkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbcXVvdGVzPXRydWVdXG4gKiAgIFRyYW5zZm9ybSBzdHJhaWdodCBxdW90ZXMgaW50byBzbWFydCBxdW90ZXMgKGRlZmF1bHQ6IGB0cnVlYCkuXG4gKlxuICogQHR5cGVkZWYgU3RhdGVcbiAqICAgSW5mbyBwYXNzZWQgYXJvdW5kLlxuICogQHByb3BlcnR5IHtRdW90ZXN9IGNsb3NlXG4gKiAgIENsb3NpbmcgcXVvdGVzLlxuICogQHByb3BlcnR5IHtRdW90ZXN9IG9wZW5cbiAqICAgT3BlbmluZyBxdW90ZXMuXG4gKlxuICogQHR5cGVkZWYgUXVvdGVDaGFyYWN0ZXJNYXBcbiAqICAgUXVvdGUgY2hhcmFjdGVycy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkb3VibGVcbiAqICAgQ2hhcmFjdGVyIHRvIHVzZSBmb3IgZG91YmxlIHF1b3Rlcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzaW5nbGVcbiAqICAgQ2hhcmFjdGVyIHRvIHVzZSBmb3Igc2luZ2xlIHF1b3Rlcy5cbiAqXG4gKiBAdHlwZWRlZiB7W3N0cmluZywgc3RyaW5nXX0gUXVvdGVzXG4gKiAgIFF1b3Rlcy5cbiAqL1xuXG5pbXBvcnQge3Zpc2l0fSBmcm9tICd1bmlzdC11dGlsLXZpc2l0J1xuaW1wb3J0IHt0b1N0cmluZ30gZnJvbSAnbmxjc3QtdG8tc3RyaW5nJ1xuXG4vKiogQHR5cGUge1F1b3Rlc30gKi9cbmNvbnN0IGRlZmF1bHRDbG9zaW5nUXVvdGVzID0gWyfigJ0nLCAn4oCZJ11cbi8qKiBAdHlwZSB7UXVvdGVzfSAqL1xuY29uc3QgZGVmYXVsdE9wZW5pbmdRdW90ZXMgPSBbJ+KAnCcsICfigJgnXVxuXG4vKiogQHR5cGUge1JlYWRvbmx5PE9wdGlvbnM+fSAqL1xuY29uc3QgZW1wdHlPcHRpb25zID0ge31cblxuLyoqXG4gKiBSZXBsYWNlIHN0cmFpZ2h0IHB1bmN0dWF0aW9uIG1hcmtzIHdpdGggY3VybHkgb25lcy5cbiAqXG4gKiBAcGFyYW0ge1JlYWRvbmx5PE9wdGlvbnM+IHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zXG4gKiAgIFRyYW5zZm9ybS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmV0ZXh0U21hcnR5cGFudHMob3B0aW9ucykge1xuICBjb25zdCBzZXR0aW5ncyA9IG9wdGlvbnMgfHwgZW1wdHlPcHRpb25zXG4gIC8qKiBAdHlwZSB7QXJyYXk8TWV0aG9kPn0gKi9cbiAgY29uc3QgbWV0aG9kcyA9IFtdXG5cbiAgaWYgKHNldHRpbmdzLnF1b3RlcyAhPT0gZmFsc2UpIHtcbiAgICBtZXRob2RzLnB1c2gocXVvdGVzRGVmYXVsdClcbiAgfVxuXG4gIGlmIChzZXR0aW5ncy5lbGxpcHNlcyA9PT0gJ3NwYWNlZCcpIHtcbiAgICBtZXRob2RzLnB1c2goZWxsaXBzZXNTcGFjZWQpXG4gIH0gZWxzZSBpZiAoc2V0dGluZ3MuZWxsaXBzZXMgPT09ICd1bnNwYWNlZCcpIHtcbiAgICBtZXRob2RzLnB1c2goZWxsaXBzZXNVbnNwYWNlZClcbiAgfSBlbHNlIGlmIChzZXR0aW5ncy5lbGxpcHNlcyAhPT0gZmFsc2UpIHtcbiAgICBtZXRob2RzLnB1c2goZWxsaXBzZXNEZWZhdWx0KVxuICB9XG5cbiAgaWYgKHNldHRpbmdzLmJhY2t0aWNrcyA9PT0gJ2FsbCcpIHtcbiAgICBpZiAoc2V0dGluZ3MucXVvdGVzICE9PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFjY2VwdCBgYmFja3RpY2tzOiAnYWxsJ2Agd2l0aCBgcXVvdGVzOiB0cnVlYFwiKVxuICAgIH1cblxuICAgIG1ldGhvZHMucHVzaChiYWNrdGlja3NBbGwpXG4gIH0gZWxzZSBpZiAoc2V0dGluZ3MuYmFja3RpY2tzICE9PSBmYWxzZSkge1xuICAgIG1ldGhvZHMucHVzaChiYWNrdGlja3NEZWZhdWx0KVxuICB9XG5cbiAgaWYgKHNldHRpbmdzLmRhc2hlcyA9PT0gJ2ludmVydGVkJykge1xuICAgIG1ldGhvZHMucHVzaChkYXNoZXNJbnZlcnRlZClcbiAgfSBlbHNlIGlmIChzZXR0aW5ncy5kYXNoZXMgPT09ICdvbGRzY2hvb2wnKSB7XG4gICAgbWV0aG9kcy5wdXNoKGRhc2hlc09sZHNjaG9vbClcbiAgfSBlbHNlIGlmIChzZXR0aW5ncy5kYXNoZXMgIT09IGZhbHNlKSB7XG4gICAgbWV0aG9kcy5wdXNoKGRhc2hlc0RlZmF1bHQpXG4gIH1cblxuICAvKiogQHR5cGUge1N0YXRlfSAqL1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBjbG9zZTogc2V0dGluZ3MuY2xvc2luZ1F1b3Rlc1xuICAgICAgPyBbc2V0dGluZ3MuY2xvc2luZ1F1b3Rlcy5kb3VibGUsIHNldHRpbmdzLmNsb3NpbmdRdW90ZXMuc2luZ2xlXVxuICAgICAgOiBkZWZhdWx0Q2xvc2luZ1F1b3RlcyxcbiAgICBvcGVuOiBzZXR0aW5ncy5vcGVuaW5nUXVvdGVzXG4gICAgICA/IFtzZXR0aW5ncy5vcGVuaW5nUXVvdGVzLmRvdWJsZSwgc2V0dGluZ3Mub3BlbmluZ1F1b3Rlcy5zaW5nbGVdXG4gICAgICA6IGRlZmF1bHRPcGVuaW5nUXVvdGVzXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtLlxuICAgKlxuICAgKiBAcGFyYW0ge1Jvb3R9IHRyZWVcbiAgICogICBUcmVlLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiAgIE5vdGhpbmcuXG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gKHRyZWUpIHtcbiAgICB2aXNpdCh0cmVlLCBmdW5jdGlvbiAobm9kZSwgcG9zaXRpb24sIHBhcmVudCkge1xuICAgICAgbGV0IGluZGV4ID0gLTFcblxuICAgICAgaWYgKFxuICAgICAgICBwYXJlbnQgJiZcbiAgICAgICAgcG9zaXRpb24gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAobm9kZS50eXBlID09PSAnUHVuY3R1YXRpb25Ob2RlJyB8fCBub2RlLnR5cGUgPT09ICdTeW1ib2xOb2RlJylcbiAgICAgICkge1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IG1ldGhvZHMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWV0aG9kc1tpbmRleF0oc3RhdGUsIG5vZGUsIHBvc2l0aW9uLCBwYXJlbnQpXG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2Ryb3AnLCBub2RlKVxuICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShwb3NpdGlvbiwgMSlcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gc2luZ2xlIGFuZCBkb3VibGUgYmFja3RpY2tzIGFuZCBzaW5nbGUgcXVvdGVzIGludG8gc21hcnQgcXVvdGVzLlxuICpcbiAqIEB0eXBlIHtNZXRob2R9XG4gKi9cbmZ1bmN0aW9uIGJhY2t0aWNrc0FsbChzdGF0ZSwgbm9kZSwgaW5kZXgsIHBhcmVudCkge1xuICBiYWNrdGlja3NEZWZhdWx0KHN0YXRlLCBub2RlLCBpbmRleCwgcGFyZW50KVxuXG4gIGlmIChub2RlLnZhbHVlID09PSAnYCcpIHtcbiAgICBub2RlLnZhbHVlID0gJ+KAmCdcbiAgfSBlbHNlIGlmIChub2RlLnZhbHVlID09PSBcIidcIikge1xuICAgIG5vZGUudmFsdWUgPSAn4oCZJ1xuICB9XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGRvdWJsZSBiYWNrdGlja3MgYW5kIHNpbmdsZSBxdW90ZXMgaW50byBzbWFydCBxdW90ZXMuXG4gKlxuICogQHR5cGUge01ldGhvZH1cbiAqL1xuZnVuY3Rpb24gYmFja3RpY2tzRGVmYXVsdChfLCBub2RlKSB7XG4gIGlmIChub2RlLnZhbHVlID09PSAnYGAnKSB7XG4gICAgbm9kZS52YWx1ZSA9ICfigJwnXG4gIH0gZWxzZSBpZiAobm9kZS52YWx1ZSA9PT0gXCInJ1wiKSB7XG4gICAgbm9kZS52YWx1ZSA9ICfigJ0nXG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdHdvIGRhc2hlcyBpbnRvIGFuIGVtIGRhc2guXG4gKlxuICogQHR5cGUge01ldGhvZH1cbiAqL1xuZnVuY3Rpb24gZGFzaGVzRGVmYXVsdChfLCBub2RlKSB7XG4gIGlmIChub2RlLnZhbHVlID09PSAnLS0nKSB7XG4gICAgbm9kZS52YWx1ZSA9ICfigJQnXG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhyZWUgZGFzaGVzIGludG8gYW4gZW4gZGFzaCwgYW5kIHR3byBpbnRvIGFuIGVtIGRhc2guXG4gKlxuICogQHR5cGUge01ldGhvZH1cbiAqL1xuZnVuY3Rpb24gZGFzaGVzSW52ZXJ0ZWQoXywgbm9kZSwgaW5kZXgsIHBhcmVudCkge1xuICBjb25zdCBuZXh0ID0gcGFyZW50LmNoaWxkcmVuW2luZGV4ICsgMV1cblxuICBpZiAoXG4gICAgbm9kZS52YWx1ZSA9PT0gJ+KAlCcgJiZcbiAgICBuZXh0ICYmXG4gICAgbmV4dC50eXBlID09PSAnUHVuY3R1YXRpb25Ob2RlJyAmJlxuICAgIG5leHQudmFsdWUgPT09ICctJ1xuICApIHtcbiAgICBuZXh0LnZhbHVlID0gJ+KAkydcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKG5vZGUudmFsdWUgPT09ICctLS0nKSB7XG4gICAgbm9kZS52YWx1ZSA9ICfigJMnXG4gIH0gZWxzZSBpZiAobm9kZS52YWx1ZSA9PT0gJy0tJykge1xuICAgIG5vZGUudmFsdWUgPSAn4oCUJ1xuICB9XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRocmVlIGRhc2hlcyBpbnRvIGFuIGVtIGRhc2gsIGFuZCB0d28gaW50byBhbiBlbiBkYXNoLlxuICpcbiAqIEB0eXBlIHtNZXRob2R9XG4gKi9cbmZ1bmN0aW9uIGRhc2hlc09sZHNjaG9vbChfLCBub2RlLCBpbmRleCwgcGFyZW50KSB7XG4gIGNvbnN0IG5leHQgPSBwYXJlbnQuY2hpbGRyZW5baW5kZXggKyAxXVxuXG4gIGlmIChcbiAgICBub2RlLnZhbHVlID09PSAn4oCTJyAmJlxuICAgIG5leHQgJiZcbiAgICBuZXh0LnR5cGUgPT09ICdQdW5jdHVhdGlvbk5vZGUnICYmXG4gICAgbmV4dC52YWx1ZSA9PT0gJy0nXG4gICkge1xuICAgIG5leHQudmFsdWUgPSAn4oCUJ1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAobm9kZS52YWx1ZSA9PT0gJy0tLScpIHtcbiAgICBub2RlLnZhbHVlID0gJ+KAlCdcbiAgfSBlbHNlIGlmIChub2RlLnZhbHVlID09PSAnLS0nKSB7XG4gICAgbm9kZS52YWx1ZSA9ICfigJMnXG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gbXVsdGlwbGUgZG90cyBpbnRvIHVuaWNvZGUgZWxsaXBzZXMuXG4gKlxuICogQHR5cGUge01ldGhvZH1cbiAqL1xuZnVuY3Rpb24gZWxsaXBzZXNEZWZhdWx0KF8sIG5vZGUsIGluZGV4LCBwYXJlbnQpIHtcbiAgZWxsaXBzZXNTcGFjZWQoXywgbm9kZSwgaW5kZXgsIHBhcmVudClcbiAgZWxsaXBzZXNVbnNwYWNlZChfLCBub2RlLCBpbmRleCwgcGFyZW50KVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBtdWx0aXBsZSBkb3RzIHdpdGggc3BhY2VzIGludG8gdW5pY29kZSBlbGxpcHNlcy5cbiAqXG4gKiBAdHlwZSB7TWV0aG9kfVxuICovXG5mdW5jdGlvbiBlbGxpcHNlc1NwYWNlZChfLCBub2RlLCBpbmRleCwgcGFyZW50KSB7XG4gIGNvbnN0IHZhbHVlID0gbm9kZS52YWx1ZVxuICBjb25zdCBzaWJsaW5ncyA9IHBhcmVudC5jaGlsZHJlblxuXG4gIGlmICghL15cXC4rJC8udGVzdCh2YWx1ZSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIFNlYXJjaCBmb3IgZG90LW5vZGVzIHdpdGggd2hpdGVzcGFjZSBiZXR3ZWVuLlxuICAvKiogQHR5cGUge0FycmF5PFNlbnRlbmNlQ29udGVudD59ICovXG4gIGNvbnN0IG5vZGVzID0gW11cbiAgbGV0IHBvc2l0aW9uID0gaW5kZXhcbiAgbGV0IGNvdW50ID0gMVxuXG4gIC8vIEl04oCZcyBwb3NzaWJsZSB0aGF0IHRoZSBub2RlIGlzIG1lcmdlZCB3aXRoIGFuIGFkamFjZW50IHdvcmQtbm9kZS4gIEluIHRoYXRcbiAgLy8gY29kZSwgd2UgY2Fubm90IHRyYW5zZm9ybSBpdCBiZWNhdXNlIHRoZXJl4oCZcyBubyByZWZlcmVuY2UgdG8gdGhlXG4gIC8vIGdyYW5kcGFyZW50LlxuICB3aGlsZSAoLS1wb3NpdGlvbiA+IDApIHtcbiAgICBsZXQgc2libGluZyA9IHNpYmxpbmdzW3Bvc2l0aW9uXVxuXG4gICAgaWYgKHNpYmxpbmcudHlwZSAhPT0gJ1doaXRlU3BhY2VOb2RlJykge1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBjb25zdCBxdWV1ZSA9IHNpYmxpbmdcbiAgICBzaWJsaW5nID0gc2libGluZ3NbLS1wb3NpdGlvbl1cblxuICAgIGlmIChcbiAgICAgIHNpYmxpbmcgJiZcbiAgICAgIChzaWJsaW5nLnR5cGUgPT09ICdQdW5jdHVhdGlvbk5vZGUnIHx8IHNpYmxpbmcudHlwZSA9PT0gJ1N5bWJvbE5vZGUnKSAmJlxuICAgICAgL15cXC4rJC8udGVzdChzaWJsaW5nLnZhbHVlKVxuICAgICkge1xuICAgICAgbm9kZXMucHVzaChxdWV1ZSwgc2libGluZylcblxuICAgICAgY291bnQrK1xuXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGJyZWFrXG4gIH1cblxuICBpZiAoY291bnQgPCAzKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBzaWJsaW5ncy5zcGxpY2UoaW5kZXggLSBub2Rlcy5sZW5ndGgsIG5vZGVzLmxlbmd0aClcblxuICBub2RlLnZhbHVlID0gJ+KApidcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gbXVsdGlwbGUgZG90cyB3aXRob3V0IHNwYWNlcyBpbnRvIHVuaWNvZGUgZWxsaXBzZXMuXG4gKlxuICogQHR5cGUge01ldGhvZH1cbiAqL1xuZnVuY3Rpb24gZWxsaXBzZXNVbnNwYWNlZChfLCBub2RlKSB7XG4gIC8vIFNpbXBsZSBub2RlIHdpdGggdGhyZWUgZG90cyBhbmQgd2l0aG91dCB3aGl0ZXNwYWNlLlxuICBpZiAoL15cXC57Myx9JC8udGVzdChub2RlLnZhbHVlKSkge1xuICAgIG5vZGUudmFsdWUgPSAn4oCmJ1xuICB9XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHN0cmFpZ2h0IHNpbmdsZS0gYW5kIGRvdWJsZSBxdW90ZXMgaW50byBzbWFydCBxdW90ZXMuXG4gKlxuICogQHR5cGUge01ldGhvZH1cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHF1b3Rlc0RlZmF1bHQoc3RhdGUsIG5vZGUsIGluZGV4LCBwYXJlbnQpIHtcbiAgY29uc3Qgc2libGluZ3MgPSBwYXJlbnQuY2hpbGRyZW5cbiAgY29uc3QgdmFsdWUgPSBub2RlLnZhbHVlXG5cbiAgaWYgKHZhbHVlICE9PSAnXCInICYmIHZhbHVlICE9PSBcIidcIikge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgcXVvdGVJbmRleCA9IHZhbHVlID09PSAnXCInID8gMCA6IDFcbiAgY29uc3QgcHJldmlvdXMgPSBzaWJsaW5nc1tpbmRleCAtIDFdXG4gIGNvbnN0IG5leHQgPSBzaWJsaW5nc1tpbmRleCArIDFdXG4gIGNvbnN0IG5leHROZXh0ID0gc2libGluZ3NbaW5kZXggKyAyXVxuICBjb25zdCBuZXh0VmFsdWUgPSBuZXh0ID8gdG9TdHJpbmcobmV4dCkgOiAnJ1xuXG4gIGlmIChcbiAgICBuZXh0ICYmXG4gICAgKG5leHQudHlwZSA9PT0gJ1B1bmN0dWF0aW9uTm9kZScgfHwgbmV4dC50eXBlID09PSAnU3ltYm9sTm9kZScpICYmXG4gICAgKCFuZXh0TmV4dCB8fCBuZXh0TmV4dC50eXBlICE9PSAnV29yZE5vZGUnKVxuICApIHtcbiAgICAvLyBTcGVjaWFsIGNhc2UgaWYgdGhlIHZlcnkgZmlyc3QgY2hhcmFjdGVyIGlzIGEgcXVvdGUgZm9sbG93ZWQgYnlcbiAgICAvLyBwdW5jdHVhdGlvbiBhdCBhIG5vbi13b3JkLWJyZWFrLiBDbG9zZSB0aGUgcXVvdGVzIGJ5IGJydXRlIGZvcmNlLlxuICAgIG5vZGUudmFsdWUgPSBzdGF0ZS5jbG9zZVtxdW90ZUluZGV4XVxuICB9IGVsc2UgaWYgKFxuICAgIG5leHQgJiZcbiAgICAobmV4dC50eXBlID09PSAnUHVuY3R1YXRpb25Ob2RlJyB8fCBuZXh0LnR5cGUgPT09ICdTeW1ib2xOb2RlJykgJiZcbiAgICAobmV4dFZhbHVlID09PSAnXCInIHx8IG5leHRWYWx1ZSA9PT0gXCInXCIpICYmXG4gICAgbmV4dE5leHQgJiZcbiAgICBuZXh0TmV4dC50eXBlID09PSAnV29yZE5vZGUnXG4gICkge1xuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgZG91YmxlIHNldHMgb2YgcXVvdGVzOlxuICAgIC8vIGBIZSBzYWlkLCBcIidRdW90ZWQnIHdvcmRzIGluIGEgbGFyZ2VyIHF1b3RlLlwiYFxuICAgIG5vZGUudmFsdWUgPSBzdGF0ZS5vcGVuW3F1b3RlSW5kZXhdXG4gICAgbmV4dC52YWx1ZSA9IHN0YXRlLm9wZW5bbmV4dFZhbHVlID09PSAnXCInID8gMCA6IDFdXG4gIH0gZWxzZSBpZiAobmV4dCAmJiAvXlxcZFxcZHMkLy50ZXN0KG5leHRWYWx1ZSkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGRlY2FkZSBhYmJyZXZpYXRpb25zOiBgdGhlICc4MHNgXG4gICAgbm9kZS52YWx1ZSA9IHN0YXRlLmNsb3NlW3F1b3RlSW5kZXhdXG4gIH0gZWxzZSBpZiAoXG4gICAgcHJldmlvdXMgJiZcbiAgICAocHJldmlvdXMudHlwZSA9PT0gJ1doaXRlU3BhY2VOb2RlJyB8fFxuICAgICAgcHJldmlvdXMudHlwZSA9PT0gJ1B1bmN0dWF0aW9uTm9kZScgfHxcbiAgICAgIHByZXZpb3VzLnR5cGUgPT09ICdTeW1ib2xOb2RlJykgJiZcbiAgICBuZXh0ICYmXG4gICAgbmV4dC50eXBlID09PSAnV29yZE5vZGUnXG4gICkge1xuICAgIC8vIEdldCBtb3N0IG9wZW5pbmcgc2luZ2xlIHF1b3Rlcy5cbiAgICBub2RlLnZhbHVlID0gc3RhdGUub3BlbltxdW90ZUluZGV4XVxuICB9IGVsc2UgaWYgKFxuICAgIHByZXZpb3VzICYmXG4gICAgcHJldmlvdXMudHlwZSAhPT0gJ1doaXRlU3BhY2VOb2RlJyAmJlxuICAgIHByZXZpb3VzLnR5cGUgIT09ICdTeW1ib2xOb2RlJyAmJlxuICAgIHByZXZpb3VzLnR5cGUgIT09ICdQdW5jdHVhdGlvbk5vZGUnXG4gICkge1xuICAgIC8vIENsb3NpbmcgcXVvdGVzLlxuICAgIG5vZGUudmFsdWUgPSBzdGF0ZS5jbG9zZVtxdW90ZUluZGV4XVxuICB9IGVsc2UgaWYgKFxuICAgICFuZXh0IHx8XG4gICAgbmV4dC50eXBlID09PSAnV2hpdGVTcGFjZU5vZGUnIHx8XG4gICAgKHZhbHVlID09PSBcIidcIiAmJiBuZXh0VmFsdWUgPT09ICdzJylcbiAgKSB7XG4gICAgbm9kZS52YWx1ZSA9IHN0YXRlLmNsb3NlW3F1b3RlSW5kZXhdXG4gIH0gZWxzZSB7XG4gICAgbm9kZS52YWx1ZSA9IHN0YXRlLm9wZW5bcXVvdGVJbmRleF1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/retext-smartypants@6.2.0/node_modules/retext-smartypants/lib/index.js\n");

/***/ })

};
;