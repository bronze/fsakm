"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/micromark-util-events-to-acorn@2.0.3";
exports.ids = ["vendor-chunks/micromark-util-events-to-acorn@2.0.3"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/micromark-util-events-to-acorn@2.0.3/node_modules/micromark-util-events-to-acorn/dev/lib/index.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/micromark-util-events-to-acorn@2.0.3/node_modules/micromark-util-events-to-acorn/dev/lib/index.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   eventsToAcorn: () => (/* binding */ eventsToAcorn)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! devlop */ \"(rsc)/./node_modules/.pnpm/devlop@1.1.0/node_modules/devlop/lib/development.js\");\n/* harmony import */ var estree_util_visit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! estree-util-visit */ \"(rsc)/./node_modules/.pnpm/estree-util-visit@2.0.0/node_modules/estree-util-visit/lib/index.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! micromark-util-symbol */ \"(rsc)/./node_modules/.pnpm/micromark-util-symbol@2.0.1/node_modules/micromark-util-symbol/lib/types.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! micromark-util-symbol */ \"(rsc)/./node_modules/.pnpm/micromark-util-symbol@2.0.1/node_modules/micromark-util-symbol/lib/codes.js\");\n/* harmony import */ var micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! micromark-util-symbol */ \"(rsc)/./node_modules/.pnpm/micromark-util-symbol@2.0.1/node_modules/micromark-util-symbol/lib/values.js\");\n/* harmony import */ var vfile_message__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vfile-message */ \"(rsc)/./node_modules/.pnpm/vfile-message@4.0.2/node_modules/vfile-message/lib/index.js\");\n/**\n * @import {Comment, Node as AcornNode, Token} from 'acorn'\n * @import {Node as EstreeNode, Program} from 'estree'\n * @import {Chunk, Event, Point as MicromarkPoint, TokenType} from 'micromark-util-types'\n * @import {Point as UnistPoint} from 'unist'\n *\n * @import {AcornOptions, Options} from 'micromark-util-events-to-acorn'\n * @import {AcornError, Collection, Result, Stop} from './types.js'\n */\n\n\n\n\n\n\n/**\n * Parse a list of micromark events with acorn.\n *\n * @param {Array<Event>} events\n *   Events.\n * @param {Options} options\n *   Configuration (required).\n * @returns {Result}\n *   Result.\n */\n// eslint-disable-next-line complexity\nfunction eventsToAcorn(events, options) {\n  const prefix = options.prefix || ''\n  const suffix = options.suffix || ''\n  const acornOptions = Object.assign({}, options.acornOptions)\n  /** @type {Array<Comment>} */\n  const comments = []\n  /** @type {Array<Token>} */\n  const tokens = []\n  const onComment = acornOptions.onComment\n  const onToken = acornOptions.onToken\n  let swallow = false\n  /** @type {AcornNode | undefined} */\n  let estree\n  /** @type {AcornError | undefined} */\n  let exception\n  /** @type {AcornOptions} */\n  const acornConfig = Object.assign({}, acornOptions, {\n    onComment: comments,\n    preserveParens: true\n  })\n\n  if (onToken) {\n    acornConfig.onToken = tokens\n  }\n\n  const collection = collect(events, options.tokenTypes)\n\n  const source = collection.value\n\n  const value = prefix + source + suffix\n  const isEmptyExpression = options.expression && empty(source)\n\n  if (isEmptyExpression && !options.allowEmpty) {\n    throw new vfile_message__WEBPACK_IMPORTED_MODULE_0__.VFileMessage('Unexpected empty expression', {\n      place: parseOffsetToUnistPoint(0),\n      ruleId: 'unexpected-empty-expression',\n      source: 'micromark-extension-mdx-expression'\n    })\n  }\n\n  try {\n    estree =\n      options.expression && !isEmptyExpression\n        ? options.acorn.parseExpressionAt(value, 0, acornConfig)\n        : options.acorn.parse(value, acornConfig)\n  } catch (error_) {\n    const error = /** @type {AcornError} */ (error_)\n    const point = parseOffsetToUnistPoint(error.pos)\n    error.message = String(error.message).replace(/ \\(\\d+:\\d+\\)$/, '')\n    // Always defined in our unist points that come from micromark.\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(point.offset !== undefined, 'expected `offset`')\n    error.pos = point.offset\n    error.loc = {line: point.line, column: point.column - 1}\n    exception = error\n    swallow =\n      error.raisedAt >= prefix.length + source.length ||\n      // Broken comments are raised at their start, not their end.\n      error.message === 'Unterminated comment'\n  }\n\n  if (estree && options.expression && !isEmptyExpression) {\n    if (empty(value.slice(estree.end, value.length - suffix.length))) {\n      estree = {\n        type: 'Program',\n        start: 0,\n        end: prefix.length + source.length,\n        // @ts-expect-error: It’s good.\n        body: [\n          {\n            type: 'ExpressionStatement',\n            expression: estree,\n            start: 0,\n            end: prefix.length + source.length\n          }\n        ],\n        sourceType: 'module',\n        comments: []\n      }\n    } else {\n      const point = parseOffsetToUnistPoint(estree.end)\n      const error = /** @type {AcornError} */ (\n        new Error('Unexpected content after expression')\n      )\n      // Always defined in our unist points that come from micromark.\n      ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(point.offset !== undefined, 'expected `offset`')\n      error.pos = point.offset\n      error.loc = {line: point.line, column: point.column - 1}\n      exception = error\n      estree = undefined\n    }\n  }\n\n  if (estree) {\n    // @ts-expect-error: acorn *does* allow comments\n    estree.comments = comments\n\n    // @ts-expect-error: acorn looks enough like estree.\n    ;(0,estree_util_visit__WEBPACK_IMPORTED_MODULE_2__.visit)(estree, function (esnode, field, index, parents) {\n      let context = /** @type {AcornNode | Array<AcornNode>} */ (\n        parents[parents.length - 1]\n      )\n      /** @type {number | string | undefined} */\n      let property = field\n\n      // Remove non-standard `ParenthesizedExpression`.\n      // @ts-expect-error: included in acorn.\n      if (esnode.type === 'ParenthesizedExpression' && context && property) {\n        /* c8 ignore next 5 */\n        if (typeof index === 'number') {\n          // @ts-expect-error: indexable.\n          context = context[property]\n          property = index\n        }\n\n        // @ts-expect-error: indexable.\n        context[property] = esnode.expression\n      }\n\n      fixPosition(esnode)\n    })\n\n    // Comment positions are fixed by `visit` because they’re in the tree.\n    if (Array.isArray(onComment)) {\n      onComment.push(...comments)\n    } else if (typeof onComment === 'function') {\n      for (const comment of comments) {\n        (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(comment.loc, 'expected `loc` on comment')\n        onComment(\n          comment.type === 'Block',\n          comment.value,\n          comment.start,\n          comment.end,\n          comment.loc.start,\n          comment.loc.end\n        )\n      }\n    }\n\n    for (const token of tokens) {\n      // Ignore tokens that ends in prefix or start in suffix:\n      if (\n        token.end <= prefix.length ||\n        token.start - prefix.length >= source.length\n      ) {\n        continue\n      }\n\n      fixPosition(token)\n\n      if (Array.isArray(onToken)) {\n        onToken.push(token)\n      } else {\n        // `tokens` are not added if `onToken` is not defined, so it must be a\n        // function.\n        (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(typeof onToken === 'function', 'expected function')\n        onToken(token)\n      }\n    }\n  }\n\n  // @ts-expect-error: It’s a program now.\n  return {estree, error: exception, swallow}\n\n  /**\n   * Update the position of a node.\n   *\n   * @param {AcornNode | EstreeNode | Token} nodeOrToken\n   * @returns {undefined}\n   */\n  function fixPosition(nodeOrToken) {\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n      'start' in nodeOrToken,\n      'expected `start` in node or token from acorn'\n    )\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)('end' in nodeOrToken, 'expected `end` in node or token from acorn')\n    const pointStart = parseOffsetToUnistPoint(nodeOrToken.start)\n    const pointEnd = parseOffsetToUnistPoint(nodeOrToken.end)\n    // Always defined in our unist points that come from micromark.\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(pointStart.offset !== undefined, 'expected `offset`')\n    ;(0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(pointEnd.offset !== undefined, 'expected `offset`')\n    nodeOrToken.start = pointStart.offset\n    nodeOrToken.end = pointEnd.offset\n    nodeOrToken.loc = {\n      start: {\n        line: pointStart.line,\n        column: pointStart.column - 1,\n        // @ts-expect-error: not allowed by acorn types.\n        offset: pointStart.offset\n      },\n      end: {\n        line: pointEnd.line,\n        column: pointEnd.column - 1,\n        // @ts-expect-error: not allowed by acorn types.\n        offset: pointEnd.offset\n      }\n    }\n    nodeOrToken.range = [nodeOrToken.start, nodeOrToken.end]\n  }\n\n  /**\n   * Turn an arbitrary offset into the parsed value, into a point in the source\n   * value.\n   *\n   * @param {number} acornOffset\n   * @returns {UnistPoint}\n   */\n  function parseOffsetToUnistPoint(acornOffset) {\n    let sourceOffset = acornOffset - prefix.length\n\n    if (sourceOffset < 0) {\n      sourceOffset = 0\n    } else if (sourceOffset > source.length) {\n      sourceOffset = source.length\n    }\n\n    let point = relativeToPoint(collection.stops, sourceOffset)\n\n    if (!point) {\n      (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(\n        options.start,\n        'empty expressions are need `options.start` being passed'\n      )\n      point = {\n        line: options.start.line,\n        column: options.start.column,\n        offset: options.start.offset\n      }\n    }\n\n    return point\n  }\n}\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nfunction empty(value) {\n  return /^\\s*$/.test(\n    value\n      // Multiline comments.\n      .replace(/\\/\\*[\\s\\S]*?\\*\\//g, '')\n      // Line comments.\n      // EOF instead of EOL is specifically not allowed, because that would\n      // mean the closing brace is on the commented-out line\n      .replace(/\\/\\/[^\\r\\n]*(\\r\\n|\\n|\\r)/g, '')\n  )\n}\n\n// Port from <https://github.com/wooorm/markdown-rs/blob/e692ab0/src/util/mdx_collect.rs#L15>.\n/**\n * @param {Array<Event>} events\n * @param {Array<TokenType>} tokenTypes\n * @returns {Collection}\n */\nfunction collect(events, tokenTypes) {\n  /** @type {Collection} */\n  const result = {value: '', stops: []}\n  let index = -1\n\n  while (++index < events.length) {\n    const event = events[index]\n\n    // Assume void.\n    if (event[0] === 'enter') {\n      const type = event[1].type\n\n      if (type === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_3__.types.lineEnding || tokenTypes.includes(type)) {\n        const chunks = event[2].sliceStream(event[1])\n\n        // Drop virtual spaces.\n        while (chunks.length > 0 && chunks[0] === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.virtualSpace) {\n          chunks.shift()\n        }\n\n        const value = serializeChunks(chunks)\n        result.stops.push([result.value.length, event[1].start])\n        result.value += value\n        result.stops.push([result.value.length, event[1].end])\n      }\n    }\n  }\n\n  return result\n}\n\n// Port from <https://github.com/wooorm/markdown-rs/blob/e692ab0/src/util/location.rs#L91>.\n/**\n * Turn a relative offset into an absolute offset.\n *\n * @param {Array<Stop>} stops\n * @param {number} relative\n * @returns {UnistPoint | undefined}\n */\nfunction relativeToPoint(stops, relative) {\n  let index = 0\n\n  while (index < stops.length && stops[index][0] <= relative) {\n    index += 1\n  }\n\n  // There are no points: that only occurs if there was an empty string.\n  if (index === 0) {\n    return undefined\n  }\n\n  const [stopRelative, stopAbsolute] = stops[index - 1]\n  const rest = relative - stopRelative\n  return {\n    line: stopAbsolute.line,\n    column: stopAbsolute.column + rest,\n    offset: stopAbsolute.offset + rest\n  }\n}\n\n// Copy from <https://github.com/micromark/micromark/blob/ce3593a/packages/micromark/dev/lib/create-tokenizer.js#L595>\n// To do: expose that?\n/**\n * Get the string value of a slice of chunks.\n *\n * @param {Array<Chunk>} chunks\n * @returns {string}\n */\nfunction serializeChunks(chunks) {\n  let index = -1\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {boolean | undefined} */\n  let atTab\n\n  while (++index < chunks.length) {\n    const chunk = chunks[index]\n    /** @type {string} */\n    let value\n\n    if (typeof chunk === 'string') {\n      value = chunk\n    } else\n      switch (chunk) {\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.carriageReturn: {\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.cr\n\n          break\n        }\n\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.lineFeed: {\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.lf\n\n          break\n        }\n\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.carriageReturnLineFeed: {\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.cr + micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.lf\n\n          break\n        }\n\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.horizontalTab: {\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.ht\n\n          break\n        }\n\n        /* c8 ignore next 6 */\n        case micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.virtualSpace: {\n          if (atTab) continue\n          value = micromark_util_symbol__WEBPACK_IMPORTED_MODULE_5__.values.space\n\n          break\n        }\n\n        default: {\n          (0,devlop__WEBPACK_IMPORTED_MODULE_1__.ok)(typeof chunk === 'number', 'expected number')\n          // Currently only replacement character.\n          // eslint-disable-next-line unicorn/prefer-code-point\n          value = String.fromCharCode(chunk)\n        }\n      }\n\n    atTab = chunk === micromark_util_symbol__WEBPACK_IMPORTED_MODULE_4__.codes.horizontalTab\n    result.push(value)\n  }\n\n  return result.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vbWljcm9tYXJrLXV0aWwtZXZlbnRzLXRvLWFjb3JuQDIuMC4zL25vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1ldmVudHMtdG8tYWNvcm4vZGV2L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQSxZQUFZLG1DQUFtQztBQUMvQyxZQUFZLDZCQUE2QjtBQUN6QyxZQUFZLGtEQUFrRDtBQUM5RCxZQUFZLHFCQUFxQjtBQUNqQztBQUNBLFlBQVksdUJBQXVCO0FBQ25DLFlBQVksc0NBQXNDO0FBQ2xEOztBQUVtQztBQUNJO0FBQ21CO0FBQ2hCOztBQUUxQztBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQztBQUNBLGFBQWEsY0FBYztBQUMzQixzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHVEQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDZCQUE2QixZQUFZO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLElBQUksMkNBQU07QUFDVjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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bEI7QUFDQSxrQkFBa0IseURBQU07O0FBRXhCO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLDBDQUFNO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHdEQUFLO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvYnJvbnplL2NvZGluZy9mc2FrbS9ub2RlX21vZHVsZXMvLnBucG0vbWljcm9tYXJrLXV0aWwtZXZlbnRzLXRvLWFjb3JuQDIuMC4zL25vZGVfbW9kdWxlcy9taWNyb21hcmstdXRpbC1ldmVudHMtdG8tYWNvcm4vZGV2L2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge0NvbW1lbnQsIE5vZGUgYXMgQWNvcm5Ob2RlLCBUb2tlbn0gZnJvbSAnYWNvcm4nXG4gKiBAaW1wb3J0IHtOb2RlIGFzIEVzdHJlZU5vZGUsIFByb2dyYW19IGZyb20gJ2VzdHJlZSdcbiAqIEBpbXBvcnQge0NodW5rLCBFdmVudCwgUG9pbnQgYXMgTWljcm9tYXJrUG9pbnQsIFRva2VuVHlwZX0gZnJvbSAnbWljcm9tYXJrLXV0aWwtdHlwZXMnXG4gKiBAaW1wb3J0IHtQb2ludCBhcyBVbmlzdFBvaW50fSBmcm9tICd1bmlzdCdcbiAqXG4gKiBAaW1wb3J0IHtBY29ybk9wdGlvbnMsIE9wdGlvbnN9IGZyb20gJ21pY3JvbWFyay11dGlsLWV2ZW50cy10by1hY29ybidcbiAqIEBpbXBvcnQge0Fjb3JuRXJyb3IsIENvbGxlY3Rpb24sIFJlc3VsdCwgU3RvcH0gZnJvbSAnLi90eXBlcy5qcydcbiAqL1xuXG5pbXBvcnQge29rIGFzIGFzc2VydH0gZnJvbSAnZGV2bG9wJ1xuaW1wb3J0IHt2aXNpdH0gZnJvbSAnZXN0cmVlLXV0aWwtdmlzaXQnXG5pbXBvcnQge2NvZGVzLCB0eXBlcywgdmFsdWVzfSBmcm9tICdtaWNyb21hcmstdXRpbC1zeW1ib2wnXG5pbXBvcnQge1ZGaWxlTWVzc2FnZX0gZnJvbSAndmZpbGUtbWVzc2FnZSdcblxuLyoqXG4gKiBQYXJzZSBhIGxpc3Qgb2YgbWljcm9tYXJrIGV2ZW50cyB3aXRoIGFjb3JuLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8RXZlbnQ+fSBldmVudHNcbiAqICAgRXZlbnRzLlxuICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24gKHJlcXVpcmVkKS5cbiAqIEByZXR1cm5zIHtSZXN1bHR9XG4gKiAgIFJlc3VsdC5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBmdW5jdGlvbiBldmVudHNUb0Fjb3JuKGV2ZW50cywgb3B0aW9ucykge1xuICBjb25zdCBwcmVmaXggPSBvcHRpb25zLnByZWZpeCB8fCAnJ1xuICBjb25zdCBzdWZmaXggPSBvcHRpb25zLnN1ZmZpeCB8fCAnJ1xuICBjb25zdCBhY29ybk9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmFjb3JuT3B0aW9ucylcbiAgLyoqIEB0eXBlIHtBcnJheTxDb21tZW50Pn0gKi9cbiAgY29uc3QgY29tbWVudHMgPSBbXVxuICAvKiogQHR5cGUge0FycmF5PFRva2VuPn0gKi9cbiAgY29uc3QgdG9rZW5zID0gW11cbiAgY29uc3Qgb25Db21tZW50ID0gYWNvcm5PcHRpb25zLm9uQ29tbWVudFxuICBjb25zdCBvblRva2VuID0gYWNvcm5PcHRpb25zLm9uVG9rZW5cbiAgbGV0IHN3YWxsb3cgPSBmYWxzZVxuICAvKiogQHR5cGUge0Fjb3JuTm9kZSB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IGVzdHJlZVxuICAvKiogQHR5cGUge0Fjb3JuRXJyb3IgfCB1bmRlZmluZWR9ICovXG4gIGxldCBleGNlcHRpb25cbiAgLyoqIEB0eXBlIHtBY29ybk9wdGlvbnN9ICovXG4gIGNvbnN0IGFjb3JuQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgYWNvcm5PcHRpb25zLCB7XG4gICAgb25Db21tZW50OiBjb21tZW50cyxcbiAgICBwcmVzZXJ2ZVBhcmVuczogdHJ1ZVxuICB9KVxuXG4gIGlmIChvblRva2VuKSB7XG4gICAgYWNvcm5Db25maWcub25Ub2tlbiA9IHRva2Vuc1xuICB9XG5cbiAgY29uc3QgY29sbGVjdGlvbiA9IGNvbGxlY3QoZXZlbnRzLCBvcHRpb25zLnRva2VuVHlwZXMpXG5cbiAgY29uc3Qgc291cmNlID0gY29sbGVjdGlvbi52YWx1ZVxuXG4gIGNvbnN0IHZhbHVlID0gcHJlZml4ICsgc291cmNlICsgc3VmZml4XG4gIGNvbnN0IGlzRW1wdHlFeHByZXNzaW9uID0gb3B0aW9ucy5leHByZXNzaW9uICYmIGVtcHR5KHNvdXJjZSlcblxuICBpZiAoaXNFbXB0eUV4cHJlc3Npb24gJiYgIW9wdGlvbnMuYWxsb3dFbXB0eSkge1xuICAgIHRocm93IG5ldyBWRmlsZU1lc3NhZ2UoJ1VuZXhwZWN0ZWQgZW1wdHkgZXhwcmVzc2lvbicsIHtcbiAgICAgIHBsYWNlOiBwYXJzZU9mZnNldFRvVW5pc3RQb2ludCgwKSxcbiAgICAgIHJ1bGVJZDogJ3VuZXhwZWN0ZWQtZW1wdHktZXhwcmVzc2lvbicsXG4gICAgICBzb3VyY2U6ICdtaWNyb21hcmstZXh0ZW5zaW9uLW1keC1leHByZXNzaW9uJ1xuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIGVzdHJlZSA9XG4gICAgICBvcHRpb25zLmV4cHJlc3Npb24gJiYgIWlzRW1wdHlFeHByZXNzaW9uXG4gICAgICAgID8gb3B0aW9ucy5hY29ybi5wYXJzZUV4cHJlc3Npb25BdCh2YWx1ZSwgMCwgYWNvcm5Db25maWcpXG4gICAgICAgIDogb3B0aW9ucy5hY29ybi5wYXJzZSh2YWx1ZSwgYWNvcm5Db25maWcpXG4gIH0gY2F0Y2ggKGVycm9yXykge1xuICAgIGNvbnN0IGVycm9yID0gLyoqIEB0eXBlIHtBY29ybkVycm9yfSAqLyAoZXJyb3JfKVxuICAgIGNvbnN0IHBvaW50ID0gcGFyc2VPZmZzZXRUb1VuaXN0UG9pbnQoZXJyb3IucG9zKVxuICAgIGVycm9yLm1lc3NhZ2UgPSBTdHJpbmcoZXJyb3IubWVzc2FnZSkucmVwbGFjZSgvIFxcKFxcZCs6XFxkK1xcKSQvLCAnJylcbiAgICAvLyBBbHdheXMgZGVmaW5lZCBpbiBvdXIgdW5pc3QgcG9pbnRzIHRoYXQgY29tZSBmcm9tIG1pY3JvbWFyay5cbiAgICBhc3NlcnQocG9pbnQub2Zmc2V0ICE9PSB1bmRlZmluZWQsICdleHBlY3RlZCBgb2Zmc2V0YCcpXG4gICAgZXJyb3IucG9zID0gcG9pbnQub2Zmc2V0XG4gICAgZXJyb3IubG9jID0ge2xpbmU6IHBvaW50LmxpbmUsIGNvbHVtbjogcG9pbnQuY29sdW1uIC0gMX1cbiAgICBleGNlcHRpb24gPSBlcnJvclxuICAgIHN3YWxsb3cgPVxuICAgICAgZXJyb3IucmFpc2VkQXQgPj0gcHJlZml4Lmxlbmd0aCArIHNvdXJjZS5sZW5ndGggfHxcbiAgICAgIC8vIEJyb2tlbiBjb21tZW50cyBhcmUgcmFpc2VkIGF0IHRoZWlyIHN0YXJ0LCBub3QgdGhlaXIgZW5kLlxuICAgICAgZXJyb3IubWVzc2FnZSA9PT0gJ1VudGVybWluYXRlZCBjb21tZW50J1xuICB9XG5cbiAgaWYgKGVzdHJlZSAmJiBvcHRpb25zLmV4cHJlc3Npb24gJiYgIWlzRW1wdHlFeHByZXNzaW9uKSB7XG4gICAgaWYgKGVtcHR5KHZhbHVlLnNsaWNlKGVzdHJlZS5lbmQsIHZhbHVlLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpKSkge1xuICAgICAgZXN0cmVlID0ge1xuICAgICAgICB0eXBlOiAnUHJvZ3JhbScsXG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBlbmQ6IHByZWZpeC5sZW5ndGggKyBzb3VyY2UubGVuZ3RoLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBJdOKAmXMgZ29vZC5cbiAgICAgICAgYm9keTogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGVzdHJlZSxcbiAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgZW5kOiBwcmVmaXgubGVuZ3RoICsgc291cmNlLmxlbmd0aFxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc291cmNlVHlwZTogJ21vZHVsZScsXG4gICAgICAgIGNvbW1lbnRzOiBbXVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBhcnNlT2Zmc2V0VG9VbmlzdFBvaW50KGVzdHJlZS5lbmQpXG4gICAgICBjb25zdCBlcnJvciA9IC8qKiBAdHlwZSB7QWNvcm5FcnJvcn0gKi8gKFxuICAgICAgICBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgY29udGVudCBhZnRlciBleHByZXNzaW9uJylcbiAgICAgIClcbiAgICAgIC8vIEFsd2F5cyBkZWZpbmVkIGluIG91ciB1bmlzdCBwb2ludHMgdGhhdCBjb21lIGZyb20gbWljcm9tYXJrLlxuICAgICAgYXNzZXJ0KHBvaW50Lm9mZnNldCAhPT0gdW5kZWZpbmVkLCAnZXhwZWN0ZWQgYG9mZnNldGAnKVxuICAgICAgZXJyb3IucG9zID0gcG9pbnQub2Zmc2V0XG4gICAgICBlcnJvci5sb2MgPSB7bGluZTogcG9pbnQubGluZSwgY29sdW1uOiBwb2ludC5jb2x1bW4gLSAxfVxuICAgICAgZXhjZXB0aW9uID0gZXJyb3JcbiAgICAgIGVzdHJlZSA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIGlmIChlc3RyZWUpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBhY29ybiAqZG9lcyogYWxsb3cgY29tbWVudHNcbiAgICBlc3RyZWUuY29tbWVudHMgPSBjb21tZW50c1xuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYWNvcm4gbG9va3MgZW5vdWdoIGxpa2UgZXN0cmVlLlxuICAgIHZpc2l0KGVzdHJlZSwgZnVuY3Rpb24gKGVzbm9kZSwgZmllbGQsIGluZGV4LCBwYXJlbnRzKSB7XG4gICAgICBsZXQgY29udGV4dCA9IC8qKiBAdHlwZSB7QWNvcm5Ob2RlIHwgQXJyYXk8QWNvcm5Ob2RlPn0gKi8gKFxuICAgICAgICBwYXJlbnRzW3BhcmVudHMubGVuZ3RoIC0gMV1cbiAgICAgIClcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyIHwgc3RyaW5nIHwgdW5kZWZpbmVkfSAqL1xuICAgICAgbGV0IHByb3BlcnR5ID0gZmllbGRcblxuICAgICAgLy8gUmVtb3ZlIG5vbi1zdGFuZGFyZCBgUGFyZW50aGVzaXplZEV4cHJlc3Npb25gLlxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW5jbHVkZWQgaW4gYWNvcm4uXG4gICAgICBpZiAoZXNub2RlLnR5cGUgPT09ICdQYXJlbnRoZXNpemVkRXhwcmVzc2lvbicgJiYgY29udGV4dCAmJiBwcm9wZXJ0eSkge1xuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCA1ICovXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW5kZXhhYmxlLlxuICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0W3Byb3BlcnR5XVxuICAgICAgICAgIHByb3BlcnR5ID0gaW5kZXhcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGluZGV4YWJsZS5cbiAgICAgICAgY29udGV4dFtwcm9wZXJ0eV0gPSBlc25vZGUuZXhwcmVzc2lvblxuICAgICAgfVxuXG4gICAgICBmaXhQb3NpdGlvbihlc25vZGUpXG4gICAgfSlcblxuICAgIC8vIENvbW1lbnQgcG9zaXRpb25zIGFyZSBmaXhlZCBieSBgdmlzaXRgIGJlY2F1c2UgdGhleeKAmXJlIGluIHRoZSB0cmVlLlxuICAgIGlmIChBcnJheS5pc0FycmF5KG9uQ29tbWVudCkpIHtcbiAgICAgIG9uQ29tbWVudC5wdXNoKC4uLmNvbW1lbnRzKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9uQ29tbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZm9yIChjb25zdCBjb21tZW50IG9mIGNvbW1lbnRzKSB7XG4gICAgICAgIGFzc2VydChjb21tZW50LmxvYywgJ2V4cGVjdGVkIGBsb2NgIG9uIGNvbW1lbnQnKVxuICAgICAgICBvbkNvbW1lbnQoXG4gICAgICAgICAgY29tbWVudC50eXBlID09PSAnQmxvY2snLFxuICAgICAgICAgIGNvbW1lbnQudmFsdWUsXG4gICAgICAgICAgY29tbWVudC5zdGFydCxcbiAgICAgICAgICBjb21tZW50LmVuZCxcbiAgICAgICAgICBjb21tZW50LmxvYy5zdGFydCxcbiAgICAgICAgICBjb21tZW50LmxvYy5lbmRcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAvLyBJZ25vcmUgdG9rZW5zIHRoYXQgZW5kcyBpbiBwcmVmaXggb3Igc3RhcnQgaW4gc3VmZml4OlxuICAgICAgaWYgKFxuICAgICAgICB0b2tlbi5lbmQgPD0gcHJlZml4Lmxlbmd0aCB8fFxuICAgICAgICB0b2tlbi5zdGFydCAtIHByZWZpeC5sZW5ndGggPj0gc291cmNlLmxlbmd0aFxuICAgICAgKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGZpeFBvc2l0aW9uKHRva2VuKVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvblRva2VuKSkge1xuICAgICAgICBvblRva2VuLnB1c2godG9rZW4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBgdG9rZW5zYCBhcmUgbm90IGFkZGVkIGlmIGBvblRva2VuYCBpcyBub3QgZGVmaW5lZCwgc28gaXQgbXVzdCBiZSBhXG4gICAgICAgIC8vIGZ1bmN0aW9uLlxuICAgICAgICBhc3NlcnQodHlwZW9mIG9uVG9rZW4gPT09ICdmdW5jdGlvbicsICdleHBlY3RlZCBmdW5jdGlvbicpXG4gICAgICAgIG9uVG9rZW4odG9rZW4pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogSXTigJlzIGEgcHJvZ3JhbSBub3cuXG4gIHJldHVybiB7ZXN0cmVlLCBlcnJvcjogZXhjZXB0aW9uLCBzd2FsbG93fVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtBY29ybk5vZGUgfCBFc3RyZWVOb2RlIHwgVG9rZW59IG5vZGVPclRva2VuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBmdW5jdGlvbiBmaXhQb3NpdGlvbihub2RlT3JUb2tlbikge1xuICAgIGFzc2VydChcbiAgICAgICdzdGFydCcgaW4gbm9kZU9yVG9rZW4sXG4gICAgICAnZXhwZWN0ZWQgYHN0YXJ0YCBpbiBub2RlIG9yIHRva2VuIGZyb20gYWNvcm4nXG4gICAgKVxuICAgIGFzc2VydCgnZW5kJyBpbiBub2RlT3JUb2tlbiwgJ2V4cGVjdGVkIGBlbmRgIGluIG5vZGUgb3IgdG9rZW4gZnJvbSBhY29ybicpXG4gICAgY29uc3QgcG9pbnRTdGFydCA9IHBhcnNlT2Zmc2V0VG9VbmlzdFBvaW50KG5vZGVPclRva2VuLnN0YXJ0KVxuICAgIGNvbnN0IHBvaW50RW5kID0gcGFyc2VPZmZzZXRUb1VuaXN0UG9pbnQobm9kZU9yVG9rZW4uZW5kKVxuICAgIC8vIEFsd2F5cyBkZWZpbmVkIGluIG91ciB1bmlzdCBwb2ludHMgdGhhdCBjb21lIGZyb20gbWljcm9tYXJrLlxuICAgIGFzc2VydChwb2ludFN0YXJ0Lm9mZnNldCAhPT0gdW5kZWZpbmVkLCAnZXhwZWN0ZWQgYG9mZnNldGAnKVxuICAgIGFzc2VydChwb2ludEVuZC5vZmZzZXQgIT09IHVuZGVmaW5lZCwgJ2V4cGVjdGVkIGBvZmZzZXRgJylcbiAgICBub2RlT3JUb2tlbi5zdGFydCA9IHBvaW50U3RhcnQub2Zmc2V0XG4gICAgbm9kZU9yVG9rZW4uZW5kID0gcG9pbnRFbmQub2Zmc2V0XG4gICAgbm9kZU9yVG9rZW4ubG9jID0ge1xuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgbGluZTogcG9pbnRTdGFydC5saW5lLFxuICAgICAgICBjb2x1bW46IHBvaW50U3RhcnQuY29sdW1uIC0gMSxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbm90IGFsbG93ZWQgYnkgYWNvcm4gdHlwZXMuXG4gICAgICAgIG9mZnNldDogcG9pbnRTdGFydC5vZmZzZXRcbiAgICAgIH0sXG4gICAgICBlbmQ6IHtcbiAgICAgICAgbGluZTogcG9pbnRFbmQubGluZSxcbiAgICAgICAgY29sdW1uOiBwb2ludEVuZC5jb2x1bW4gLSAxLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBub3QgYWxsb3dlZCBieSBhY29ybiB0eXBlcy5cbiAgICAgICAgb2Zmc2V0OiBwb2ludEVuZC5vZmZzZXRcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZU9yVG9rZW4ucmFuZ2UgPSBbbm9kZU9yVG9rZW4uc3RhcnQsIG5vZGVPclRva2VuLmVuZF1cbiAgfVxuXG4gIC8qKlxuICAgKiBUdXJuIGFuIGFyYml0cmFyeSBvZmZzZXQgaW50byB0aGUgcGFyc2VkIHZhbHVlLCBpbnRvIGEgcG9pbnQgaW4gdGhlIHNvdXJjZVxuICAgKiB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFjb3JuT2Zmc2V0XG4gICAqIEByZXR1cm5zIHtVbmlzdFBvaW50fVxuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VPZmZzZXRUb1VuaXN0UG9pbnQoYWNvcm5PZmZzZXQpIHtcbiAgICBsZXQgc291cmNlT2Zmc2V0ID0gYWNvcm5PZmZzZXQgLSBwcmVmaXgubGVuZ3RoXG5cbiAgICBpZiAoc291cmNlT2Zmc2V0IDwgMCkge1xuICAgICAgc291cmNlT2Zmc2V0ID0gMFxuICAgIH0gZWxzZSBpZiAoc291cmNlT2Zmc2V0ID4gc291cmNlLmxlbmd0aCkge1xuICAgICAgc291cmNlT2Zmc2V0ID0gc291cmNlLmxlbmd0aFxuICAgIH1cblxuICAgIGxldCBwb2ludCA9IHJlbGF0aXZlVG9Qb2ludChjb2xsZWN0aW9uLnN0b3BzLCBzb3VyY2VPZmZzZXQpXG5cbiAgICBpZiAoIXBvaW50KSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIG9wdGlvbnMuc3RhcnQsXG4gICAgICAgICdlbXB0eSBleHByZXNzaW9ucyBhcmUgbmVlZCBgb3B0aW9ucy5zdGFydGAgYmVpbmcgcGFzc2VkJ1xuICAgICAgKVxuICAgICAgcG9pbnQgPSB7XG4gICAgICAgIGxpbmU6IG9wdGlvbnMuc3RhcnQubGluZSxcbiAgICAgICAgY29sdW1uOiBvcHRpb25zLnN0YXJ0LmNvbHVtbixcbiAgICAgICAgb2Zmc2V0OiBvcHRpb25zLnN0YXJ0Lm9mZnNldFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwb2ludFxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZW1wdHkodmFsdWUpIHtcbiAgcmV0dXJuIC9eXFxzKiQvLnRlc3QoXG4gICAgdmFsdWVcbiAgICAgIC8vIE11bHRpbGluZSBjb21tZW50cy5cbiAgICAgIC5yZXBsYWNlKC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvL2csICcnKVxuICAgICAgLy8gTGluZSBjb21tZW50cy5cbiAgICAgIC8vIEVPRiBpbnN0ZWFkIG9mIEVPTCBpcyBzcGVjaWZpY2FsbHkgbm90IGFsbG93ZWQsIGJlY2F1c2UgdGhhdCB3b3VsZFxuICAgICAgLy8gbWVhbiB0aGUgY2xvc2luZyBicmFjZSBpcyBvbiB0aGUgY29tbWVudGVkLW91dCBsaW5lXG4gICAgICAucmVwbGFjZSgvXFwvXFwvW15cXHJcXG5dKihcXHJcXG58XFxufFxccikvZywgJycpXG4gIClcbn1cblxuLy8gUG9ydCBmcm9tIDxodHRwczovL2dpdGh1Yi5jb20vd29vb3JtL21hcmtkb3duLXJzL2Jsb2IvZTY5MmFiMC9zcmMvdXRpbC9tZHhfY29sbGVjdC5ycyNMMTU+LlxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEV2ZW50Pn0gZXZlbnRzXG4gKiBAcGFyYW0ge0FycmF5PFRva2VuVHlwZT59IHRva2VuVHlwZXNcbiAqIEByZXR1cm5zIHtDb2xsZWN0aW9ufVxuICovXG5mdW5jdGlvbiBjb2xsZWN0KGV2ZW50cywgdG9rZW5UeXBlcykge1xuICAvKiogQHR5cGUge0NvbGxlY3Rpb259ICovXG4gIGNvbnN0IHJlc3VsdCA9IHt2YWx1ZTogJycsIHN0b3BzOiBbXX1cbiAgbGV0IGluZGV4ID0gLTFcblxuICB3aGlsZSAoKytpbmRleCA8IGV2ZW50cy5sZW5ndGgpIHtcbiAgICBjb25zdCBldmVudCA9IGV2ZW50c1tpbmRleF1cblxuICAgIC8vIEFzc3VtZSB2b2lkLlxuICAgIGlmIChldmVudFswXSA9PT0gJ2VudGVyJykge1xuICAgICAgY29uc3QgdHlwZSA9IGV2ZW50WzFdLnR5cGVcblxuICAgICAgaWYgKHR5cGUgPT09IHR5cGVzLmxpbmVFbmRpbmcgfHwgdG9rZW5UeXBlcy5pbmNsdWRlcyh0eXBlKSkge1xuICAgICAgICBjb25zdCBjaHVua3MgPSBldmVudFsyXS5zbGljZVN0cmVhbShldmVudFsxXSlcblxuICAgICAgICAvLyBEcm9wIHZpcnR1YWwgc3BhY2VzLlxuICAgICAgICB3aGlsZSAoY2h1bmtzLmxlbmd0aCA+IDAgJiYgY2h1bmtzWzBdID09PSBjb2Rlcy52aXJ0dWFsU3BhY2UpIHtcbiAgICAgICAgICBjaHVua3Muc2hpZnQoKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSBzZXJpYWxpemVDaHVua3MoY2h1bmtzKVxuICAgICAgICByZXN1bHQuc3RvcHMucHVzaChbcmVzdWx0LnZhbHVlLmxlbmd0aCwgZXZlbnRbMV0uc3RhcnRdKVxuICAgICAgICByZXN1bHQudmFsdWUgKz0gdmFsdWVcbiAgICAgICAgcmVzdWx0LnN0b3BzLnB1c2goW3Jlc3VsdC52YWx1ZS5sZW5ndGgsIGV2ZW50WzFdLmVuZF0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vLyBQb3J0IGZyb20gPGh0dHBzOi8vZ2l0aHViLmNvbS93b29vcm0vbWFya2Rvd24tcnMvYmxvYi9lNjkyYWIwL3NyYy91dGlsL2xvY2F0aW9uLnJzI0w5MT4uXG4vKipcbiAqIFR1cm4gYSByZWxhdGl2ZSBvZmZzZXQgaW50byBhbiBhYnNvbHV0ZSBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxTdG9wPn0gc3RvcHNcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWxhdGl2ZVxuICogQHJldHVybnMge1VuaXN0UG9pbnQgfCB1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHJlbGF0aXZlVG9Qb2ludChzdG9wcywgcmVsYXRpdmUpIHtcbiAgbGV0IGluZGV4ID0gMFxuXG4gIHdoaWxlIChpbmRleCA8IHN0b3BzLmxlbmd0aCAmJiBzdG9wc1tpbmRleF1bMF0gPD0gcmVsYXRpdmUpIHtcbiAgICBpbmRleCArPSAxXG4gIH1cblxuICAvLyBUaGVyZSBhcmUgbm8gcG9pbnRzOiB0aGF0IG9ubHkgb2NjdXJzIGlmIHRoZXJlIHdhcyBhbiBlbXB0eSBzdHJpbmcuXG4gIGlmIChpbmRleCA9PT0gMCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGNvbnN0IFtzdG9wUmVsYXRpdmUsIHN0b3BBYnNvbHV0ZV0gPSBzdG9wc1tpbmRleCAtIDFdXG4gIGNvbnN0IHJlc3QgPSByZWxhdGl2ZSAtIHN0b3BSZWxhdGl2ZVxuICByZXR1cm4ge1xuICAgIGxpbmU6IHN0b3BBYnNvbHV0ZS5saW5lLFxuICAgIGNvbHVtbjogc3RvcEFic29sdXRlLmNvbHVtbiArIHJlc3QsXG4gICAgb2Zmc2V0OiBzdG9wQWJzb2x1dGUub2Zmc2V0ICsgcmVzdFxuICB9XG59XG5cbi8vIENvcHkgZnJvbSA8aHR0cHM6Ly9naXRodWIuY29tL21pY3JvbWFyay9taWNyb21hcmsvYmxvYi9jZTM1OTNhL3BhY2thZ2VzL21pY3JvbWFyay9kZXYvbGliL2NyZWF0ZS10b2tlbml6ZXIuanMjTDU5NT5cbi8vIFRvIGRvOiBleHBvc2UgdGhhdD9cbi8qKlxuICogR2V0IHRoZSBzdHJpbmcgdmFsdWUgb2YgYSBzbGljZSBvZiBjaHVua3MuXG4gKlxuICogQHBhcmFtIHtBcnJheTxDaHVuaz59IGNodW5rc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplQ2h1bmtzKGNodW5rcykge1xuICBsZXQgaW5kZXggPSAtMVxuICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gIGNvbnN0IHJlc3VsdCA9IFtdXG4gIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gKi9cbiAgbGV0IGF0VGFiXG5cbiAgd2hpbGUgKCsraW5kZXggPCBjaHVua3MubGVuZ3RoKSB7XG4gICAgY29uc3QgY2h1bmsgPSBjaHVua3NbaW5kZXhdXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgbGV0IHZhbHVlXG5cbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBjaHVua1xuICAgIH0gZWxzZVxuICAgICAgc3dpdGNoIChjaHVuaykge1xuICAgICAgICBjYXNlIGNvZGVzLmNhcnJpYWdlUmV0dXJuOiB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuY3JcblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIGNvZGVzLmxpbmVGZWVkOiB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMubGZcblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBjYXNlIGNvZGVzLmNhcnJpYWdlUmV0dXJuTGluZUZlZWQ6IHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5jciArIHZhbHVlcy5sZlxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgY29kZXMuaG9yaXpvbnRhbFRhYjoge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmh0XG5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgLyogYzggaWdub3JlIG5leHQgNiAqL1xuICAgICAgICBjYXNlIGNvZGVzLnZpcnR1YWxTcGFjZToge1xuICAgICAgICAgIGlmIChhdFRhYikgY29udGludWVcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5zcGFjZVxuXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBhc3NlcnQodHlwZW9mIGNodW5rID09PSAnbnVtYmVyJywgJ2V4cGVjdGVkIG51bWJlcicpXG4gICAgICAgICAgLy8gQ3VycmVudGx5IG9ubHkgcmVwbGFjZW1lbnQgY2hhcmFjdGVyLlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1jb2RlLXBvaW50XG4gICAgICAgICAgdmFsdWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNodW5rKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBhdFRhYiA9IGNodW5rID09PSBjb2Rlcy5ob3Jpem9udGFsVGFiXG4gICAgcmVzdWx0LnB1c2godmFsdWUpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0LmpvaW4oJycpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/micromark-util-events-to-acorn@2.0.3/node_modules/micromark-util-events-to-acorn/dev/lib/index.js\n");

/***/ })

};
;