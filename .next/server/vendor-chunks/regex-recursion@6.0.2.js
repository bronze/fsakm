"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/regex-recursion@6.0.2";
exports.ids = ["vendor-chunks/regex-recursion@6.0.2"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/regex-recursion@6.0.2/node_modules/regex-recursion/src/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/regex-recursion@6.0.2/node_modules/regex-recursion/src/index.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   recursion: () => (/* binding */ recursion)\n/* harmony export */ });\n/* harmony import */ var regex_utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regex-utilities */ \"(rsc)/./node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js\");\n\n\nconst r = String.raw;\nconst gRToken = r`\\\\g<(?<gRNameOrNum>[^>&]+)&R=(?<gRDepth>[^>]+)>`;\nconst recursiveToken = r`\\(\\?R=(?<rDepth>[^\\)]+)\\)|${gRToken}`;\nconst namedCaptureDelim = r`\\(\\?<(?![=!])(?<captureName>[^>]+)>`;\nconst captureDelim = r`${namedCaptureDelim}|(?<unnamed>\\()(?!\\?)`;\nconst token = new RegExp(r`${namedCaptureDelim}|${recursiveToken}|\\(\\?|\\\\?.`, 'gsu');\nconst overlappingRecursionMsg = 'Cannot use multiple overlapping recursions';\n\n/**\n@param {string} pattern\n@param {{\n  flags?: string;\n  captureTransfers?: Map<number, Array<number>>;\n  hiddenCaptures?: Array<number>;\n  mode?: 'plugin' | 'external';\n}} [data]\n@returns {{\n  pattern: string;\n  captureTransfers: Map<number, Array<number>>;\n  hiddenCaptures: Array<number>;\n}}\n*/\nfunction recursion(pattern, data) {\n  const {hiddenCaptures, mode} = {\n    hiddenCaptures: [],\n    mode: 'plugin',\n    ...data,\n  };\n  // Capture transfer is used by <github.com/slevithan/oniguruma-to-es>\n  let captureTransfers = data?.captureTransfers ?? new Map();\n  // Keep the initial fail-check (which avoids unneeded processing) as fast as possible by testing\n  // without the accuracy improvement of using `hasUnescaped` with `Context.DEFAULT`\n  if (!(new RegExp(recursiveToken, 'su').test(pattern))) {\n    return {\n      pattern,\n      captureTransfers,\n      hiddenCaptures,\n    };\n  }\n  if (mode === 'plugin' && (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.hasUnescaped)(pattern, r`\\(\\?\\(DEFINE\\)`, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT)) {\n    throw new Error('DEFINE groups cannot be used with recursion');\n  }\n\n  const addedHiddenCaptures = [];\n  const hasNumberedBackref = (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.hasUnescaped)(pattern, r`\\\\[1-9]`, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT);\n  const groupContentsStartPos = new Map();\n  const openGroups = [];\n  let hasRecursed = false;\n  let numCharClassesOpen = 0;\n  let numCapturesPassed = 0;\n  let match;\n  token.lastIndex = 0;\n  while ((match = token.exec(pattern))) {\n    const {0: m, groups: {captureName, rDepth, gRNameOrNum, gRDepth}} = match;\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n\n      // `(?R=N)`\n      if (rDepth) {\n        assertMaxInBounds(rDepth);\n        if (hasRecursed) {\n          throw new Error(overlappingRecursionMsg);\n        }\n        if (hasNumberedBackref) {\n          // Could add support for numbered backrefs with extra effort, but it's probably not worth\n          // it. To trigger this error, the regex must include recursion and one of the following:\n          // - An interpolated regex that contains a numbered backref (since other numbered\n          //   backrefs are prevented by implicit flag n).\n          // - A numbered backref, when flag n is explicitly disabled.\n          // Note that Regex+'s extended syntax (atomic groups and sometimes subroutines) can also\n          // add numbered backrefs, but those work fine because external plugins like this one run\n          // *before* the transformation of built-in syntax extensions\n          throw new Error(\n            // When used in `external` mode by transpilers other than Regex+, backrefs might have\n            // gone through conversion from named to numbered, so avoid a misleading error\n            `${mode === 'external' ? 'Backrefs' : 'Numbered backrefs'} cannot be used with global recursion`\n          );\n        }\n        const left = pattern.slice(0, match.index);\n        const right = pattern.slice(token.lastIndex);\n        if ((0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.hasUnescaped)(right, recursiveToken, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT)) {\n          throw new Error(overlappingRecursionMsg);\n        }\n        const reps = +rDepth - 1;\n        pattern = makeRecursive(\n          left,\n          right,\n          reps,\n          false,\n          hiddenCaptures,\n          addedHiddenCaptures,\n          numCapturesPassed\n        );\n        captureTransfers = mapCaptureTransfers(\n          captureTransfers,\n          left,\n          reps,\n          addedHiddenCaptures.length,\n          0,\n          numCapturesPassed\n        );\n        // No need to parse further\n        break;\n      // `\\g<name&R=N>`, `\\g<number&R=N>`\n      } else if (gRNameOrNum) {\n        assertMaxInBounds(gRDepth);\n        let isWithinReffedGroup = false;\n        for (const g of openGroups) {\n          if (g.name === gRNameOrNum || g.num === +gRNameOrNum) {\n            isWithinReffedGroup = true;\n            if (g.hasRecursedWithin) {\n              throw new Error(overlappingRecursionMsg);\n            }\n            break;\n          }\n        }\n        if (!isWithinReffedGroup) {\n          throw new Error(r`Recursive \\g cannot be used outside the referenced group \"${\n            mode === 'external' ? gRNameOrNum : r`\\g<${gRNameOrNum}&R=${gRDepth}>`\n          }\"`);\n        }\n        const startPos = groupContentsStartPos.get(gRNameOrNum);\n        const groupContents = (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.getGroupContents)(pattern, startPos);\n        if (\n          hasNumberedBackref &&\n          (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.hasUnescaped)(groupContents, r`${namedCaptureDelim}|\\((?!\\?)`, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT)\n        ) {\n          throw new Error(\n            // When used in `external` mode by transpilers other than Regex+, backrefs might have\n            // gone through conversion from named to numbered, so avoid a misleading error\n            `${mode === 'external' ? 'Backrefs' : 'Numbered backrefs'} cannot be used with recursion of capturing groups`\n          );\n        }\n        const groupContentsLeft = pattern.slice(startPos, match.index);\n        const groupContentsRight = groupContents.slice(groupContentsLeft.length + m.length);\n        const numAddedHiddenCapturesPreExpansion = addedHiddenCaptures.length;\n        const reps = +gRDepth - 1;\n        const expansion = makeRecursive(\n          groupContentsLeft,\n          groupContentsRight,\n          reps,\n          true,\n          hiddenCaptures,\n          addedHiddenCaptures,\n          numCapturesPassed\n        );\n        captureTransfers = mapCaptureTransfers(\n          captureTransfers,\n          groupContentsLeft,\n          reps,\n          addedHiddenCaptures.length - numAddedHiddenCapturesPreExpansion,\n          numAddedHiddenCapturesPreExpansion,\n          numCapturesPassed\n        );\n        const pre = pattern.slice(0, startPos);\n        const post = pattern.slice(startPos + groupContents.length);\n        // Modify the string we're looping over\n        pattern = `${pre}${expansion}${post}`;\n        // Step forward for the next loop iteration\n        token.lastIndex += expansion.length - m.length - groupContentsLeft.length - groupContentsRight.length;\n        openGroups.forEach(g => g.hasRecursedWithin = true);\n        hasRecursed = true;\n      } else if (captureName) {\n        numCapturesPassed++;\n        groupContentsStartPos.set(String(numCapturesPassed), token.lastIndex);\n        groupContentsStartPos.set(captureName, token.lastIndex);\n        openGroups.push({\n          num: numCapturesPassed,\n          name: captureName,\n        });\n      } else if (m[0] === '(') {\n        const isUnnamedCapture = m === '(';\n        if (isUnnamedCapture) {\n          numCapturesPassed++;\n          groupContentsStartPos.set(String(numCapturesPassed), token.lastIndex);\n        }\n        openGroups.push(isUnnamedCapture ? {num: numCapturesPassed} : {});\n      } else if (m === ')') {\n        openGroups.pop();\n      }\n\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n\n  hiddenCaptures.push(...addedHiddenCaptures);\n\n  return {\n    pattern,\n    captureTransfers,\n    hiddenCaptures,\n  };\n}\n\n/**\n@param {string} max\n*/\nfunction assertMaxInBounds(max) {\n  const errMsg = `Max depth must be integer between 2 and 100; used ${max}`;\n  if (!/^[1-9]\\d*$/.test(max)) {\n    throw new Error(errMsg);\n  }\n  max = +max;\n  if (max < 2 || max > 100) {\n    throw new Error(errMsg);\n  }\n}\n\n/**\n@param {string} left\n@param {string} right\n@param {number} reps\n@param {boolean} isSubpattern\n@param {Array<number>} hiddenCaptures\n@param {Array<number>} addedHiddenCaptures\n@param {number} numCapturesPassed\n@returns {string}\n*/\nfunction makeRecursive(\n  left,\n  right,\n  reps,\n  isSubpattern,\n  hiddenCaptures,\n  addedHiddenCaptures,\n  numCapturesPassed\n) {\n  const namesInRecursed = new Set();\n  // Can skip this work if not needed\n  if (isSubpattern) {\n    (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.forEachUnescaped)(left + right, namedCaptureDelim, ({groups: {captureName}}) => {\n      namesInRecursed.add(captureName);\n    }, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT);\n  }\n  const rest = [\n    reps,\n    isSubpattern ? namesInRecursed : null,\n    hiddenCaptures,\n    addedHiddenCaptures,\n    numCapturesPassed,\n  ];\n  // Depth 2: 'left(?:left(?:)right)right'\n  // Depth 3: 'left(?:left(?:left(?:)right)right)right'\n  // Empty group in the middle separates tokens and absorbs a following quantifier if present\n  return `${left}${\n    repeatWithDepth(`(?:${left}`, 'forward', ...rest)\n  }(?:)${\n    repeatWithDepth(`${right})`, 'backward', ...rest)\n  }${right}`;\n}\n\n/**\n@param {string} pattern\n@param {'forward' | 'backward'} direction\n@param {number} reps\n@param {Set<string> | null} namesInRecursed\n@param {Array<number>} hiddenCaptures\n@param {Array<number>} addedHiddenCaptures\n@param {number} numCapturesPassed\n@returns {string}\n*/\nfunction repeatWithDepth(\n  pattern,\n  direction,\n  reps,\n  namesInRecursed,\n  hiddenCaptures,\n  addedHiddenCaptures,\n  numCapturesPassed\n) {\n  const startNum = 2;\n  const getDepthNum = i => direction === 'forward' ? (i + startNum) : (reps - i + startNum - 1);\n  let result = '';\n  for (let i = 0; i < reps; i++) {\n    const depthNum = getDepthNum(i);\n    result += (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.replaceUnescaped)(\n      pattern,\n      r`${captureDelim}|\\\\k<(?<backref>[^>]+)>`,\n      ({0: m, groups: {captureName, unnamed, backref}}) => {\n        if (backref && namesInRecursed && !namesInRecursed.has(backref)) {\n          // Don't alter backrefs to groups outside the recursed subpattern\n          return m;\n        }\n        const suffix = `_$${depthNum}`;\n        if (unnamed || captureName) {\n          const addedCaptureNum = numCapturesPassed + addedHiddenCaptures.length + 1;\n          addedHiddenCaptures.push(addedCaptureNum);\n          incrementIfAtLeast(hiddenCaptures, addedCaptureNum);\n          return unnamed ? m : `(?<${captureName}${suffix}>`;\n        }\n        return r`\\k<${backref}${suffix}>`;\n      },\n      regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT\n    );\n  }\n  return result;\n}\n\n/**\nUpdates the array in place by incrementing each value greater than or equal to the threshold.\n@param {Array<number>} arr\n@param {number} threshold\n*/\nfunction incrementIfAtLeast(arr, threshold) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= threshold) {\n      arr[i]++;\n    }\n  }\n}\n\n/**\n@param {Map<number, Array<number>>} captureTransfers\n@param {string} left\n@param {number} reps\n@param {number} numCapturesAddedInExpansion\n@param {number} numAddedHiddenCapturesPreExpansion\n@param {number} numCapturesPassed\n@returns {Map<number, Array<number>>}\n*/\nfunction mapCaptureTransfers(captureTransfers, left, reps, numCapturesAddedInExpansion, numAddedHiddenCapturesPreExpansion, numCapturesPassed) {\n  if (captureTransfers.size && numCapturesAddedInExpansion) {\n    let numCapturesInLeft = 0;\n    (0,regex_utilities__WEBPACK_IMPORTED_MODULE_0__.forEachUnescaped)(left, captureDelim, () => numCapturesInLeft++, regex_utilities__WEBPACK_IMPORTED_MODULE_0__.Context.DEFAULT);\n    // Is 0 for global recursion\n    const recursionDelimCaptureNum = numCapturesPassed - numCapturesInLeft + numAddedHiddenCapturesPreExpansion;\n    const newCaptureTransfers = new Map();\n    captureTransfers.forEach((from, to) => {\n      const numCapturesInRight = (numCapturesAddedInExpansion - (numCapturesInLeft * reps)) / reps;\n      const numCapturesAddedInLeft = numCapturesInLeft * reps;\n      const newTo = to > (recursionDelimCaptureNum + numCapturesInLeft) ? to + numCapturesAddedInExpansion : to;\n      const newFrom = [];\n      for (const f of from) {\n        // Before the recursed subpattern\n        if (f <= recursionDelimCaptureNum) {\n          newFrom.push(f);\n        // After the recursed subpattern\n        } else if (f > (recursionDelimCaptureNum + numCapturesInLeft + numCapturesInRight)) {\n          newFrom.push(f + numCapturesAddedInExpansion);\n        // Within the recursed subpattern, on the left of the recursion token\n        } else if (f <= (recursionDelimCaptureNum + numCapturesInLeft)) {\n          for (let i = 0; i <= reps; i++) {\n            newFrom.push(f + (numCapturesInLeft * i));\n          }\n        // Within the recursed subpattern, on the right of the recursion token\n        } else {\n          for (let i = 0; i <= reps; i++) {\n            newFrom.push(f + numCapturesAddedInLeft + (numCapturesInRight * i));\n          }\n        }\n      }\n      newCaptureTransfers.set(newTo, newFrom);\n    });\n    return newCaptureTransfers;\n  }\n  return captureTransfers;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVnZXgtcmVjdXJzaW9uQDYuMC4yL25vZGVfbW9kdWxlcy9yZWdleC1yZWN1cnNpb24vc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRHOztBQUU1RztBQUNBO0FBQ0EscURBQXFELFFBQVE7QUFDN0Q7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDLDZCQUE2QixrQkFBa0IsR0FBRyxlQUFlO0FBQ2pFOztBQUVBO0FBQ0EsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNCQUFzQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkRBQVksNkJBQTZCLG9EQUFPO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsNkRBQVksc0JBQXNCLG9EQUFPO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWUsNENBQTRDO0FBQ3RFO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQXdEO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2REFBWSx3QkFBd0Isb0RBQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBSUUiLCJzb3VyY2VzIjpbIi9ob21lL2Jyb256ZS9jb2RpbmcvZnNha20vbm9kZV9tb2R1bGVzLy5wbnBtL3JlZ2V4LXJlY3Vyc2lvbkA2LjAuMi9ub2RlX21vZHVsZXMvcmVnZXgtcmVjdXJzaW9uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbnRleHQsIGZvckVhY2hVbmVzY2FwZWQsIGdldEdyb3VwQ29udGVudHMsIGhhc1VuZXNjYXBlZCwgcmVwbGFjZVVuZXNjYXBlZH0gZnJvbSAncmVnZXgtdXRpbGl0aWVzJztcblxuY29uc3QgciA9IFN0cmluZy5yYXc7XG5jb25zdCBnUlRva2VuID0gcmBcXFxcZzwoPzxnUk5hbWVPck51bT5bXj4mXSspJlI9KD88Z1JEZXB0aD5bXj5dKyk+YDtcbmNvbnN0IHJlY3Vyc2l2ZVRva2VuID0gcmBcXChcXD9SPSg/PHJEZXB0aD5bXlxcKV0rKVxcKXwke2dSVG9rZW59YDtcbmNvbnN0IG5hbWVkQ2FwdHVyZURlbGltID0gcmBcXChcXD88KD8hWz0hXSkoPzxjYXB0dXJlTmFtZT5bXj5dKyk+YDtcbmNvbnN0IGNhcHR1cmVEZWxpbSA9IHJgJHtuYW1lZENhcHR1cmVEZWxpbX18KD88dW5uYW1lZD5cXCgpKD8hXFw/KWA7XG5jb25zdCB0b2tlbiA9IG5ldyBSZWdFeHAocmAke25hbWVkQ2FwdHVyZURlbGltfXwke3JlY3Vyc2l2ZVRva2VufXxcXChcXD98XFxcXD8uYCwgJ2dzdScpO1xuY29uc3Qgb3ZlcmxhcHBpbmdSZWN1cnNpb25Nc2cgPSAnQ2Fubm90IHVzZSBtdWx0aXBsZSBvdmVybGFwcGluZyByZWN1cnNpb25zJztcblxuLyoqXG5AcGFyYW0ge3N0cmluZ30gcGF0dGVyblxuQHBhcmFtIHt7XG4gIGZsYWdzPzogc3RyaW5nO1xuICBjYXB0dXJlVHJhbnNmZXJzPzogTWFwPG51bWJlciwgQXJyYXk8bnVtYmVyPj47XG4gIGhpZGRlbkNhcHR1cmVzPzogQXJyYXk8bnVtYmVyPjtcbiAgbW9kZT86ICdwbHVnaW4nIHwgJ2V4dGVybmFsJztcbn19IFtkYXRhXVxuQHJldHVybnMge3tcbiAgcGF0dGVybjogc3RyaW5nO1xuICBjYXB0dXJlVHJhbnNmZXJzOiBNYXA8bnVtYmVyLCBBcnJheTxudW1iZXI+PjtcbiAgaGlkZGVuQ2FwdHVyZXM6IEFycmF5PG51bWJlcj47XG59fVxuKi9cbmZ1bmN0aW9uIHJlY3Vyc2lvbihwYXR0ZXJuLCBkYXRhKSB7XG4gIGNvbnN0IHtoaWRkZW5DYXB0dXJlcywgbW9kZX0gPSB7XG4gICAgaGlkZGVuQ2FwdHVyZXM6IFtdLFxuICAgIG1vZGU6ICdwbHVnaW4nLFxuICAgIC4uLmRhdGEsXG4gIH07XG4gIC8vIENhcHR1cmUgdHJhbnNmZXIgaXMgdXNlZCBieSA8Z2l0aHViLmNvbS9zbGV2aXRoYW4vb25pZ3VydW1hLXRvLWVzPlxuICBsZXQgY2FwdHVyZVRyYW5zZmVycyA9IGRhdGE/LmNhcHR1cmVUcmFuc2ZlcnMgPz8gbmV3IE1hcCgpO1xuICAvLyBLZWVwIHRoZSBpbml0aWFsIGZhaWwtY2hlY2sgKHdoaWNoIGF2b2lkcyB1bm5lZWRlZCBwcm9jZXNzaW5nKSBhcyBmYXN0IGFzIHBvc3NpYmxlIGJ5IHRlc3RpbmdcbiAgLy8gd2l0aG91dCB0aGUgYWNjdXJhY3kgaW1wcm92ZW1lbnQgb2YgdXNpbmcgYGhhc1VuZXNjYXBlZGAgd2l0aCBgQ29udGV4dC5ERUZBVUxUYFxuICBpZiAoIShuZXcgUmVnRXhwKHJlY3Vyc2l2ZVRva2VuLCAnc3UnKS50ZXN0KHBhdHRlcm4pKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXR0ZXJuLFxuICAgICAgY2FwdHVyZVRyYW5zZmVycyxcbiAgICAgIGhpZGRlbkNhcHR1cmVzLFxuICAgIH07XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdwbHVnaW4nICYmIGhhc1VuZXNjYXBlZChwYXR0ZXJuLCByYFxcKFxcP1xcKERFRklORVxcKWAsIENvbnRleHQuREVGQVVMVCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RFRklORSBncm91cHMgY2Fubm90IGJlIHVzZWQgd2l0aCByZWN1cnNpb24nKTtcbiAgfVxuXG4gIGNvbnN0IGFkZGVkSGlkZGVuQ2FwdHVyZXMgPSBbXTtcbiAgY29uc3QgaGFzTnVtYmVyZWRCYWNrcmVmID0gaGFzVW5lc2NhcGVkKHBhdHRlcm4sIHJgXFxcXFsxLTldYCwgQ29udGV4dC5ERUZBVUxUKTtcbiAgY29uc3QgZ3JvdXBDb250ZW50c1N0YXJ0UG9zID0gbmV3IE1hcCgpO1xuICBjb25zdCBvcGVuR3JvdXBzID0gW107XG4gIGxldCBoYXNSZWN1cnNlZCA9IGZhbHNlO1xuICBsZXQgbnVtQ2hhckNsYXNzZXNPcGVuID0gMDtcbiAgbGV0IG51bUNhcHR1cmVzUGFzc2VkID0gMDtcbiAgbGV0IG1hdGNoO1xuICB0b2tlbi5sYXN0SW5kZXggPSAwO1xuICB3aGlsZSAoKG1hdGNoID0gdG9rZW4uZXhlYyhwYXR0ZXJuKSkpIHtcbiAgICBjb25zdCB7MDogbSwgZ3JvdXBzOiB7Y2FwdHVyZU5hbWUsIHJEZXB0aCwgZ1JOYW1lT3JOdW0sIGdSRGVwdGh9fSA9IG1hdGNoO1xuICAgIGlmIChtID09PSAnWycpIHtcbiAgICAgIG51bUNoYXJDbGFzc2VzT3BlbisrO1xuICAgIH0gZWxzZSBpZiAoIW51bUNoYXJDbGFzc2VzT3Blbikge1xuXG4gICAgICAvLyBgKD9SPU4pYFxuICAgICAgaWYgKHJEZXB0aCkge1xuICAgICAgICBhc3NlcnRNYXhJbkJvdW5kcyhyRGVwdGgpO1xuICAgICAgICBpZiAoaGFzUmVjdXJzZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob3ZlcmxhcHBpbmdSZWN1cnNpb25Nc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNOdW1iZXJlZEJhY2tyZWYpIHtcbiAgICAgICAgICAvLyBDb3VsZCBhZGQgc3VwcG9ydCBmb3IgbnVtYmVyZWQgYmFja3JlZnMgd2l0aCBleHRyYSBlZmZvcnQsIGJ1dCBpdCdzIHByb2JhYmx5IG5vdCB3b3J0aFxuICAgICAgICAgIC8vIGl0LiBUbyB0cmlnZ2VyIHRoaXMgZXJyb3IsIHRoZSByZWdleCBtdXN0IGluY2x1ZGUgcmVjdXJzaW9uIGFuZCBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICAgICAgICAvLyAtIEFuIGludGVycG9sYXRlZCByZWdleCB0aGF0IGNvbnRhaW5zIGEgbnVtYmVyZWQgYmFja3JlZiAoc2luY2Ugb3RoZXIgbnVtYmVyZWRcbiAgICAgICAgICAvLyAgIGJhY2tyZWZzIGFyZSBwcmV2ZW50ZWQgYnkgaW1wbGljaXQgZmxhZyBuKS5cbiAgICAgICAgICAvLyAtIEEgbnVtYmVyZWQgYmFja3JlZiwgd2hlbiBmbGFnIG4gaXMgZXhwbGljaXRseSBkaXNhYmxlZC5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgUmVnZXgrJ3MgZXh0ZW5kZWQgc3ludGF4IChhdG9taWMgZ3JvdXBzIGFuZCBzb21ldGltZXMgc3Vicm91dGluZXMpIGNhbiBhbHNvXG4gICAgICAgICAgLy8gYWRkIG51bWJlcmVkIGJhY2tyZWZzLCBidXQgdGhvc2Ugd29yayBmaW5lIGJlY2F1c2UgZXh0ZXJuYWwgcGx1Z2lucyBsaWtlIHRoaXMgb25lIHJ1blxuICAgICAgICAgIC8vICpiZWZvcmUqIHRoZSB0cmFuc2Zvcm1hdGlvbiBvZiBidWlsdC1pbiBzeW50YXggZXh0ZW5zaW9uc1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIC8vIFdoZW4gdXNlZCBpbiBgZXh0ZXJuYWxgIG1vZGUgYnkgdHJhbnNwaWxlcnMgb3RoZXIgdGhhbiBSZWdleCssIGJhY2tyZWZzIG1pZ2h0IGhhdmVcbiAgICAgICAgICAgIC8vIGdvbmUgdGhyb3VnaCBjb252ZXJzaW9uIGZyb20gbmFtZWQgdG8gbnVtYmVyZWQsIHNvIGF2b2lkIGEgbWlzbGVhZGluZyBlcnJvclxuICAgICAgICAgICAgYCR7bW9kZSA9PT0gJ2V4dGVybmFsJyA/ICdCYWNrcmVmcycgOiAnTnVtYmVyZWQgYmFja3JlZnMnfSBjYW5ub3QgYmUgdXNlZCB3aXRoIGdsb2JhbCByZWN1cnNpb25gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZWZ0ID0gcGF0dGVybi5zbGljZSgwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gcGF0dGVybi5zbGljZSh0b2tlbi5sYXN0SW5kZXgpO1xuICAgICAgICBpZiAoaGFzVW5lc2NhcGVkKHJpZ2h0LCByZWN1cnNpdmVUb2tlbiwgQ29udGV4dC5ERUZBVUxUKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihvdmVybGFwcGluZ1JlY3Vyc2lvbk1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVwcyA9ICtyRGVwdGggLSAxO1xuICAgICAgICBwYXR0ZXJuID0gbWFrZVJlY3Vyc2l2ZShcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgIHJlcHMsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgaGlkZGVuQ2FwdHVyZXMsXG4gICAgICAgICAgYWRkZWRIaWRkZW5DYXB0dXJlcyxcbiAgICAgICAgICBudW1DYXB0dXJlc1Bhc3NlZFxuICAgICAgICApO1xuICAgICAgICBjYXB0dXJlVHJhbnNmZXJzID0gbWFwQ2FwdHVyZVRyYW5zZmVycyhcbiAgICAgICAgICBjYXB0dXJlVHJhbnNmZXJzLFxuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgcmVwcyxcbiAgICAgICAgICBhZGRlZEhpZGRlbkNhcHR1cmVzLmxlbmd0aCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIG51bUNhcHR1cmVzUGFzc2VkXG4gICAgICAgICk7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gcGFyc2UgZnVydGhlclxuICAgICAgICBicmVhaztcbiAgICAgIC8vIGBcXGc8bmFtZSZSPU4+YCwgYFxcZzxudW1iZXImUj1OPmBcbiAgICAgIH0gZWxzZSBpZiAoZ1JOYW1lT3JOdW0pIHtcbiAgICAgICAgYXNzZXJ0TWF4SW5Cb3VuZHMoZ1JEZXB0aCk7XG4gICAgICAgIGxldCBpc1dpdGhpblJlZmZlZEdyb3VwID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgZyBvZiBvcGVuR3JvdXBzKSB7XG4gICAgICAgICAgaWYgKGcubmFtZSA9PT0gZ1JOYW1lT3JOdW0gfHwgZy5udW0gPT09ICtnUk5hbWVPck51bSkge1xuICAgICAgICAgICAgaXNXaXRoaW5SZWZmZWRHcm91cCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZy5oYXNSZWN1cnNlZFdpdGhpbikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob3ZlcmxhcHBpbmdSZWN1cnNpb25Nc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNXaXRoaW5SZWZmZWRHcm91cCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyYFJlY3Vyc2l2ZSBcXGcgY2Fubm90IGJlIHVzZWQgb3V0c2lkZSB0aGUgcmVmZXJlbmNlZCBncm91cCBcIiR7XG4gICAgICAgICAgICBtb2RlID09PSAnZXh0ZXJuYWwnID8gZ1JOYW1lT3JOdW0gOiByYFxcZzwke2dSTmFtZU9yTnVtfSZSPSR7Z1JEZXB0aH0+YFxuICAgICAgICAgIH1cImApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zID0gZ3JvdXBDb250ZW50c1N0YXJ0UG9zLmdldChnUk5hbWVPck51bSk7XG4gICAgICAgIGNvbnN0IGdyb3VwQ29udGVudHMgPSBnZXRHcm91cENvbnRlbnRzKHBhdHRlcm4sIHN0YXJ0UG9zKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGhhc051bWJlcmVkQmFja3JlZiAmJlxuICAgICAgICAgIGhhc1VuZXNjYXBlZChncm91cENvbnRlbnRzLCByYCR7bmFtZWRDYXB0dXJlRGVsaW19fFxcKCg/IVxcPylgLCBDb250ZXh0LkRFRkFVTFQpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIC8vIFdoZW4gdXNlZCBpbiBgZXh0ZXJuYWxgIG1vZGUgYnkgdHJhbnNwaWxlcnMgb3RoZXIgdGhhbiBSZWdleCssIGJhY2tyZWZzIG1pZ2h0IGhhdmVcbiAgICAgICAgICAgIC8vIGdvbmUgdGhyb3VnaCBjb252ZXJzaW9uIGZyb20gbmFtZWQgdG8gbnVtYmVyZWQsIHNvIGF2b2lkIGEgbWlzbGVhZGluZyBlcnJvclxuICAgICAgICAgICAgYCR7bW9kZSA9PT0gJ2V4dGVybmFsJyA/ICdCYWNrcmVmcycgOiAnTnVtYmVyZWQgYmFja3JlZnMnfSBjYW5ub3QgYmUgdXNlZCB3aXRoIHJlY3Vyc2lvbiBvZiBjYXB0dXJpbmcgZ3JvdXBzYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ3JvdXBDb250ZW50c0xlZnQgPSBwYXR0ZXJuLnNsaWNlKHN0YXJ0UG9zLCBtYXRjaC5pbmRleCk7XG4gICAgICAgIGNvbnN0IGdyb3VwQ29udGVudHNSaWdodCA9IGdyb3VwQ29udGVudHMuc2xpY2UoZ3JvdXBDb250ZW50c0xlZnQubGVuZ3RoICsgbS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBudW1BZGRlZEhpZGRlbkNhcHR1cmVzUHJlRXhwYW5zaW9uID0gYWRkZWRIaWRkZW5DYXB0dXJlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlcHMgPSArZ1JEZXB0aCAtIDE7XG4gICAgICAgIGNvbnN0IGV4cGFuc2lvbiA9IG1ha2VSZWN1cnNpdmUoXG4gICAgICAgICAgZ3JvdXBDb250ZW50c0xlZnQsXG4gICAgICAgICAgZ3JvdXBDb250ZW50c1JpZ2h0LFxuICAgICAgICAgIHJlcHMsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBoaWRkZW5DYXB0dXJlcyxcbiAgICAgICAgICBhZGRlZEhpZGRlbkNhcHR1cmVzLFxuICAgICAgICAgIG51bUNhcHR1cmVzUGFzc2VkXG4gICAgICAgICk7XG4gICAgICAgIGNhcHR1cmVUcmFuc2ZlcnMgPSBtYXBDYXB0dXJlVHJhbnNmZXJzKFxuICAgICAgICAgIGNhcHR1cmVUcmFuc2ZlcnMsXG4gICAgICAgICAgZ3JvdXBDb250ZW50c0xlZnQsXG4gICAgICAgICAgcmVwcyxcbiAgICAgICAgICBhZGRlZEhpZGRlbkNhcHR1cmVzLmxlbmd0aCAtIG51bUFkZGVkSGlkZGVuQ2FwdHVyZXNQcmVFeHBhbnNpb24sXG4gICAgICAgICAgbnVtQWRkZWRIaWRkZW5DYXB0dXJlc1ByZUV4cGFuc2lvbixcbiAgICAgICAgICBudW1DYXB0dXJlc1Bhc3NlZFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBwcmUgPSBwYXR0ZXJuLnNsaWNlKDAsIHN0YXJ0UG9zKTtcbiAgICAgICAgY29uc3QgcG9zdCA9IHBhdHRlcm4uc2xpY2Uoc3RhcnRQb3MgKyBncm91cENvbnRlbnRzLmxlbmd0aCk7XG4gICAgICAgIC8vIE1vZGlmeSB0aGUgc3RyaW5nIHdlJ3JlIGxvb3Bpbmcgb3ZlclxuICAgICAgICBwYXR0ZXJuID0gYCR7cHJlfSR7ZXhwYW5zaW9ufSR7cG9zdH1gO1xuICAgICAgICAvLyBTdGVwIGZvcndhcmQgZm9yIHRoZSBuZXh0IGxvb3AgaXRlcmF0aW9uXG4gICAgICAgIHRva2VuLmxhc3RJbmRleCArPSBleHBhbnNpb24ubGVuZ3RoIC0gbS5sZW5ndGggLSBncm91cENvbnRlbnRzTGVmdC5sZW5ndGggLSBncm91cENvbnRlbnRzUmlnaHQubGVuZ3RoO1xuICAgICAgICBvcGVuR3JvdXBzLmZvckVhY2goZyA9PiBnLmhhc1JlY3Vyc2VkV2l0aGluID0gdHJ1ZSk7XG4gICAgICAgIGhhc1JlY3Vyc2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2FwdHVyZU5hbWUpIHtcbiAgICAgICAgbnVtQ2FwdHVyZXNQYXNzZWQrKztcbiAgICAgICAgZ3JvdXBDb250ZW50c1N0YXJ0UG9zLnNldChTdHJpbmcobnVtQ2FwdHVyZXNQYXNzZWQpLCB0b2tlbi5sYXN0SW5kZXgpO1xuICAgICAgICBncm91cENvbnRlbnRzU3RhcnRQb3Muc2V0KGNhcHR1cmVOYW1lLCB0b2tlbi5sYXN0SW5kZXgpO1xuICAgICAgICBvcGVuR3JvdXBzLnB1c2goe1xuICAgICAgICAgIG51bTogbnVtQ2FwdHVyZXNQYXNzZWQsXG4gICAgICAgICAgbmFtZTogY2FwdHVyZU5hbWUsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChtWzBdID09PSAnKCcpIHtcbiAgICAgICAgY29uc3QgaXNVbm5hbWVkQ2FwdHVyZSA9IG0gPT09ICcoJztcbiAgICAgICAgaWYgKGlzVW5uYW1lZENhcHR1cmUpIHtcbiAgICAgICAgICBudW1DYXB0dXJlc1Bhc3NlZCsrO1xuICAgICAgICAgIGdyb3VwQ29udGVudHNTdGFydFBvcy5zZXQoU3RyaW5nKG51bUNhcHR1cmVzUGFzc2VkKSwgdG9rZW4ubGFzdEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBvcGVuR3JvdXBzLnB1c2goaXNVbm5hbWVkQ2FwdHVyZSA/IHtudW06IG51bUNhcHR1cmVzUGFzc2VkfSA6IHt9KTtcbiAgICAgIH0gZWxzZSBpZiAobSA9PT0gJyknKSB7XG4gICAgICAgIG9wZW5Hcm91cHMucG9wKCk7XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKG0gPT09ICddJykge1xuICAgICAgbnVtQ2hhckNsYXNzZXNPcGVuLS07XG4gICAgfVxuICB9XG5cbiAgaGlkZGVuQ2FwdHVyZXMucHVzaCguLi5hZGRlZEhpZGRlbkNhcHR1cmVzKTtcblxuICByZXR1cm4ge1xuICAgIHBhdHRlcm4sXG4gICAgY2FwdHVyZVRyYW5zZmVycyxcbiAgICBoaWRkZW5DYXB0dXJlcyxcbiAgfTtcbn1cblxuLyoqXG5AcGFyYW0ge3N0cmluZ30gbWF4XG4qL1xuZnVuY3Rpb24gYXNzZXJ0TWF4SW5Cb3VuZHMobWF4KSB7XG4gIGNvbnN0IGVyck1zZyA9IGBNYXggZGVwdGggbXVzdCBiZSBpbnRlZ2VyIGJldHdlZW4gMiBhbmQgMTAwOyB1c2VkICR7bWF4fWA7XG4gIGlmICghL15bMS05XVxcZCokLy50ZXN0KG1heCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgfVxuICBtYXggPSArbWF4O1xuICBpZiAobWF4IDwgMiB8fCBtYXggPiAxMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgfVxufVxuXG4vKipcbkBwYXJhbSB7c3RyaW5nfSBsZWZ0XG5AcGFyYW0ge3N0cmluZ30gcmlnaHRcbkBwYXJhbSB7bnVtYmVyfSByZXBzXG5AcGFyYW0ge2Jvb2xlYW59IGlzU3VicGF0dGVyblxuQHBhcmFtIHtBcnJheTxudW1iZXI+fSBoaWRkZW5DYXB0dXJlc1xuQHBhcmFtIHtBcnJheTxudW1iZXI+fSBhZGRlZEhpZGRlbkNhcHR1cmVzXG5AcGFyYW0ge251bWJlcn0gbnVtQ2FwdHVyZXNQYXNzZWRcbkByZXR1cm5zIHtzdHJpbmd9XG4qL1xuZnVuY3Rpb24gbWFrZVJlY3Vyc2l2ZShcbiAgbGVmdCxcbiAgcmlnaHQsXG4gIHJlcHMsXG4gIGlzU3VicGF0dGVybixcbiAgaGlkZGVuQ2FwdHVyZXMsXG4gIGFkZGVkSGlkZGVuQ2FwdHVyZXMsXG4gIG51bUNhcHR1cmVzUGFzc2VkXG4pIHtcbiAgY29uc3QgbmFtZXNJblJlY3Vyc2VkID0gbmV3IFNldCgpO1xuICAvLyBDYW4gc2tpcCB0aGlzIHdvcmsgaWYgbm90IG5lZWRlZFxuICBpZiAoaXNTdWJwYXR0ZXJuKSB7XG4gICAgZm9yRWFjaFVuZXNjYXBlZChsZWZ0ICsgcmlnaHQsIG5hbWVkQ2FwdHVyZURlbGltLCAoe2dyb3Vwczoge2NhcHR1cmVOYW1lfX0pID0+IHtcbiAgICAgIG5hbWVzSW5SZWN1cnNlZC5hZGQoY2FwdHVyZU5hbWUpO1xuICAgIH0sIENvbnRleHQuREVGQVVMVCk7XG4gIH1cbiAgY29uc3QgcmVzdCA9IFtcbiAgICByZXBzLFxuICAgIGlzU3VicGF0dGVybiA/IG5hbWVzSW5SZWN1cnNlZCA6IG51bGwsXG4gICAgaGlkZGVuQ2FwdHVyZXMsXG4gICAgYWRkZWRIaWRkZW5DYXB0dXJlcyxcbiAgICBudW1DYXB0dXJlc1Bhc3NlZCxcbiAgXTtcbiAgLy8gRGVwdGggMjogJ2xlZnQoPzpsZWZ0KD86KXJpZ2h0KXJpZ2h0J1xuICAvLyBEZXB0aCAzOiAnbGVmdCg/OmxlZnQoPzpsZWZ0KD86KXJpZ2h0KXJpZ2h0KXJpZ2h0J1xuICAvLyBFbXB0eSBncm91cCBpbiB0aGUgbWlkZGxlIHNlcGFyYXRlcyB0b2tlbnMgYW5kIGFic29yYnMgYSBmb2xsb3dpbmcgcXVhbnRpZmllciBpZiBwcmVzZW50XG4gIHJldHVybiBgJHtsZWZ0fSR7XG4gICAgcmVwZWF0V2l0aERlcHRoKGAoPzoke2xlZnR9YCwgJ2ZvcndhcmQnLCAuLi5yZXN0KVxuICB9KD86KSR7XG4gICAgcmVwZWF0V2l0aERlcHRoKGAke3JpZ2h0fSlgLCAnYmFja3dhcmQnLCAuLi5yZXN0KVxuICB9JHtyaWdodH1gO1xufVxuXG4vKipcbkBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuXG5AcGFyYW0geydmb3J3YXJkJyB8ICdiYWNrd2FyZCd9IGRpcmVjdGlvblxuQHBhcmFtIHtudW1iZXJ9IHJlcHNcbkBwYXJhbSB7U2V0PHN0cmluZz4gfCBudWxsfSBuYW1lc0luUmVjdXJzZWRcbkBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gaGlkZGVuQ2FwdHVyZXNcbkBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYWRkZWRIaWRkZW5DYXB0dXJlc1xuQHBhcmFtIHtudW1iZXJ9IG51bUNhcHR1cmVzUGFzc2VkXG5AcmV0dXJucyB7c3RyaW5nfVxuKi9cbmZ1bmN0aW9uIHJlcGVhdFdpdGhEZXB0aChcbiAgcGF0dGVybixcbiAgZGlyZWN0aW9uLFxuICByZXBzLFxuICBuYW1lc0luUmVjdXJzZWQsXG4gIGhpZGRlbkNhcHR1cmVzLFxuICBhZGRlZEhpZGRlbkNhcHR1cmVzLFxuICBudW1DYXB0dXJlc1Bhc3NlZFxuKSB7XG4gIGNvbnN0IHN0YXJ0TnVtID0gMjtcbiAgY29uc3QgZ2V0RGVwdGhOdW0gPSBpID0+IGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnID8gKGkgKyBzdGFydE51bSkgOiAocmVwcyAtIGkgKyBzdGFydE51bSAtIDEpO1xuICBsZXQgcmVzdWx0ID0gJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVwczsgaSsrKSB7XG4gICAgY29uc3QgZGVwdGhOdW0gPSBnZXREZXB0aE51bShpKTtcbiAgICByZXN1bHQgKz0gcmVwbGFjZVVuZXNjYXBlZChcbiAgICAgIHBhdHRlcm4sXG4gICAgICByYCR7Y2FwdHVyZURlbGltfXxcXFxcazwoPzxiYWNrcmVmPltePl0rKT5gLFxuICAgICAgKHswOiBtLCBncm91cHM6IHtjYXB0dXJlTmFtZSwgdW5uYW1lZCwgYmFja3JlZn19KSA9PiB7XG4gICAgICAgIGlmIChiYWNrcmVmICYmIG5hbWVzSW5SZWN1cnNlZCAmJiAhbmFtZXNJblJlY3Vyc2VkLmhhcyhiYWNrcmVmKSkge1xuICAgICAgICAgIC8vIERvbid0IGFsdGVyIGJhY2tyZWZzIHRvIGdyb3VwcyBvdXRzaWRlIHRoZSByZWN1cnNlZCBzdWJwYXR0ZXJuXG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VmZml4ID0gYF8kJHtkZXB0aE51bX1gO1xuICAgICAgICBpZiAodW5uYW1lZCB8fCBjYXB0dXJlTmFtZSkge1xuICAgICAgICAgIGNvbnN0IGFkZGVkQ2FwdHVyZU51bSA9IG51bUNhcHR1cmVzUGFzc2VkICsgYWRkZWRIaWRkZW5DYXB0dXJlcy5sZW5ndGggKyAxO1xuICAgICAgICAgIGFkZGVkSGlkZGVuQ2FwdHVyZXMucHVzaChhZGRlZENhcHR1cmVOdW0pO1xuICAgICAgICAgIGluY3JlbWVudElmQXRMZWFzdChoaWRkZW5DYXB0dXJlcywgYWRkZWRDYXB0dXJlTnVtKTtcbiAgICAgICAgICByZXR1cm4gdW5uYW1lZCA/IG0gOiBgKD88JHtjYXB0dXJlTmFtZX0ke3N1ZmZpeH0+YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmBcXGs8JHtiYWNrcmVmfSR7c3VmZml4fT5gO1xuICAgICAgfSxcbiAgICAgIENvbnRleHQuREVGQVVMVFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG5VcGRhdGVzIHRoZSBhcnJheSBpbiBwbGFjZSBieSBpbmNyZW1lbnRpbmcgZWFjaCB2YWx1ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHRocmVzaG9sZC5cbkBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYXJyXG5AcGFyYW0ge251bWJlcn0gdGhyZXNob2xkXG4qL1xuZnVuY3Rpb24gaW5jcmVtZW50SWZBdExlYXN0KGFyciwgdGhyZXNob2xkKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSA+PSB0aHJlc2hvbGQpIHtcbiAgICAgIGFycltpXSsrO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbkBwYXJhbSB7TWFwPG51bWJlciwgQXJyYXk8bnVtYmVyPj59IGNhcHR1cmVUcmFuc2ZlcnNcbkBwYXJhbSB7c3RyaW5nfSBsZWZ0XG5AcGFyYW0ge251bWJlcn0gcmVwc1xuQHBhcmFtIHtudW1iZXJ9IG51bUNhcHR1cmVzQWRkZWRJbkV4cGFuc2lvblxuQHBhcmFtIHtudW1iZXJ9IG51bUFkZGVkSGlkZGVuQ2FwdHVyZXNQcmVFeHBhbnNpb25cbkBwYXJhbSB7bnVtYmVyfSBudW1DYXB0dXJlc1Bhc3NlZFxuQHJldHVybnMge01hcDxudW1iZXIsIEFycmF5PG51bWJlcj4+fVxuKi9cbmZ1bmN0aW9uIG1hcENhcHR1cmVUcmFuc2ZlcnMoY2FwdHVyZVRyYW5zZmVycywgbGVmdCwgcmVwcywgbnVtQ2FwdHVyZXNBZGRlZEluRXhwYW5zaW9uLCBudW1BZGRlZEhpZGRlbkNhcHR1cmVzUHJlRXhwYW5zaW9uLCBudW1DYXB0dXJlc1Bhc3NlZCkge1xuICBpZiAoY2FwdHVyZVRyYW5zZmVycy5zaXplICYmIG51bUNhcHR1cmVzQWRkZWRJbkV4cGFuc2lvbikge1xuICAgIGxldCBudW1DYXB0dXJlc0luTGVmdCA9IDA7XG4gICAgZm9yRWFjaFVuZXNjYXBlZChsZWZ0LCBjYXB0dXJlRGVsaW0sICgpID0+IG51bUNhcHR1cmVzSW5MZWZ0KyssIENvbnRleHQuREVGQVVMVCk7XG4gICAgLy8gSXMgMCBmb3IgZ2xvYmFsIHJlY3Vyc2lvblxuICAgIGNvbnN0IHJlY3Vyc2lvbkRlbGltQ2FwdHVyZU51bSA9IG51bUNhcHR1cmVzUGFzc2VkIC0gbnVtQ2FwdHVyZXNJbkxlZnQgKyBudW1BZGRlZEhpZGRlbkNhcHR1cmVzUHJlRXhwYW5zaW9uO1xuICAgIGNvbnN0IG5ld0NhcHR1cmVUcmFuc2ZlcnMgPSBuZXcgTWFwKCk7XG4gICAgY2FwdHVyZVRyYW5zZmVycy5mb3JFYWNoKChmcm9tLCB0bykgPT4ge1xuICAgICAgY29uc3QgbnVtQ2FwdHVyZXNJblJpZ2h0ID0gKG51bUNhcHR1cmVzQWRkZWRJbkV4cGFuc2lvbiAtIChudW1DYXB0dXJlc0luTGVmdCAqIHJlcHMpKSAvIHJlcHM7XG4gICAgICBjb25zdCBudW1DYXB0dXJlc0FkZGVkSW5MZWZ0ID0gbnVtQ2FwdHVyZXNJbkxlZnQgKiByZXBzO1xuICAgICAgY29uc3QgbmV3VG8gPSB0byA+IChyZWN1cnNpb25EZWxpbUNhcHR1cmVOdW0gKyBudW1DYXB0dXJlc0luTGVmdCkgPyB0byArIG51bUNhcHR1cmVzQWRkZWRJbkV4cGFuc2lvbiA6IHRvO1xuICAgICAgY29uc3QgbmV3RnJvbSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBmIG9mIGZyb20pIHtcbiAgICAgICAgLy8gQmVmb3JlIHRoZSByZWN1cnNlZCBzdWJwYXR0ZXJuXG4gICAgICAgIGlmIChmIDw9IHJlY3Vyc2lvbkRlbGltQ2FwdHVyZU51bSkge1xuICAgICAgICAgIG5ld0Zyb20ucHVzaChmKTtcbiAgICAgICAgLy8gQWZ0ZXIgdGhlIHJlY3Vyc2VkIHN1YnBhdHRlcm5cbiAgICAgICAgfSBlbHNlIGlmIChmID4gKHJlY3Vyc2lvbkRlbGltQ2FwdHVyZU51bSArIG51bUNhcHR1cmVzSW5MZWZ0ICsgbnVtQ2FwdHVyZXNJblJpZ2h0KSkge1xuICAgICAgICAgIG5ld0Zyb20ucHVzaChmICsgbnVtQ2FwdHVyZXNBZGRlZEluRXhwYW5zaW9uKTtcbiAgICAgICAgLy8gV2l0aGluIHRoZSByZWN1cnNlZCBzdWJwYXR0ZXJuLCBvbiB0aGUgbGVmdCBvZiB0aGUgcmVjdXJzaW9uIHRva2VuXG4gICAgICAgIH0gZWxzZSBpZiAoZiA8PSAocmVjdXJzaW9uRGVsaW1DYXB0dXJlTnVtICsgbnVtQ2FwdHVyZXNJbkxlZnQpKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcmVwczsgaSsrKSB7XG4gICAgICAgICAgICBuZXdGcm9tLnB1c2goZiArIChudW1DYXB0dXJlc0luTGVmdCAqIGkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIC8vIFdpdGhpbiB0aGUgcmVjdXJzZWQgc3VicGF0dGVybiwgb24gdGhlIHJpZ2h0IG9mIHRoZSByZWN1cnNpb24gdG9rZW5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSByZXBzOyBpKyspIHtcbiAgICAgICAgICAgIG5ld0Zyb20ucHVzaChmICsgbnVtQ2FwdHVyZXNBZGRlZEluTGVmdCArIChudW1DYXB0dXJlc0luUmlnaHQgKiBpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXdDYXB0dXJlVHJhbnNmZXJzLnNldChuZXdUbywgbmV3RnJvbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0NhcHR1cmVUcmFuc2ZlcnM7XG4gIH1cbiAgcmV0dXJuIGNhcHR1cmVUcmFuc2ZlcnM7XG59XG5cbmV4cG9ydCB7XG4gIHJlY3Vyc2lvbixcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/regex-recursion@6.0.2/node_modules/regex-recursion/src/index.js\n");

/***/ })

};
;